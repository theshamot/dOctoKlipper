V// source: plugin/bedlevelvisualizer/js/knockout-sortable.1.2.0.js\u000a// knockout-sortable 1.2.0 | (c) 2019 Ryan Niemeyer |  http://www.opensource.org/licenses/mit-license\u000a;(function(factory) {\u000a    if (typeof define === "function" && define.amd) {\u000a        // AMD anonymous module\u000a        define(["knockout", "jquery", "jquery-ui/ui/widgets/sortable", "jquery-ui/ui/widgets/draggable", "jquery-ui/ui/widgets/droppable"], factory);\u000a    } else if (typeof require === "function" && typeof exports === "object" && typeof module === "object") {\u000a        // CommonJS module\u000a        var ko = require("knockout"),\u000a            jQuery = require("jquery");\u000a        require("jquery-ui/ui/widgets/sortable");\u000a        require("jquery-ui/ui/widgets/draggable");\u000a        require("jquery-ui/ui/widgets/droppable");\u000a        factory(ko, jQuery);\u000a    } else {\u000a        // No module loader (plain <script> tag) - put directly in global namespace\u000a        factory(window.ko, window.jQuery);\u000a    }\u000a})(function(ko, $) {\u000a    var ITEMKEY = "ko_sortItem",\u000a        INDEXKEY = "ko_sourceIndex",\u000a        LISTKEY = "ko_sortList",\u000a        PARENTKEY = "ko_parentList",\u000a        DRAGKEY = "ko_dragItem",\u000a        unwrap = ko.utils.unwrapObservable,\u000a        dataGet = ko.utils.domData.get,\u000a        dataSet = ko.utils.domData.set,\u000a        version = $.ui && $.ui.version,\u000a        //1.8.24 included a fix for how events were triggered in nested sortables. indexOf checks will fail if version starts with that value (0 vs. -1)\u000a        hasNestedSortableFix = version && version.indexOf("1.6.") && version.indexOf("1.7.") && (version.indexOf("1.8.") || version === "1.8.24");\u000a\u000a    //internal afterRender that adds meta-data to children\u000a    var addMetaDataAfterRender = function(elements, data) {\u000a        ko.utils.arrayForEach(elements, function(element) {\u000a            if (element.nodeType === 1) {\u000a                dataSet(element, ITEMKEY, data);\u000a                dataSet(element, PARENTKEY, dataGet(element.parentNode, LISTKEY));\u000a            }\u000a        });\u000a    };\u000a\u000a    //prepare the proper options for the template binding\u000a    var prepareTemplateOptions = function(valueAccessor, dataName) {\u000a        var result = {},\u000a            options = {},\u000a            actualAfterRender;\u000a\u000a        //build our options to pass to the template engine\u000a        if (ko.utils.peekObservable(valueAccessor()).data) {\u000a            options = unwrap(valueAccessor() || {});\u000a            result[dataName] = options.data;\u000a            if (options.hasOwnProperty("template")) {\u000a                result.name = options.template;\u000a            }\u000a        } else {\u000a            result[dataName] = valueAccessor();\u000a        }\u000a\u000a        ko.utils.arrayForEach(["afterAdd", "afterRender", "as", "beforeRemove", "includeDestroyed", "templateEngine", "templateOptions", "nodes"], function (option) {\u000a            if (options.hasOwnProperty(option)) {\u000a                result[option] = options[option];\u000a            } else if (ko.bindingHandlers.sortable.hasOwnProperty(option)) {\u000a                result[option] = ko.bindingHandlers.sortable[option];\u000a            }\u000a        });\u000a\u000a        //use an afterRender function to add meta-data\u000a        if (dataName === "foreach") {\u000a            if (result.afterRender) {\u000a                //wrap the existing function, if it was passed\u000a                actualAfterRender = result.afterRender;\u000a                result.afterRender = function(element, data) {\u000a                    addMetaDataAfterRender.call(data, element, data);\u000a                    actualAfterRender.call(data, element, data);\u000a                };\u000a            } else {\u000a                result.afterRender = addMetaDataAfterRender;\u000a            }\u000a        }\u000a\u000a        //return options to pass to the template binding\u000a        return result;\u000a    };\u000a\u000a    var updateIndexFromDestroyedItems = function(index, items) {\u000a        var unwrapped = unwrap(items);\u000a\u000a        if (unwrapped) {\u000a            for (var i = 0; i <= index; i++) {\u000a                //add one for every destroyed item we find before the targetIndex in the target array\u000a                if (unwrapped[i] && unwrap(unwrapped[i]._destroy)) {\u000a                    index++;\u000a                }\u000a            }\u000a        }\u000a\u000a        return index;\u000a    };\u000a\u000a    //remove problematic leading/trailing whitespace from templates\u000a    var stripTemplateWhitespace = function(element, name) {\u000a        var templateSource,\u000a            templateElement;\u000a\u000a        //process named templates\u000a        if (name) {\u000a            templateElement = document.getElementById(name);\u000a            if (templateElement) {\u000a                templateSource = new ko.templateSources.domElement(templateElement);\u000a                templateSource.text($.trim(templateSource.text()));\u000a            }\u000a        }\u000a        else {\u000a            //remove leading/trailing non-elements from anonymous templates\u000a            $(element).contents().each(function() {\u000a                if (this && this.nodeType !== 1) {\u000a                    element.removeChild(this);\u000a                }\u000a            });\u000a        }\u000a    };\u000a\u000a    //connect items with observableArrays\u000a    ko.bindingHandlers.sortable = {\u000a        init: function(element, valueAccessor, allBindingsAccessor, data, context) {\u000a            var $element = $(element),\u000a                value = unwrap(valueAccessor()) || {},\u000a                templateOptions = prepareTemplateOptions(valueAccessor, "foreach"),\u000a                sortable = {},\u000a                startActual, updateActual;\u000a\u000a            stripTemplateWhitespace(element, templateOptions.name);\u000a\u000a            //build a new object that has the global options with overrides from the binding\u000a            $.extend(true, sortable, ko.bindingHandlers.sortable);\u000a            if (value.options && sortable.options) {\u000a                ko.utils.extend(sortable.options, value.options);\u000a                delete value.options;\u000a            }\u000a            ko.utils.extend(sortable, value);\u000a\u000a            //if allowDrop is an observable or a function, then execute it in a computed observable\u000a            if (sortable.connectClass && (ko.isObservable(sortable.allowDrop) || typeof sortable.allowDrop == "function")) {\u000a                ko.computed({\u000a                    read: function() {\u000a                        var value = unwrap(sortable.allowDrop),\u000a                            shouldAdd = typeof value == "function" ? value.call(this, templateOptions.foreach) : value;\u000a                        ko.utils.toggleDomNodeCssClass(element, sortable.connectClass, shouldAdd);\u000a                    },\u000a                    disposeWhenNodeIsRemoved: element\u000a                }, this);\u000a            } else {\u000a                ko.utils.toggleDomNodeCssClass(element, sortable.connectClass, sortable.allowDrop);\u000a            }\u000a\u000a            //wrap the template binding\u000a            ko.bindingHandlers.template.init(element, function() { return templateOptions; }, allBindingsAccessor, data, context);\u000a\u000a            //keep a reference to start/update functions that might have been passed in\u000a            startActual = sortable.options.start;\u000a            updateActual = sortable.options.update;\u000a\u000a            //ensure draggable table row cells maintain their width while dragging (unless a helper is provided)\u000a            if ( !sortable.options.helper ) {\u000a                sortable.options.helper = function(e, ui) {\u000a                    if (ui.is("tr")) {\u000a                        ui.children().each(function() {\u000a                            $(this).width($(this).width());\u000a                        });\u000a                    }\u000a                    return ui;\u000a                };\u000a            }\u000a\u000a            //initialize sortable binding after template binding has rendered in update function\u000a            var createTimeout = setTimeout(function() {\u000a                var dragItem;\u000a                var originalReceive = sortable.options.receive;\u000a\u000a                $element.sortable(ko.utils.extend(sortable.options, {\u000a                    start: function(event, ui) {\u000a                        //track original index\u000a                        var el = ui.item[0];\u000a                        dataSet(el, INDEXKEY, ko.utils.arrayIndexOf(ui.item.parent().children(), el));\u000a\u000a                        //make sure that fields have a chance to update model\u000a                        ui.item.find("input:focus").change();\u000a                        if (startActual) {\u000a                            startActual.apply(this, arguments);\u000a                        }\u000a                    },\u000a                    receive: function(event, ui) {\u000a                        //optionally apply an existing receive handler\u000a                        if (typeof originalReceive === "function") {\u000a                            originalReceive.call(this, event, ui);\u000a                        }\u000a\u000a                        dragItem = dataGet(ui.item[0], DRAGKEY);\u000a                        if (dragItem) {\u000a                            //copy the model item, if a clone option is provided\u000a                            if (dragItem.clone) {\u000a                                dragItem = dragItem.clone();\u000a                            }\u000a\u000a                            //configure a handler to potentially manipulate item before drop\u000a                            if (sortable.dragged) {\u000a                                dragItem = sortable.dragged.call(this, dragItem, event, ui) || dragItem;\u000a                            }\u000a                        }\u000a                    },\u000a                    update: function(event, ui) {\u000a                        var sourceParent, targetParent, sourceIndex, targetIndex, arg,\u000a                            el = ui.item[0],\u000a                            parentEl = ui.item.parent()[0],\u000a                            item = dataGet(el, ITEMKEY) || dragItem;\u000a\u000a                        if (!item) {\u000a                            $(el).remove();\u000a                        }\u000a                        dragItem = null;\u000a\u000a                        //make sure that moves only run once, as update fires on multiple containers\u000a                        if (item && (this === parentEl) || (!hasNestedSortableFix && $.contains(this, parentEl))) {\u000a                            //identify parents\u000a                            sourceParent = dataGet(el, PARENTKEY);\u000a                            sourceIndex = dataGet(el, INDEXKEY);\u000a                            targetParent = dataGet(el.parentNode, LISTKEY);\u000a                            targetIndex = ko.utils.arrayIndexOf(ui.item.parent().children(), el);\u000a\u000a                            //take destroyed items into consideration\u000a                            if (!templateOptions.includeDestroyed) {\u000a                                sourceIndex = updateIndexFromDestroyedItems(sourceIndex, sourceParent);\u000a                                targetIndex = updateIndexFromDestroyedItems(targetIndex, targetParent);\u000a                            }\u000a\u000a                            //build up args for the callbacks\u000a                            if (sortable.beforeMove || sortable.afterMove) {\u000a                                arg = {\u000a                                    item: item,\u000a                                    sourceParent: sourceParent,\u000a                                    sourceParentNode: sourceParent && ui.sender || el.parentNode,\u000a                                    sourceIndex: sourceIndex,\u000a                                    targetParent: targetParent,\u000a                                    targetIndex: targetIndex,\u000a                                    cancelDrop: false\u000a                                };\u000a\u000a                                //execute the configured callback prior to actually moving items\u000a                                if (sortable.beforeMove) {\u000a                                    sortable.beforeMove.call(this, arg, event, ui);\u000a                                }\u000a                            }\u000a\u000a                            //call cancel on the correct list, so KO can take care of DOM manipulation\u000a                            if (sourceParent) {\u000a                                $(sourceParent === targetParent ? this : ui.sender || this).sortable("cancel");\u000a                            }\u000a                            //for a draggable item just remove the element\u000a                            else {\u000a                                $(el).remove();\u000a                            }\u000a\u000a                            //if beforeMove told us to cancel, then we are done\u000a                            if (arg && arg.cancelDrop) {\u000a                                return;\u000a                            }\u000a\u000a                            //if the strategy option is unset or false, employ the order strategy involving removal and insertion of items\u000a                            if (!sortable.hasOwnProperty("strategyMove") || sortable.strategyMove === false) {\u000a                                //do the actual move\u000a                                if (targetIndex >= 0) {\u000a                                    if (sourceParent) {\u000a                                        sourceParent.splice(sourceIndex, 1);\u000a\u000a                                        //if using deferred updates plugin, force updates\u000a                                        if (ko.processAllDeferredBindingUpdates) {\u000a                                            ko.processAllDeferredBindingUpdates();\u000a                                        }\u000a\u000a                                        //if using deferred updates on knockout 3.4, force updates\u000a                                        if (ko.options && ko.options.deferUpdates) {\u000a                                            ko.tasks.runEarly();\u000a                                        }\u000a                                    }\u000a\u000a                                    targetParent.splice(targetIndex, 0, item);\u000a                                }\u000a\u000a                                //rendering is handled by manipulating the observableArray; ignore dropped element\u000a                                dataSet(el, ITEMKEY, null);\u000a                            }\u000a                            else { //employ the strategy of moving items\u000a                                if (targetIndex >= 0) {\u000a                                    if (sourceParent) {\u000a                                        if (sourceParent !== targetParent) {\u000a                                            // moving from one list to another\u000a\u000a                                            sourceParent.splice(sourceIndex, 1);\u000a                                            targetParent.splice(targetIndex, 0, item);\u000a\u000a                                            //rendering is handled by manipulating the observableArray; ignore dropped element\u000a                                            dataSet(el, ITEMKEY, null);\u000a                                            ui.item.remove();\u000a                                        }\u000a                                        else {\u000a                                            // moving within same list\u000a                                            var underlyingList = unwrap(sourceParent);\u000a\u000a                                            // notify 'beforeChange' subscribers\u000a                                            if (sourceParent.valueWillMutate) {\u000a                                                sourceParent.valueWillMutate();\u000a                                            }\u000a\u000a                                            // move from source index ...\u000a                                            underlyingList.splice(sourceIndex, 1);\u000a                                            // ... to target index\u000a                                            underlyingList.splice(targetIndex, 0, item);\u000a\u000a                                            // notify subscribers\u000a                                            if (sourceParent.valueHasMutated) {\u000a                                                sourceParent.valueHasMutated();\u000a                                            }\u000a                                        }\u000a                                    }\u000a                                    else {\u000a                                        // drop new element from outside\u000a                                        targetParent.splice(targetIndex, 0, item);\u000a\u000a                                        //rendering is handled by manipulating the observableArray; ignore dropped element\u000a                                        dataSet(el, ITEMKEY, null);\u000a                                        ui.item.remove();\u000a                                    }\u000a                                }\u000a                            }\u000a\u000a                            //if using deferred updates plugin, force updates\u000a                            if (ko.processAllDeferredBindingUpdates) {\u000a                                ko.processAllDeferredBindingUpdates();\u000a                            }\u000a\u000a                            //allow binding to accept a function to execute after moving the item\u000a                            if (sortable.afterMove) {\u000a                                sortable.afterMove.call(this, arg, event, ui);\u000a                            }\u000a                        }\u000a\u000a                        if (updateActual) {\u000a                            updateActual.apply(this, arguments);\u000a                        }\u000a                    },\u000a                    connectWith: sortable.connectClass ? "." + sortable.connectClass : false\u000a                }));\u000a\u000a                //handle enabling/disabling sorting\u000a                if (sortable.isEnabled !== undefined) {\u000a                    ko.computed({\u000a                        read: function() {\u000a                            $element.sortable(unwrap(sortable.isEnabled) ? "enable" : "disable");\u000a                        },\u000a                        disposeWhenNodeIsRemoved: element\u000a                    });\u000a                }\u000a            }, 0);\u000a\u000a            //handle disposal\u000a            ko.utils.domNodeDisposal.addDisposeCallback(element, function() {\u000a                //only call destroy if sortable has been created\u000a                if ($element.data("ui-sortable") || $element.data("sortable")) {\u000a                    $element.sortable("destroy");\u000a                }\u000a\u000a                ko.utils.toggleDomNodeCssClass(element, sortable.connectClass, false);\u000a\u000a                //do not create the sortable if the element has been removed from DOM\u000a                clearTimeout(createTimeout);\u000a            });\u000a\u000a            return { 'controlsDescendantBindings': true };\u000a        },\u000a        update: function(element, valueAccessor, allBindingsAccessor, data, context) {\u000a            var templateOptions = prepareTemplateOptions(valueAccessor, "foreach");\u000a\u000a            //attach meta-data\u000a            dataSet(element, LISTKEY, templateOptions.foreach);\u000a\u000a            //call template binding's update with correct options\u000a            ko.bindingHandlers.template.update(element, function() { return templateOptions; }, allBindingsAccessor, data, context);\u000a        },\u000a        connectClass: 'ko_container',\u000a        allowDrop: true,\u000a        afterMove: null,\u000a        beforeMove: null,\u000a        options: {}\u000a    };\u000a\u000a    //create a draggable that is appropriate for dropping into a sortable\u000a    ko.bindingHandlers.draggable = {\u000a        init: function(element, valueAccessor, allBindingsAccessor, data, context) {\u000a            var value = unwrap(valueAccessor()) || {},\u000a                options = value.options || {},\u000a                draggableOptions = ko.utils.extend({}, ko.bindingHandlers.draggable.options),\u000a                templateOptions = prepareTemplateOptions(valueAccessor, "data"),\u000a                connectClass = value.connectClass || ko.bindingHandlers.draggable.connectClass,\u000a                isEnabled = value.isEnabled !== undefined ? value.isEnabled : ko.bindingHandlers.draggable.isEnabled;\u000a\u000a            value = "data" in value ? value.data : value;\u000a\u000a            //set meta-data\u000a            dataSet(element, DRAGKEY, value);\u000a\u000a            //override global options with override options passed in\u000a            ko.utils.extend(draggableOptions, options);\u000a\u000a            //setup connection to a sortable\u000a            draggableOptions.connectToSortable = connectClass ? "." + connectClass : false;\u000a\u000a            //initialize draggable\u000a            $(element).draggable(draggableOptions);\u000a\u000a            //handle enabling/disabling sorting\u000a            if (isEnabled !== undefined) {\u000a                ko.computed({\u000a                    read: function() {\u000a                        $(element).draggable(unwrap(isEnabled) ? "enable" : "disable");\u000a                    },\u000a                    disposeWhenNodeIsRemoved: element\u000a                });\u000a            }\u000a\u000a            //handle disposal\u000a            ko.utils.domNodeDisposal.addDisposeCallback(element, function() {\u000a                $(element).draggable("destroy");\u000a            });\u000a\u000a            return ko.bindingHandlers.template.init(element, function() { return templateOptions; }, allBindingsAccessor, data, context);\u000a        },\u000a        update: function(element, valueAccessor, allBindingsAccessor, data, context) {\u000a            var templateOptions = prepareTemplateOptions(valueAccessor, "data");\u000a\u000a            return ko.bindingHandlers.template.update(element, function() { return templateOptions; }, allBindingsAccessor, data, context);\u000a        },\u000a        connectClass: ko.bindingHandlers.sortable.connectClass,\u000a        options: {\u000a            helper: "clone"\u000a        }\u000a    };\u000a\u000a    // Simple Droppable Implementation\u000a    // binding that updates (function or observable)\u000a    ko.bindingHandlers.droppable = {\u000a        init: function(element, valueAccessor, allBindingsAccessor, data, context) {\u000a            var value = unwrap(valueAccessor()) || {},\u000a                options = value.options || {},\u000a                droppableOptions = ko.utils.extend({}, ko.bindingHandlers.droppable.options),\u000a                isEnabled = value.isEnabled !== undefined ? value.isEnabled : ko.bindingHandlers.droppable.isEnabled;\u000a\u000a            //override global options with override options passed in\u000a            ko.utils.extend(droppableOptions, options);\u000a\u000a            //get reference to drop method\u000a            value = "data" in value ? value.data : valueAccessor();\u000a\u000a            //set drop method\u000a            droppableOptions.drop = function(event, ui) {\u000a                var droppedItem = dataGet(ui.draggable[0], DRAGKEY) || dataGet(ui.draggable[0], ITEMKEY);\u000a                value(droppedItem);\u000a            };\u000a\u000a            //initialize droppable\u000a            $(element).droppable(droppableOptions);\u000a\u000a            //handle enabling/disabling droppable\u000a            if (isEnabled !== undefined) {\u000a                ko.computed({\u000a                    read: function() {\u000a                        $(element).droppable(unwrap(isEnabled) ? "enable": "disable");\u000a                    },\u000a                    disposeWhenNodeIsRemoved: element\u000a                });\u000a            }\u000a\u000a            //handle disposal\u000a            ko.utils.domNodeDisposal.addDisposeCallback(element, function() {\u000a                $(element).droppable("destroy");\u000a            });\u000a        },\u000a        options: {\u000a            accept: "*"\u000a        }\u000a    };\u000a});\u000a\u000a;\u000a
p0
.