V// source: js/lib/jquery/jquery.fileupload.js\u000a/*\u000a * jQuery File Upload Plugin\u000a * https://github.com/blueimp/jQuery-File-Upload\u000a *\u000a * Copyright 2010, Sebastian Tschan\u000a * https://blueimp.net\u000a *\u000a * Licensed under the MIT license:\u000a * https://opensource.org/licenses/MIT\u000a */\u000a\u000a/* global define, require */\u000a/* eslint-disable new-cap */\u000a\u000a(function (factory) {\u000a  'use strict';\u000a  if (typeof define === 'function' && define.amd) {\u000a    // Register as an anonymous AMD module:\u000a    define(['jquery', 'jquery-ui/ui/widget'], factory);\u000a  } else if (typeof exports === 'object') {\u000a    // Node/CommonJS:\u000a    factory(require('jquery'), require('./vendor/jquery.ui.widget'));\u000a  } else {\u000a    // Browser globals:\u000a    factory(window.jQuery);\u000a  }\u000a})(function ($) {\u000a  'use strict';\u000a\u000a  // Detect file input support, based on\u000a  // https://viljamis.com/2012/file-upload-support-on-mobile/\u000a  $.support.fileInput = !(\u000a    new RegExp(\u000a      // Handle devices which give false positives for the feature detection:\u000a      '(Android (1\u005c\u005c.[0156]|2\u005c\u005c.[01]))' +\u000a        '|(Windows Phone (OS 7|8\u005c\u005c.0))|(XBLWP)|(ZuneWP)|(WPDesktop)' +\u000a        '|(w(eb)?OSBrowser)|(webOS)' +\u000a        '|(Kindle/(1\u005c\u005c.0|2\u005c\u005c.[05]|3\u005c\u005c.0))'\u000a    ).test(window.navigator.userAgent) ||\u000a    // Feature detection for all other devices:\u000a    $('<input type="file"/>').prop('disabled')\u000a  );\u000a\u000a  // The FileReader API is not actually used, but works as feature detection,\u000a  // as some Safari versions (5?) support XHR file uploads via the FormData API,\u000a  // but not non-multipart XHR file uploads.\u000a  // window.XMLHttpRequestUpload is not available on IE10, so we check for\u000a  // window.ProgressEvent instead to detect XHR2 file upload capability:\u000a  $.support.xhrFileUpload = !!(window.ProgressEvent && window.FileReader);\u000a  $.support.xhrFormDataFileUpload = !!window.FormData;\u000a\u000a  // Detect support for Blob slicing (required for chunked uploads):\u000a  $.support.blobSlice =\u000a    window.Blob &&\u000a    (Blob.prototype.slice ||\u000a      Blob.prototype.webkitSlice ||\u000a      Blob.prototype.mozSlice);\u000a\u000a  /**\u000a   * Helper function to create drag handlers for dragover/dragenter/dragleave\u000a   *\u000a   * @param {string} type Event type\u000a   * @returns {Function} Drag handler\u000a   */\u000a  function getDragHandler(type) {\u000a    var isDragOver = type === 'dragover';\u000a    return function (e) {\u000a      e.dataTransfer = e.originalEvent && e.originalEvent.dataTransfer;\u000a      var dataTransfer = e.dataTransfer;\u000a      if (\u000a        dataTransfer &&\u000a        $.inArray('Files', dataTransfer.types) !== -1 &&\u000a        this._trigger(type, $.Event(type, { delegatedEvent: e })) !== false\u000a      ) {\u000a        e.preventDefault();\u000a        if (isDragOver) {\u000a          dataTransfer.dropEffect = 'copy';\u000a        }\u000a      }\u000a    };\u000a  }\u000a\u000a  // The fileupload widget listens for change events on file input fields defined\u000a  // via fileInput setting and paste or drop events of the given dropZone.\u000a  // In addition to the default jQuery Widget methods, the fileupload widget\u000a  // exposes the "add" and "send" methods, to add or directly send files using\u000a  // the fileupload API.\u000a  // By default, files added via file input selection, paste, drag & drop or\u000a  // "add" method are uploaded immediately, but it is possible to override\u000a  // the "add" callback option to queue file uploads.\u000a  $.widget('blueimp.fileupload', {\u000a    options: {\u000a      // The drop target element(s), by the default the complete document.\u000a      // Set to null to disable drag & drop support:\u000a      dropZone: $(document),\u000a      // The paste target element(s), by the default undefined.\u000a      // Set to a DOM node or jQuery object to enable file pasting:\u000a      pasteZone: undefined,\u000a      // The file input field(s), that are listened to for change events.\u000a      // If undefined, it is set to the file input fields inside\u000a      // of the widget element on plugin initialization.\u000a      // Set to null to disable the change listener.\u000a      fileInput: undefined,\u000a      // By default, the file input field is replaced with a clone after\u000a      // each input field change event. This is required for iframe transport\u000a      // queues and allows change events to be fired for the same file\u000a      // selection, but can be disabled by setting the following option to false:\u000a      replaceFileInput: true,\u000a      // The parameter name for the file form data (the request argument name).\u000a      // If undefined or empty, the name property of the file input field is\u000a      // used, or "files[]" if the file input name property is also empty,\u000a      // can be a string or an array of strings:\u000a      paramName: undefined,\u000a      // By default, each file of a selection is uploaded using an individual\u000a      // request for XHR type uploads. Set to false to upload file\u000a      // selections in one request each:\u000a      singleFileUploads: true,\u000a      // To limit the number of files uploaded with one XHR request,\u000a      // set the following option to an integer greater than 0:\u000a      limitMultiFileUploads: undefined,\u000a      // The following option limits the number of files uploaded with one\u000a      // XHR request to keep the request size under or equal to the defined\u000a      // limit in bytes:\u000a      limitMultiFileUploadSize: undefined,\u000a      // Multipart file uploads add a number of bytes to each uploaded file,\u000a      // therefore the following option adds an overhead for each file used\u000a      // in the limitMultiFileUploadSize configuration:\u000a      limitMultiFileUploadSizeOverhead: 512,\u000a      // Set the following option to true to issue all file upload requests\u000a      // in a sequential order:\u000a      sequentialUploads: false,\u000a      // To limit the number of concurrent uploads,\u000a      // set the following option to an integer greater than 0:\u000a      limitConcurrentUploads: undefined,\u000a      // Set the following option to true to force iframe transport uploads:\u000a      forceIframeTransport: false,\u000a      // Set the following option to the location of a redirect url on the\u000a      // origin server, for cross-domain iframe transport uploads:\u000a      redirect: undefined,\u000a      // The parameter name for the redirect url, sent as part of the form\u000a      // data and set to 'redirect' if this option is empty:\u000a      redirectParamName: undefined,\u000a      // Set the following option to the location of a postMessage window,\u000a      // to enable postMessage transport uploads:\u000a      postMessage: undefined,\u000a      // By default, XHR file uploads are sent as multipart/form-data.\u000a      // The iframe transport is always using multipart/form-data.\u000a      // Set to false to enable non-multipart XHR uploads:\u000a      multipart: true,\u000a      // To upload large files in smaller chunks, set the following option\u000a      // to a preferred maximum chunk size. If set to 0, null or undefined,\u000a      // or the browser does not support the required Blob API, files will\u000a      // be uploaded as a whole.\u000a      maxChunkSize: undefined,\u000a      // When a non-multipart upload or a chunked multipart upload has been\u000a      // aborted, this option can be used to resume the upload by setting\u000a      // it to the size of the already uploaded bytes. This option is most\u000a      // useful when modifying the options object inside of the "add" or\u000a      // "send" callbacks, as the options are cloned for each file upload.\u000a      uploadedBytes: undefined,\u000a      // By default, failed (abort or error) file uploads are removed from the\u000a      // global progress calculation. Set the following option to false to\u000a      // prevent recalculating the global progress data:\u000a      recalculateProgress: true,\u000a      // Interval in milliseconds to calculate and trigger progress events:\u000a      progressInterval: 100,\u000a      // Interval in milliseconds to calculate progress bitrate:\u000a      bitrateInterval: 500,\u000a      // By default, uploads are started automatically when adding files:\u000a      autoUpload: true,\u000a      // By default, duplicate file names are expected to be handled on\u000a      // the server-side. If this is not possible (e.g. when uploading\u000a      // files directly to Amazon S3), the following option can be set to\u000a      // an empty object or an object mapping existing filenames, e.g.:\u000a      // { "image.jpg": true, "image (1).jpg": true }\u000a      // If it is set, all files will be uploaded with unique filenames,\u000a      // adding increasing number suffixes if necessary, e.g.:\u000a      // "image (2).jpg"\u000a      uniqueFilenames: undefined,\u000a\u000a      // Error and info messages:\u000a      messages: {\u000a        uploadedBytes: 'Uploaded bytes exceed file size'\u000a      },\u000a\u000a      // Translation function, gets the message key to be translated\u000a      // and an object with context specific data as arguments:\u000a      i18n: function (message, context) {\u000a        // eslint-disable-next-line no-param-reassign\u000a        message = this.messages[message] || message.toString();\u000a        if (context) {\u000a          $.each(context, function (key, value) {\u000a            // eslint-disable-next-line no-param-reassign\u000a            message = message.replace('{' + key + '}', value);\u000a          });\u000a        }\u000a        return message;\u000a      },\u000a\u000a      // Additional form data to be sent along with the file uploads can be set\u000a      // using this option, which accepts an array of objects with name and\u000a      // value properties, a function returning such an array, a FormData\u000a      // object (for XHR file uploads), or a simple object.\u000a      // The form of the first fileInput is given as parameter to the function:\u000a      formData: function (form) {\u000a        return form.serializeArray();\u000a      },\u000a\u000a      // The add callback is invoked as soon as files are added to the fileupload\u000a      // widget (via file input selection, drag & drop, paste or add API call).\u000a      // If the singleFileUploads option is enabled, this callback will be\u000a      // called once for each file in the selection for XHR file uploads, else\u000a      // once for each file selection.\u000a      //\u000a      // The upload starts when the submit method is invoked on the data parameter.\u000a      // The data object contains a files property holding the added files\u000a      // and allows you to override plugin options as well as define ajax settings.\u000a      //\u000a      // Listeners for this callback can also be bound the following way:\u000a      // .on('fileuploadadd', func);\u000a      //\u000a      // data.submit() returns a Promise object and allows to attach additional\u000a      // handlers using jQuery's Deferred callbacks:\u000a      // data.submit().done(func).fail(func).always(func);\u000a      add: function (e, data) {\u000a        if (e.isDefaultPrevented()) {\u000a          return false;\u000a        }\u000a        if (\u000a          data.autoUpload ||\u000a          (data.autoUpload !== false &&\u000a            $(this).fileupload('option', 'autoUpload'))\u000a        ) {\u000a          data.process().done(function () {\u000a            data.submit();\u000a          });\u000a        }\u000a      },\u000a\u000a      // Other callbacks:\u000a\u000a      // Callback for the submit event of each file upload:\u000a      // submit: function (e, data) {}, // .on('fileuploadsubmit', func);\u000a\u000a      // Callback for the start of each file upload request:\u000a      // send: function (e, data) {}, // .on('fileuploadsend', func);\u000a\u000a      // Callback for successful uploads:\u000a      // done: function (e, data) {}, // .on('fileuploaddone', func);\u000a\u000a      // Callback for failed (abort or error) uploads:\u000a      // fail: function (e, data) {}, // .on('fileuploadfail', func);\u000a\u000a      // Callback for completed (success, abort or error) requests:\u000a      // always: function (e, data) {}, // .on('fileuploadalways', func);\u000a\u000a      // Callback for upload progress events:\u000a      // progress: function (e, data) {}, // .on('fileuploadprogress', func);\u000a\u000a      // Callback for global upload progress events:\u000a      // progressall: function (e, data) {}, // .on('fileuploadprogressall', func);\u000a\u000a      // Callback for uploads start, equivalent to the global ajaxStart event:\u000a      // start: function (e) {}, // .on('fileuploadstart', func);\u000a\u000a      // Callback for uploads stop, equivalent to the global ajaxStop event:\u000a      // stop: function (e) {}, // .on('fileuploadstop', func);\u000a\u000a      // Callback for change events of the fileInput(s):\u000a      // change: function (e, data) {}, // .on('fileuploadchange', func);\u000a\u000a      // Callback for paste events to the pasteZone(s):\u000a      // paste: function (e, data) {}, // .on('fileuploadpaste', func);\u000a\u000a      // Callback for drop events of the dropZone(s):\u000a      // drop: function (e, data) {}, // .on('fileuploaddrop', func);\u000a\u000a      // Callback for dragover events of the dropZone(s):\u000a      // dragover: function (e) {}, // .on('fileuploaddragover', func);\u000a\u000a      // Callback before the start of each chunk upload request (before form data initialization):\u000a      // chunkbeforesend: function (e, data) {}, // .on('fileuploadchunkbeforesend', func);\u000a\u000a      // Callback for the start of each chunk upload request:\u000a      // chunksend: function (e, data) {}, // .on('fileuploadchunksend', func);\u000a\u000a      // Callback for successful chunk uploads:\u000a      // chunkdone: function (e, data) {}, // .on('fileuploadchunkdone', func);\u000a\u000a      // Callback for failed (abort or error) chunk uploads:\u000a      // chunkfail: function (e, data) {}, // .on('fileuploadchunkfail', func);\u000a\u000a      // Callback for completed (success, abort or error) chunk upload requests:\u000a      // chunkalways: function (e, data) {}, // .on('fileuploadchunkalways', func);\u000a\u000a      // The plugin options are used as settings object for the ajax calls.\u000a      // The following are jQuery ajax settings required for the file uploads:\u000a      processData: false,\u000a      contentType: false,\u000a      cache: false,\u000a      timeout: 0\u000a    },\u000a\u000a    // jQuery versions before 1.8 require promise.pipe if the return value is\u000a    // used, as promise.then in older versions has a different behavior, see:\u000a    // https://blog.jquery.com/2012/08/09/jquery-1-8-released/\u000a    // https://bugs.jquery.com/ticket/11010\u000a    // https://github.com/blueimp/jQuery-File-Upload/pull/3435\u000a    _promisePipe: (function () {\u000a      var parts = $.fn.jquery.split('.');\u000a      return Number(parts[0]) > 1 || Number(parts[1]) > 7 ? 'then' : 'pipe';\u000a    })(),\u000a\u000a    // A list of options that require reinitializing event listeners and/or\u000a    // special initialization code:\u000a    _specialOptions: [\u000a      'fileInput',\u000a      'dropZone',\u000a      'pasteZone',\u000a      'multipart',\u000a      'forceIframeTransport'\u000a    ],\u000a\u000a    _blobSlice:\u000a      $.support.blobSlice &&\u000a      function () {\u000a        var slice = this.slice || this.webkitSlice || this.mozSlice;\u000a        return slice.apply(this, arguments);\u000a      },\u000a\u000a    _BitrateTimer: function () {\u000a      this.timestamp = Date.now ? Date.now() : new Date().getTime();\u000a      this.loaded = 0;\u000a      this.bitrate = 0;\u000a      this.getBitrate = function (now, loaded, interval) {\u000a        var timeDiff = now - this.timestamp;\u000a        if (!this.bitrate || !interval || timeDiff > interval) {\u000a          this.bitrate = (loaded - this.loaded) * (1000 / timeDiff) * 8;\u000a          this.loaded = loaded;\u000a          this.timestamp = now;\u000a        }\u000a        return this.bitrate;\u000a      };\u000a    },\u000a\u000a    _isXHRUpload: function (options) {\u000a      return (\u000a        !options.forceIframeTransport &&\u000a        ((!options.multipart && $.support.xhrFileUpload) ||\u000a          $.support.xhrFormDataFileUpload)\u000a      );\u000a    },\u000a\u000a    _getFormData: function (options) {\u000a      var formData;\u000a      if ($.type(options.formData) === 'function') {\u000a        return options.formData(options.form);\u000a      }\u000a      if ($.isArray(options.formData)) {\u000a        return options.formData;\u000a      }\u000a      if ($.type(options.formData) === 'object') {\u000a        formData = [];\u000a        $.each(options.formData, function (name, value) {\u000a          formData.push({ name: name, value: value });\u000a        });\u000a        return formData;\u000a      }\u000a      return [];\u000a    },\u000a\u000a    _getTotal: function (files) {\u000a      var total = 0;\u000a      $.each(files, function (index, file) {\u000a        total += file.size || 1;\u000a      });\u000a      return total;\u000a    },\u000a\u000a    _initProgressObject: function (obj) {\u000a      var progress = {\u000a        loaded: 0,\u000a        total: 0,\u000a        bitrate: 0\u000a      };\u000a      if (obj._progress) {\u000a        $.extend(obj._progress, progress);\u000a      } else {\u000a        obj._progress = progress;\u000a      }\u000a    },\u000a\u000a    _initResponseObject: function (obj) {\u000a      var prop;\u000a      if (obj._response) {\u000a        for (prop in obj._response) {\u000a          if (Object.prototype.hasOwnProperty.call(obj._response, prop)) {\u000a            delete obj._response[prop];\u000a          }\u000a        }\u000a      } else {\u000a        obj._response = {};\u000a      }\u000a    },\u000a\u000a    _onProgress: function (e, data) {\u000a      if (e.lengthComputable) {\u000a        var now = Date.now ? Date.now() : new Date().getTime(),\u000a          loaded;\u000a        if (\u000a          data._time &&\u000a          data.progressInterval &&\u000a          now - data._time < data.progressInterval &&\u000a          e.loaded !== e.total\u000a        ) {\u000a          return;\u000a        }\u000a        data._time = now;\u000a        loaded =\u000a          Math.floor(\u000a            (e.loaded / e.total) * (data.chunkSize || data._progress.total)\u000a          ) + (data.uploadedBytes || 0);\u000a        // Add the difference from the previously loaded state\u000a        // to the global loaded counter:\u000a        this._progress.loaded += loaded - data._progress.loaded;\u000a        this._progress.bitrate = this._bitrateTimer.getBitrate(\u000a          now,\u000a          this._progress.loaded,\u000a          data.bitrateInterval\u000a        );\u000a        data._progress.loaded = data.loaded = loaded;\u000a        data._progress.bitrate = data.bitrate = data._bitrateTimer.getBitrate(\u000a          now,\u000a          loaded,\u000a          data.bitrateInterval\u000a        );\u000a        // Trigger a custom progress event with a total data property set\u000a        // to the file size(s) of the current upload and a loaded data\u000a        // property calculated accordingly:\u000a        this._trigger(\u000a          'progress',\u000a          $.Event('progress', { delegatedEvent: e }),\u000a          data\u000a        );\u000a        // Trigger a global progress event for all current file uploads,\u000a        // including ajax calls queued for sequential file uploads:\u000a        this._trigger(\u000a          'progressall',\u000a          $.Event('progressall', { delegatedEvent: e }),\u000a          this._progress\u000a        );\u000a      }\u000a    },\u000a\u000a    _initProgressListener: function (options) {\u000a      var that = this,\u000a        xhr = options.xhr ? options.xhr() : $.ajaxSettings.xhr();\u000a      // Accesss to the native XHR object is required to add event listeners\u000a      // for the upload progress event:\u000a      if (xhr.upload) {\u000a        $(xhr.upload).on('progress', function (e) {\u000a          var oe = e.originalEvent;\u000a          // Make sure the progress event properties get copied over:\u000a          e.lengthComputable = oe.lengthComputable;\u000a          e.loaded = oe.loaded;\u000a          e.total = oe.total;\u000a          that._onProgress(e, options);\u000a        });\u000a        options.xhr = function () {\u000a          return xhr;\u000a        };\u000a      }\u000a    },\u000a\u000a    _deinitProgressListener: function (options) {\u000a      var xhr = options.xhr ? options.xhr() : $.ajaxSettings.xhr();\u000a      if (xhr.upload) {\u000a        $(xhr.upload).off('progress');\u000a      }\u000a    },\u000a\u000a    _isInstanceOf: function (type, obj) {\u000a      // Cross-frame instanceof check\u000a      return Object.prototype.toString.call(obj) === '[object ' + type + ']';\u000a    },\u000a\u000a    _getUniqueFilename: function (name, map) {\u000a      // eslint-disable-next-line no-param-reassign\u000a      name = String(name);\u000a      if (map[name]) {\u000a        // eslint-disable-next-line no-param-reassign\u000a        name = name.replace(/(?: \u005c(([\u005cd]+)\u005c))?(\u005c.[^.]+)?$/, function (\u000a          _,\u000a          p1,\u000a          p2\u000a        ) {\u000a          var index = p1 ? Number(p1) + 1 : 1;\u000a          var ext = p2 || '';\u000a          return ' (' + index + ')' + ext;\u000a        });\u000a        return this._getUniqueFilename(name, map);\u000a      }\u000a      map[name] = true;\u000a      return name;\u000a    },\u000a\u000a    _initXHRData: function (options) {\u000a      var that = this,\u000a        formData,\u000a        file = options.files[0],\u000a        // Ignore non-multipart setting if not supported:\u000a        multipart = options.multipart || !$.support.xhrFileUpload,\u000a        paramName =\u000a          $.type(options.paramName) === 'array'\u000a            ? options.paramName[0]\u000a            : options.paramName;\u000a      options.headers = $.extend({}, options.headers);\u000a      if (options.contentRange) {\u000a        options.headers['Content-Range'] = options.contentRange;\u000a      }\u000a      if (!multipart || options.blob || !this._isInstanceOf('File', file)) {\u000a        options.headers['Content-Disposition'] =\u000a          'attachment; filename="' +\u000a          encodeURI(file.uploadName || file.name) +\u000a          '"';\u000a      }\u000a      if (!multipart) {\u000a        options.contentType = file.type || 'application/octet-stream';\u000a        options.data = options.blob || file;\u000a      } else if ($.support.xhrFormDataFileUpload) {\u000a        if (options.postMessage) {\u000a          // window.postMessage does not allow sending FormData\u000a          // objects, so we just add the File/Blob objects to\u000a          // the formData array and let the postMessage window\u000a          // create the FormData object out of this array:\u000a          formData = this._getFormData(options);\u000a          if (options.blob) {\u000a            formData.push({\u000a              name: paramName,\u000a              value: options.blob\u000a            });\u000a          } else {\u000a            $.each(options.files, function (index, file) {\u000a              formData.push({\u000a                name:\u000a                  ($.type(options.paramName) === 'array' &&\u000a                    options.paramName[index]) ||\u000a                  paramName,\u000a                value: file\u000a              });\u000a            });\u000a          }\u000a        } else {\u000a          if (that._isInstanceOf('FormData', options.formData)) {\u000a            formData = options.formData;\u000a          } else {\u000a            formData = new FormData();\u000a            $.each(this._getFormData(options), function (index, field) {\u000a              formData.append(field.name, field.value);\u000a            });\u000a          }\u000a          if (options.blob) {\u000a            formData.append(\u000a              paramName,\u000a              options.blob,\u000a              file.uploadName || file.name\u000a            );\u000a          } else {\u000a            $.each(options.files, function (index, file) {\u000a              // This check allows the tests to run with\u000a              // dummy objects:\u000a              if (\u000a                that._isInstanceOf('File', file) ||\u000a                that._isInstanceOf('Blob', file)\u000a              ) {\u000a                var fileName = file.uploadName || file.name;\u000a                if (options.uniqueFilenames) {\u000a                  fileName = that._getUniqueFilename(\u000a                    fileName,\u000a                    options.uniqueFilenames\u000a                  );\u000a                }\u000a                formData.append(\u000a                  ($.type(options.paramName) === 'array' &&\u000a                    options.paramName[index]) ||\u000a                    paramName,\u000a                  file,\u000a                  fileName\u000a                );\u000a              }\u000a            });\u000a          }\u000a        }\u000a        options.data = formData;\u000a      }\u000a      // Blob reference is not needed anymore, free memory:\u000a      options.blob = null;\u000a    },\u000a\u000a    _initIframeSettings: function (options) {\u000a      var targetHost = $('<a></a>').prop('href', options.url).prop('host');\u000a      // Setting the dataType to iframe enables the iframe transport:\u000a      options.dataType = 'iframe ' + (options.dataType || '');\u000a      // The iframe transport accepts a serialized array as form data:\u000a      options.formData = this._getFormData(options);\u000a      // Add redirect url to form data on cross-domain uploads:\u000a      if (options.redirect && targetHost && targetHost !== location.host) {\u000a        options.formData.push({\u000a          name: options.redirectParamName || 'redirect',\u000a          value: options.redirect\u000a        });\u000a      }\u000a    },\u000a\u000a    _initDataSettings: function (options) {\u000a      if (this._isXHRUpload(options)) {\u000a        if (!this._chunkedUpload(options, true)) {\u000a          if (!options.data) {\u000a            this._initXHRData(options);\u000a          }\u000a          this._initProgressListener(options);\u000a        }\u000a        if (options.postMessage) {\u000a          // Setting the dataType to postmessage enables the\u000a          // postMessage transport:\u000a          options.dataType = 'postmessage ' + (options.dataType || '');\u000a        }\u000a      } else {\u000a        this._initIframeSettings(options);\u000a      }\u000a    },\u000a\u000a    _getParamName: function (options) {\u000a      var fileInput = $(options.fileInput),\u000a        paramName = options.paramName;\u000a      if (!paramName) {\u000a        paramName = [];\u000a        fileInput.each(function () {\u000a          var input = $(this),\u000a            name = input.prop('name') || 'files[]',\u000a            i = (input.prop('files') || [1]).length;\u000a          while (i) {\u000a            paramName.push(name);\u000a            i -= 1;\u000a          }\u000a        });\u000a        if (!paramName.length) {\u000a          paramName = [fileInput.prop('name') || 'files[]'];\u000a        }\u000a      } else if (!$.isArray(paramName)) {\u000a        paramName = [paramName];\u000a      }\u000a      return paramName;\u000a    },\u000a\u000a    _initFormSettings: function (options) {\u000a      // Retrieve missing options from the input field and the\u000a      // associated form, if available:\u000a      if (!options.form || !options.form.length) {\u000a        options.form = $(options.fileInput.prop('form'));\u000a        // If the given file input doesn't have an associated form,\u000a        // use the default widget file input's form:\u000a        if (!options.form.length) {\u000a          options.form = $(this.options.fileInput.prop('form'));\u000a        }\u000a      }\u000a      options.paramName = this._getParamName(options);\u000a      if (!options.url) {\u000a        options.url = options.form.prop('action') || location.href;\u000a      }\u000a      // The HTTP request method must be "POST" or "PUT":\u000a      options.type = (\u000a        options.type ||\u000a        ($.type(options.form.prop('method')) === 'string' &&\u000a          options.form.prop('method')) ||\u000a        ''\u000a      ).toUpperCase();\u000a      if (\u000a        options.type !== 'POST' &&\u000a        options.type !== 'PUT' &&\u000a        options.type !== 'PATCH'\u000a      ) {\u000a        options.type = 'POST';\u000a      }\u000a      if (!options.formAcceptCharset) {\u000a        options.formAcceptCharset = options.form.attr('accept-charset');\u000a      }\u000a    },\u000a\u000a    _getAJAXSettings: function (data) {\u000a      var options = $.extend({}, this.options, data);\u000a      this._initFormSettings(options);\u000a      this._initDataSettings(options);\u000a      return options;\u000a    },\u000a\u000a    // jQuery 1.6 doesn't provide .state(),\u000a    // while jQuery 1.8+ removed .isRejected() and .isResolved():\u000a    _getDeferredState: function (deferred) {\u000a      if (deferred.state) {\u000a        return deferred.state();\u000a      }\u000a      if (deferred.isResolved()) {\u000a        return 'resolved';\u000a      }\u000a      if (deferred.isRejected()) {\u000a        return 'rejected';\u000a      }\u000a      return 'pending';\u000a    },\u000a\u000a    // Maps jqXHR callbacks to the equivalent\u000a    // methods of the given Promise object:\u000a    _enhancePromise: function (promise) {\u000a      promise.success = promise.done;\u000a      promise.error = promise.fail;\u000a      promise.complete = promise.always;\u000a      return promise;\u000a    },\u000a\u000a    // Creates and returns a Promise object enhanced with\u000a    // the jqXHR methods abort, success, error and complete:\u000a    _getXHRPromise: function (resolveOrReject, context, args) {\u000a      var dfd = $.Deferred(),\u000a        promise = dfd.promise();\u000a      // eslint-disable-next-line no-param-reassign\u000a      context = context || this.options.context || promise;\u000a      if (resolveOrReject === true) {\u000a        dfd.resolveWith(context, args);\u000a      } else if (resolveOrReject === false) {\u000a        dfd.rejectWith(context, args);\u000a      }\u000a      promise.abort = dfd.promise;\u000a      return this._enhancePromise(promise);\u000a    },\u000a\u000a    // Adds convenience methods to the data callback argument:\u000a    _addConvenienceMethods: function (e, data) {\u000a      var that = this,\u000a        getPromise = function (args) {\u000a          return $.Deferred().resolveWith(that, args).promise();\u000a        };\u000a      data.process = function (resolveFunc, rejectFunc) {\u000a        if (resolveFunc || rejectFunc) {\u000a          data._processQueue = this._processQueue = (this._processQueue ||\u000a            getPromise([this]))\u000a            [that._promisePipe](function () {\u000a              if (data.errorThrown) {\u000a                return $.Deferred().rejectWith(that, [data]).promise();\u000a              }\u000a              return getPromise(arguments);\u000a            })\u000a            [that._promisePipe](resolveFunc, rejectFunc);\u000a        }\u000a        return this._processQueue || getPromise([this]);\u000a      };\u000a      data.submit = function () {\u000a        if (this.state() !== 'pending') {\u000a          data.jqXHR = this.jqXHR =\u000a            that._trigger(\u000a              'submit',\u000a              $.Event('submit', { delegatedEvent: e }),\u000a              this\u000a            ) !== false && that._onSend(e, this);\u000a        }\u000a        return this.jqXHR || that._getXHRPromise();\u000a      };\u000a      data.abort = function () {\u000a        if (this.jqXHR) {\u000a          return this.jqXHR.abort();\u000a        }\u000a        this.errorThrown = 'abort';\u000a        that._trigger('fail', null, this);\u000a        return that._getXHRPromise(false);\u000a      };\u000a      data.state = function () {\u000a        if (this.jqXHR) {\u000a          return that._getDeferredState(this.jqXHR);\u000a        }\u000a        if (this._processQueue) {\u000a          return that._getDeferredState(this._processQueue);\u000a        }\u000a      };\u000a      data.processing = function () {\u000a        return (\u000a          !this.jqXHR &&\u000a          this._processQueue &&\u000a          that._getDeferredState(this._processQueue) === 'pending'\u000a        );\u000a      };\u000a      data.progress = function () {\u000a        return this._progress;\u000a      };\u000a      data.response = function () {\u000a        return this._response;\u000a      };\u000a    },\u000a\u000a    // Parses the Range header from the server response\u000a    // and returns the uploaded bytes:\u000a    _getUploadedBytes: function (jqXHR) {\u000a      var range = jqXHR.getResponseHeader('Range'),\u000a        parts = range && range.split('-'),\u000a        upperBytesPos = parts && parts.length > 1 && parseInt(parts[1], 10);\u000a      return upperBytesPos && upperBytesPos + 1;\u000a    },\u000a\u000a    // Uploads a file in multiple, sequential requests\u000a    // by splitting the file up in multiple blob chunks.\u000a    // If the second parameter is true, only tests if the file\u000a    // should be uploaded in chunks, but does not invoke any\u000a    // upload requests:\u000a    _chunkedUpload: function (options, testOnly) {\u000a      options.uploadedBytes = options.uploadedBytes || 0;\u000a      var that = this,\u000a        file = options.files[0],\u000a        fs = file.size,\u000a        ub = options.uploadedBytes,\u000a        mcs = options.maxChunkSize || fs,\u000a        slice = this._blobSlice,\u000a        dfd = $.Deferred(),\u000a        promise = dfd.promise(),\u000a        jqXHR,\u000a        upload;\u000a      if (\u000a        !(\u000a          this._isXHRUpload(options) &&\u000a          slice &&\u000a          (ub || ($.type(mcs) === 'function' ? mcs(options) : mcs) < fs)\u000a        ) ||\u000a        options.data\u000a      ) {\u000a        return false;\u000a      }\u000a      if (testOnly) {\u000a        return true;\u000a      }\u000a      if (ub >= fs) {\u000a        file.error = options.i18n('uploadedBytes');\u000a        return this._getXHRPromise(false, options.context, [\u000a          null,\u000a          'error',\u000a          file.error\u000a        ]);\u000a      }\u000a      // The chunk upload method:\u000a      upload = function () {\u000a        // Clone the options object for each chunk upload:\u000a        var o = $.extend({}, options),\u000a          currentLoaded = o._progress.loaded;\u000a        o.blob = slice.call(\u000a          file,\u000a          ub,\u000a          ub + ($.type(mcs) === 'function' ? mcs(o) : mcs),\u000a          file.type\u000a        );\u000a        // Store the current chunk size, as the blob itself\u000a        // will be dereferenced after data processing:\u000a        o.chunkSize = o.blob.size;\u000a        // Expose the chunk bytes position range:\u000a        o.contentRange =\u000a          'bytes ' + ub + '-' + (ub + o.chunkSize - 1) + '/' + fs;\u000a        // Trigger chunkbeforesend to allow form data to be updated for this chunk\u000a        that._trigger('chunkbeforesend', null, o);\u000a        // Process the upload data (the blob and potential form data):\u000a        that._initXHRData(o);\u000a        // Add progress listeners for this chunk upload:\u000a        that._initProgressListener(o);\u000a        jqXHR = (\u000a          (that._trigger('chunksend', null, o) !== false && $.ajax(o)) ||\u000a          that._getXHRPromise(false, o.context)\u000a        )\u000a          .done(function (result, textStatus, jqXHR) {\u000a            ub = that._getUploadedBytes(jqXHR) || ub + o.chunkSize;\u000a            // Create a progress event if no final progress event\u000a            // with loaded equaling total has been triggered\u000a            // for this chunk:\u000a            if (currentLoaded + o.chunkSize - o._progress.loaded) {\u000a              that._onProgress(\u000a                $.Event('progress', {\u000a                  lengthComputable: true,\u000a                  loaded: ub - o.uploadedBytes,\u000a                  total: ub - o.uploadedBytes\u000a                }),\u000a                o\u000a              );\u000a            }\u000a            options.uploadedBytes = o.uploadedBytes = ub;\u000a            o.result = result;\u000a            o.textStatus = textStatus;\u000a            o.jqXHR = jqXHR;\u000a            that._trigger('chunkdone', null, o);\u000a            that._trigger('chunkalways', null, o);\u000a            if (ub < fs) {\u000a              // File upload not yet complete,\u000a              // continue with the next chunk:\u000a              upload();\u000a            } else {\u000a              dfd.resolveWith(o.context, [result, textStatus, jqXHR]);\u000a            }\u000a          })\u000a          .fail(function (jqXHR, textStatus, errorThrown) {\u000a            o.jqXHR = jqXHR;\u000a            o.textStatus = textStatus;\u000a            o.errorThrown = errorThrown;\u000a            that._trigger('chunkfail', null, o);\u000a            that._trigger('chunkalways', null, o);\u000a            dfd.rejectWith(o.context, [jqXHR, textStatus, errorThrown]);\u000a          })\u000a          .always(function () {\u000a            that._deinitProgressListener(o);\u000a          });\u000a      };\u000a      this._enhancePromise(promise);\u000a      promise.abort = function () {\u000a        return jqXHR.abort();\u000a      };\u000a      upload();\u000a      return promise;\u000a    },\u000a\u000a    _beforeSend: function (e, data) {\u000a      if (this._active === 0) {\u000a        // the start callback is triggered when an upload starts\u000a        // and no other uploads are currently running,\u000a        // equivalent to the global ajaxStart event:\u000a        this._trigger('start');\u000a        // Set timer for global bitrate progress calculation:\u000a        this._bitrateTimer = new this._BitrateTimer();\u000a        // Reset the global progress values:\u000a        this._progress.loaded = this._progress.total = 0;\u000a        this._progress.bitrate = 0;\u000a      }\u000a      // Make sure the container objects for the .response() and\u000a      // .progress() methods on the data object are available\u000a      // and reset to their initial state:\u000a      this._initResponseObject(data);\u000a      this._initProgressObject(data);\u000a      data._progress.loaded = data.loaded = data.uploadedBytes || 0;\u000a      data._progress.total = data.total = this._getTotal(data.files) || 1;\u000a      data._progress.bitrate = data.bitrate = 0;\u000a      this._active += 1;\u000a      // Initialize the global progress values:\u000a      this._progress.loaded += data.loaded;\u000a      this._progress.total += data.total;\u000a    },\u000a\u000a    _onDone: function (result, textStatus, jqXHR, options) {\u000a      var total = options._progress.total,\u000a        response = options._response;\u000a      if (options._progress.loaded < total) {\u000a        // Create a progress event if no final progress event\u000a        // with loaded equaling total has been triggered:\u000a        this._onProgress(\u000a          $.Event('progress', {\u000a            lengthComputable: true,\u000a            loaded: total,\u000a            total: total\u000a          }),\u000a          options\u000a        );\u000a      }\u000a      response.result = options.result = result;\u000a      response.textStatus = options.textStatus = textStatus;\u000a      response.jqXHR = options.jqXHR = jqXHR;\u000a      this._trigger('done', null, options);\u000a    },\u000a\u000a    _onFail: function (jqXHR, textStatus, errorThrown, options) {\u000a      var response = options._response;\u000a      if (options.recalculateProgress) {\u000a        // Remove the failed (error or abort) file upload from\u000a        // the global progress calculation:\u000a        this._progress.loaded -= options._progress.loaded;\u000a        this._progress.total -= options._progress.total;\u000a      }\u000a      response.jqXHR = options.jqXHR = jqXHR;\u000a      response.textStatus = options.textStatus = textStatus;\u000a      response.errorThrown = options.errorThrown = errorThrown;\u000a      this._trigger('fail', null, options);\u000a    },\u000a\u000a    _onAlways: function (jqXHRorResult, textStatus, jqXHRorError, options) {\u000a      // jqXHRorResult, textStatus and jqXHRorError are added to the\u000a      // options object via done and fail callbacks\u000a      this._trigger('always', null, options);\u000a    },\u000a\u000a    _onSend: function (e, data) {\u000a      if (!data.submit) {\u000a        this._addConvenienceMethods(e, data);\u000a      }\u000a      var that = this,\u000a        jqXHR,\u000a        aborted,\u000a        slot,\u000a        pipe,\u000a        options = that._getAJAXSettings(data),\u000a        send = function () {\u000a          that._sending += 1;\u000a          // Set timer for bitrate progress calculation:\u000a          options._bitrateTimer = new that._BitrateTimer();\u000a          jqXHR =\u000a            jqXHR ||\u000a            (\u000a              ((aborted ||\u000a                that._trigger(\u000a                  'send',\u000a                  $.Event('send', { delegatedEvent: e }),\u000a                  options\u000a                ) === false) &&\u000a                that._getXHRPromise(false, options.context, aborted)) ||\u000a              that._chunkedUpload(options) ||\u000a              $.ajax(options)\u000a            )\u000a              .done(function (result, textStatus, jqXHR) {\u000a                that._onDone(result, textStatus, jqXHR, options);\u000a              })\u000a              .fail(function (jqXHR, textStatus, errorThrown) {\u000a                that._onFail(jqXHR, textStatus, errorThrown, options);\u000a              })\u000a              .always(function (jqXHRorResult, textStatus, jqXHRorError) {\u000a                that._deinitProgressListener(options);\u000a                that._onAlways(\u000a                  jqXHRorResult,\u000a                  textStatus,\u000a                  jqXHRorError,\u000a                  options\u000a                );\u000a                that._sending -= 1;\u000a                that._active -= 1;\u000a                if (\u000a                  options.limitConcurrentUploads &&\u000a                  options.limitConcurrentUploads > that._sending\u000a                ) {\u000a                  // Start the next queued upload,\u000a                  // that has not been aborted:\u000a                  var nextSlot = that._slots.shift();\u000a                  while (nextSlot) {\u000a                    if (that._getDeferredState(nextSlot) === 'pending') {\u000a                      nextSlot.resolve();\u000a                      break;\u000a                    }\u000a                    nextSlot = that._slots.shift();\u000a                  }\u000a                }\u000a                if (that._active === 0) {\u000a                  // The stop callback is triggered when all uploads have\u000a                  // been completed, equivalent to the global ajaxStop event:\u000a                  that._trigger('stop');\u000a                }\u000a              });\u000a          return jqXHR;\u000a        };\u000a      this._beforeSend(e, options);\u000a      if (\u000a        this.options.sequentialUploads ||\u000a        (this.options.limitConcurrentUploads &&\u000a          this.options.limitConcurrentUploads <= this._sending)\u000a      ) {\u000a        if (this.options.limitConcurrentUploads > 1) {\u000a          slot = $.Deferred();\u000a          this._slots.push(slot);\u000a          pipe = slot[that._promisePipe](send);\u000a        } else {\u000a          this._sequence = this._sequence[that._promisePipe](send, send);\u000a          pipe = this._sequence;\u000a        }\u000a        // Return the piped Promise object, enhanced with an abort method,\u000a        // which is delegated to the jqXHR object of the current upload,\u000a        // and jqXHR callbacks mapped to the equivalent Promise methods:\u000a        pipe.abort = function () {\u000a          aborted = [undefined, 'abort', 'abort'];\u000a          if (!jqXHR) {\u000a            if (slot) {\u000a              slot.rejectWith(options.context, aborted);\u000a            }\u000a            return send();\u000a          }\u000a          return jqXHR.abort();\u000a        };\u000a        return this._enhancePromise(pipe);\u000a      }\u000a      return send();\u000a    },\u000a\u000a    _onAdd: function (e, data) {\u000a      var that = this,\u000a        result = true,\u000a        options = $.extend({}, this.options, data),\u000a        files = data.files,\u000a        filesLength = files.length,\u000a        limit = options.limitMultiFileUploads,\u000a        limitSize = options.limitMultiFileUploadSize,\u000a        overhead = options.limitMultiFileUploadSizeOverhead,\u000a        batchSize = 0,\u000a        paramName = this._getParamName(options),\u000a        paramNameSet,\u000a        paramNameSlice,\u000a        fileSet,\u000a        i,\u000a        j = 0;\u000a      if (!filesLength) {\u000a        return false;\u000a      }\u000a      if (limitSize && files[0].size === undefined) {\u000a        limitSize = undefined;\u000a      }\u000a      if (\u000a        !(options.singleFileUploads || limit || limitSize) ||\u000a        !this._isXHRUpload(options)\u000a      ) {\u000a        fileSet = [files];\u000a        paramNameSet = [paramName];\u000a      } else if (!(options.singleFileUploads || limitSize) && limit) {\u000a        fileSet = [];\u000a        paramNameSet = [];\u000a        for (i = 0; i < filesLength; i += limit) {\u000a          fileSet.push(files.slice(i, i + limit));\u000a          paramNameSlice = paramName.slice(i, i + limit);\u000a          if (!paramNameSlice.length) {\u000a            paramNameSlice = paramName;\u000a          }\u000a          paramNameSet.push(paramNameSlice);\u000a        }\u000a      } else if (!options.singleFileUploads && limitSize) {\u000a        fileSet = [];\u000a        paramNameSet = [];\u000a        for (i = 0; i < filesLength; i = i + 1) {\u000a          batchSize += files[i].size + overhead;\u000a          if (\u000a            i + 1 === filesLength ||\u000a            batchSize + files[i + 1].size + overhead > limitSize ||\u000a            (limit && i + 1 - j >= limit)\u000a          ) {\u000a            fileSet.push(files.slice(j, i + 1));\u000a            paramNameSlice = paramName.slice(j, i + 1);\u000a            if (!paramNameSlice.length) {\u000a              paramNameSlice = paramName;\u000a            }\u000a            paramNameSet.push(paramNameSlice);\u000a            j = i + 1;\u000a            batchSize = 0;\u000a          }\u000a        }\u000a      } else {\u000a        paramNameSet = paramName;\u000a      }\u000a      data.originalFiles = files;\u000a      $.each(fileSet || files, function (index, element) {\u000a        var newData = $.extend({}, data);\u000a        newData.files = fileSet ? element : [element];\u000a        newData.paramName = paramNameSet[index];\u000a        that._initResponseObject(newData);\u000a        that._initProgressObject(newData);\u000a        that._addConvenienceMethods(e, newData);\u000a        result = that._trigger(\u000a          'add',\u000a          $.Event('add', { delegatedEvent: e }),\u000a          newData\u000a        );\u000a        return result;\u000a      });\u000a      return result;\u000a    },\u000a\u000a    _replaceFileInput: function (data) {\u000a      var input = data.fileInput,\u000a        inputClone = input.clone(true),\u000a        restoreFocus = input.is(document.activeElement);\u000a      // Add a reference for the new cloned file input to the data argument:\u000a      data.fileInputClone = inputClone;\u000a      $('<form></form>').append(inputClone)[0].reset();\u000a      // Detaching allows to insert the fileInput on another form\u000a      // without loosing the file input value:\u000a      input.after(inputClone).detach();\u000a      // If the fileInput had focus before it was detached,\u000a      // restore focus to the inputClone.\u000a      if (restoreFocus) {\u000a        inputClone.trigger('focus');\u000a      }\u000a      // Avoid memory leaks with the detached file input:\u000a      $.cleanData(input.off('remove'));\u000a      // Replace the original file input element in the fileInput\u000a      // elements set with the clone, which has been copied including\u000a      // event handlers:\u000a      this.options.fileInput = this.options.fileInput.map(function (i, el) {\u000a        if (el === input[0]) {\u000a          return inputClone[0];\u000a        }\u000a        return el;\u000a      });\u000a      // If the widget has been initialized on the file input itself,\u000a      // override this.element with the file input clone:\u000a      if (input[0] === this.element[0]) {\u000a        this.element = inputClone;\u000a      }\u000a    },\u000a\u000a    _handleFileTreeEntry: function (entry, path) {\u000a      var that = this,\u000a        dfd = $.Deferred(),\u000a        entries = [],\u000a        dirReader,\u000a        errorHandler = function (e) {\u000a          if (e && !e.entry) {\u000a            e.entry = entry;\u000a          }\u000a          // Since $.when returns immediately if one\u000a          // Deferred is rejected, we use resolve instead.\u000a          // This allows valid files and invalid items\u000a          // to be returned together in one set:\u000a          dfd.resolve([e]);\u000a        },\u000a        successHandler = function (entries) {\u000a          that\u000a            ._handleFileTreeEntries(entries, path + entry.name + '/')\u000a            .done(function (files) {\u000a              dfd.resolve(files);\u000a            })\u000a            .fail(errorHandler);\u000a        },\u000a        readEntries = function () {\u000a          dirReader.readEntries(function (results) {\u000a            if (!results.length) {\u000a              successHandler(entries);\u000a            } else {\u000a              entries = entries.concat(results);\u000a              readEntries();\u000a            }\u000a          }, errorHandler);\u000a        };\u000a      // eslint-disable-next-line no-param-reassign\u000a      path = path || '';\u000a      if (entry.isFile) {\u000a        if (entry._file) {\u000a          // Workaround for Chrome bug #149735\u000a          entry._file.relativePath = path;\u000a          dfd.resolve(entry._file);\u000a        } else {\u000a          entry.file(function (file) {\u000a            file.relativePath = path;\u000a            dfd.resolve(file);\u000a          }, errorHandler);\u000a        }\u000a      } else if (entry.isDirectory) {\u000a        dirReader = entry.createReader();\u000a        readEntries();\u000a      } else {\u000a        // Return an empty list for file system items\u000a        // other than files or directories:\u000a        dfd.resolve([]);\u000a      }\u000a      return dfd.promise();\u000a    },\u000a\u000a    _handleFileTreeEntries: function (entries, path) {\u000a      var that = this;\u000a      return $.when\u000a        .apply(\u000a          $,\u000a          $.map(entries, function (entry) {\u000a            return that._handleFileTreeEntry(entry, path);\u000a          })\u000a        )\u000a        [this._promisePipe](function () {\u000a          return Array.prototype.concat.apply([], arguments);\u000a        });\u000a    },\u000a\u000a    _getDroppedFiles: function (dataTransfer) {\u000a      // eslint-disable-next-line no-param-reassign\u000a      dataTransfer = dataTransfer || {};\u000a      var items = dataTransfer.items;\u000a      if (\u000a        items &&\u000a        items.length &&\u000a        (items[0].webkitGetAsEntry || items[0].getAsEntry)\u000a      ) {\u000a        return this._handleFileTreeEntries(\u000a          $.map(items, function (item) {\u000a            var entry;\u000a            if (item.webkitGetAsEntry) {\u000a              entry = item.webkitGetAsEntry();\u000a              if (entry) {\u000a                // Workaround for Chrome bug #149735:\u000a                entry._file = item.getAsFile();\u000a              }\u000a              return entry;\u000a            }\u000a            return item.getAsEntry();\u000a          })\u000a        );\u000a      }\u000a      return $.Deferred().resolve($.makeArray(dataTransfer.files)).promise();\u000a    },\u000a\u000a    _getSingleFileInputFiles: function (fileInput) {\u000a      // eslint-disable-next-line no-param-reassign\u000a      fileInput = $(fileInput);\u000a      var entries =\u000a          fileInput.prop('webkitEntries') || fileInput.prop('entries'),\u000a        files,\u000a        value;\u000a      if (entries && entries.length) {\u000a        return this._handleFileTreeEntries(entries);\u000a      }\u000a      files = $.makeArray(fileInput.prop('files'));\u000a      if (!files.length) {\u000a        value = fileInput.prop('value');\u000a        if (!value) {\u000a          return $.Deferred().resolve([]).promise();\u000a        }\u000a        // If the files property is not available, the browser does not\u000a        // support the File API and we add a pseudo File object with\u000a        // the input value as name with path information removed:\u000a        files = [{ name: value.replace(/^.*\u005c\u005c/, '') }];\u000a      } else if (files[0].name === undefined && files[0].fileName) {\u000a        // File normalization for Safari 4 and Firefox 3:\u000a        $.each(files, function (index, file) {\u000a          file.name = file.fileName;\u000a          file.size = file.fileSize;\u000a        });\u000a      }\u000a      return $.Deferred().resolve(files).promise();\u000a    },\u000a\u000a    _getFileInputFiles: function (fileInput) {\u000a      if (!(fileInput instanceof $) || fileInput.length === 1) {\u000a        return this._getSingleFileInputFiles(fileInput);\u000a      }\u000a      return $.when\u000a        .apply($, $.map(fileInput, this._getSingleFileInputFiles))\u000a        [this._promisePipe](function () {\u000a          return Array.prototype.concat.apply([], arguments);\u000a        });\u000a    },\u000a\u000a    _onChange: function (e) {\u000a      var that = this,\u000a        data = {\u000a          fileInput: $(e.target),\u000a          form: $(e.target.form)\u000a        };\u000a      this._getFileInputFiles(data.fileInput).always(function (files) {\u000a        data.files = files;\u000a        if (that.options.replaceFileInput) {\u000a          that._replaceFileInput(data);\u000a        }\u000a        if (\u000a          that._trigger(\u000a            'change',\u000a            $.Event('change', { delegatedEvent: e }),\u000a            data\u000a          ) !== false\u000a        ) {\u000a          that._onAdd(e, data);\u000a        }\u000a      });\u000a    },\u000a\u000a    _onPaste: function (e) {\u000a      var items =\u000a          e.originalEvent &&\u000a          e.originalEvent.clipboardData &&\u000a          e.originalEvent.clipboardData.items,\u000a        data = { files: [] };\u000a      if (items && items.length) {\u000a        $.each(items, function (index, item) {\u000a          var file = item.getAsFile && item.getAsFile();\u000a          if (file) {\u000a            data.files.push(file);\u000a          }\u000a        });\u000a        if (\u000a          this._trigger(\u000a            'paste',\u000a            $.Event('paste', { delegatedEvent: e }),\u000a            data\u000a          ) !== false\u000a        ) {\u000a          this._onAdd(e, data);\u000a        }\u000a      }\u000a    },\u000a\u000a    _onDrop: function (e) {\u000a      e.dataTransfer = e.originalEvent && e.originalEvent.dataTransfer;\u000a      var that = this,\u000a        dataTransfer = e.dataTransfer,\u000a        data = {};\u000a      if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {\u000a        e.preventDefault();\u000a        this._getDroppedFiles(dataTransfer).always(function (files) {\u000a          data.files = files;\u000a          if (\u000a            that._trigger(\u000a              'drop',\u000a              $.Event('drop', { delegatedEvent: e }),\u000a              data\u000a            ) !== false\u000a          ) {\u000a            that._onAdd(e, data);\u000a          }\u000a        });\u000a      }\u000a    },\u000a\u000a    _onDragOver: getDragHandler('dragover'),\u000a\u000a    _onDragEnter: getDragHandler('dragenter'),\u000a\u000a    _onDragLeave: getDragHandler('dragleave'),\u000a\u000a    _initEventHandlers: function () {\u000a      if (this._isXHRUpload(this.options)) {\u000a        this._on(this.options.dropZone, {\u000a          dragover: this._onDragOver,\u000a          drop: this._onDrop,\u000a          // event.preventDefault() on dragenter is required for IE10+:\u000a          dragenter: this._onDragEnter,\u000a          // dragleave is not required, but added for completeness:\u000a          dragleave: this._onDragLeave\u000a        });\u000a        this._on(this.options.pasteZone, {\u000a          paste: this._onPaste\u000a        });\u000a      }\u000a      if ($.support.fileInput) {\u000a        this._on(this.options.fileInput, {\u000a          change: this._onChange\u000a        });\u000a      }\u000a    },\u000a\u000a    _destroyEventHandlers: function () {\u000a      this._off(this.options.dropZone, 'dragenter dragleave dragover drop');\u000a      this._off(this.options.pasteZone, 'paste');\u000a      this._off(this.options.fileInput, 'change');\u000a    },\u000a\u000a    _destroy: function () {\u000a      this._destroyEventHandlers();\u000a    },\u000a\u000a    _setOption: function (key, value) {\u000a      var reinit = $.inArray(key, this._specialOptions) !== -1;\u000a      if (reinit) {\u000a        this._destroyEventHandlers();\u000a      }\u000a      this._super(key, value);\u000a      if (reinit) {\u000a        this._initSpecialOptions();\u000a        this._initEventHandlers();\u000a      }\u000a    },\u000a\u000a    _initSpecialOptions: function () {\u000a      var options = this.options;\u000a      if (options.fileInput === undefined) {\u000a        options.fileInput = this.element.is('input[type="file"]')\u000a          ? this.element\u000a          : this.element.find('input[type="file"]');\u000a      } else if (!(options.fileInput instanceof $)) {\u000a        options.fileInput = $(options.fileInput);\u000a      }\u000a      if (!(options.dropZone instanceof $)) {\u000a        options.dropZone = $(options.dropZone);\u000a      }\u000a      if (!(options.pasteZone instanceof $)) {\u000a        options.pasteZone = $(options.pasteZone);\u000a      }\u000a    },\u000a\u000a    _getRegExp: function (str) {\u000a      var parts = str.split('/'),\u000a        modifiers = parts.pop();\u000a      parts.shift();\u000a      return new RegExp(parts.join('/'), modifiers);\u000a    },\u000a\u000a    _isRegExpOption: function (key, value) {\u000a      return (\u000a        key !== 'url' &&\u000a        $.type(value) === 'string' &&\u000a        /^\u005c/.*\u005c/[igm]{0,3}$/.test(value)\u000a      );\u000a    },\u000a\u000a    _initDataAttributes: function () {\u000a      var that = this,\u000a        options = this.options,\u000a        data = this.element.data();\u000a      // Initialize options set via HTML5 data-attributes:\u000a      $.each(this.element[0].attributes, function (index, attr) {\u000a        var key = attr.name.toLowerCase(),\u000a          value;\u000a        if (/^data-/.test(key)) {\u000a          // Convert hyphen-ated key to camelCase:\u000a          key = key.slice(5).replace(/-[a-z]/g, function (str) {\u000a            return str.charAt(1).toUpperCase();\u000a          });\u000a          value = data[key];\u000a          if (that._isRegExpOption(key, value)) {\u000a            value = that._getRegExp(value);\u000a          }\u000a          options[key] = value;\u000a        }\u000a      });\u000a    },\u000a\u000a    _create: function () {\u000a      this._initDataAttributes();\u000a      this._initSpecialOptions();\u000a      this._slots = [];\u000a      this._sequence = this._getXHRPromise(true);\u000a      this._sending = this._active = 0;\u000a      this._initProgressObject(this);\u000a      this._initEventHandlers();\u000a    },\u000a\u000a    // This method is exposed to the widget API and allows to query\u000a    // the number of active uploads:\u000a    active: function () {\u000a      return this._active;\u000a    },\u000a\u000a    // This method is exposed to the widget API and allows to query\u000a    // the widget upload progress.\u000a    // It returns an object with loaded, total and bitrate properties\u000a    // for the running uploads:\u000a    progress: function () {\u000a      return this._progress;\u000a    },\u000a\u000a    // This method is exposed to the widget API and allows adding files\u000a    // using the fileupload API. The data parameter accepts an object which\u000a    // must have a files property and can contain additional options:\u000a    // .fileupload('add', {files: filesList});\u000a    add: function (data) {\u000a      var that = this;\u000a      if (!data || this.options.disabled) {\u000a        return;\u000a      }\u000a      if (data.fileInput && !data.files) {\u000a        this._getFileInputFiles(data.fileInput).always(function (files) {\u000a          data.files = files;\u000a          that._onAdd(null, data);\u000a        });\u000a      } else {\u000a        data.files = $.makeArray(data.files);\u000a        this._onAdd(null, data);\u000a      }\u000a    },\u000a\u000a    // This method is exposed to the widget API and allows sending files\u000a    // using the fileupload API. The data parameter accepts an object which\u000a    // must have a files or fileInput property and can contain additional options:\u000a    // .fileupload('send', {files: filesList});\u000a    // The method returns a Promise object for the file upload call.\u000a    send: function (data) {\u000a      if (data && !this.options.disabled) {\u000a        if (data.fileInput && !data.files) {\u000a          var that = this,\u000a            dfd = $.Deferred(),\u000a            promise = dfd.promise(),\u000a            jqXHR,\u000a            aborted;\u000a          promise.abort = function () {\u000a            aborted = true;\u000a            if (jqXHR) {\u000a              return jqXHR.abort();\u000a            }\u000a            dfd.reject(null, 'abort', 'abort');\u000a            return promise;\u000a          };\u000a          this._getFileInputFiles(data.fileInput).always(function (files) {\u000a            if (aborted) {\u000a              return;\u000a            }\u000a            if (!files.length) {\u000a              dfd.reject();\u000a              return;\u000a            }\u000a            data.files = files;\u000a            jqXHR = that._onSend(null, data);\u000a            jqXHR.then(\u000a              function (result, textStatus, jqXHR) {\u000a                dfd.resolve(result, textStatus, jqXHR);\u000a              },\u000a              function (jqXHR, textStatus, errorThrown) {\u000a                dfd.reject(jqXHR, textStatus, errorThrown);\u000a              }\u000a            );\u000a          });\u000a          return this._enhancePromise(promise);\u000a        }\u000a        data.files = $.makeArray(data.files);\u000a        if (data.files.length) {\u000a          return this._onSend(null, data);\u000a        }\u000a      }\u000a      return this._getXHRPromise(false, data && data.context);\u000a    }\u000a  });\u000a});\u000a\u000a;\u000a
p0
.