V// source: js/lib/jquery/jquery.flot.js\u000a/* Javascript plotting library for jQuery, version 0.8.3.\u000a\u000aCopyright (c) 2007-2014 IOLA and Ole Laursen.\u000aLicensed under the MIT license.\u000a\u000a*/\u000a\u000a// first an inline dependency, jquery.colorhelpers.js, we inline it here\u000a// for convenience\u000a\u000a/* Plugin for jQuery for working with colors.\u000a *\u000a * Version 1.1.\u000a *\u000a * Inspiration from jQuery color animation plugin by John Resig.\u000a *\u000a * Released under the MIT license by Ole Laursen, October 2009.\u000a *\u000a * Examples:\u000a *\u000a *   $.color.parse("#fff").scale('rgb', 0.25).add('a', -0.5).toString()\u000a *   var c = $.color.extract($("#mydiv"), 'background-color');\u000a *   console.log(c.r, c.g, c.b, c.a);\u000a *   $.color.make(100, 50, 25, 0.4).toString() // returns "rgba(100,50,25,0.4)"\u000a *\u000a * Note that .scale() and .add() return the same modified object\u000a * instead of making a new one.\u000a *\u000a * V. 1.1: Fix error handling so e.g. parsing an empty string does\u000a * produce a color rather than just crashing.\u000a */\u000a(function($){$.color={};$.color.make=function(r,g,b,a){var o={};o.r=r||0;o.g=g||0;o.b=b||0;o.a=a!=null?a:1;o.add=function(c,d){for(var i=0;i<c.length;++i)o[c.charAt(i)]+=d;return o.normalize()};o.scale=function(c,f){for(var i=0;i<c.length;++i)o[c.charAt(i)]*=f;return o.normalize()};o.toString=function(){if(o.a>=1){return"rgb("+[o.r,o.g,o.b].join(",")+")"}else{return"rgba("+[o.r,o.g,o.b,o.a].join(",")+")"}};o.normalize=function(){function clamp(min,value,max){return value<min?min:value>max?max:value}o.r=clamp(0,parseInt(o.r),255);o.g=clamp(0,parseInt(o.g),255);o.b=clamp(0,parseInt(o.b),255);o.a=clamp(0,o.a,1);return o};o.clone=function(){return $.color.make(o.r,o.b,o.g,o.a)};return o.normalize()};$.color.extract=function(elem,css){var c;do{c=elem.css(css).toLowerCase();if(c!=""&&c!="transparent")break;elem=elem.parent()}while(elem.length&&!$.nodeName(elem.get(0),"body"));if(c=="rgba(0, 0, 0, 0)")c="transparent";return $.color.parse(c)};$.color.parse=function(str){var res,m=$.color.make;if(res=/rgb\u005c(\u005cs*([0-9]{1,3})\u005cs*,\u005cs*([0-9]{1,3})\u005cs*,\u005cs*([0-9]{1,3})\u005cs*\u005c)/.exec(str))return m(parseInt(res[1],10),parseInt(res[2],10),parseInt(res[3],10));if(res=/rgba\u005c(\u005cs*([0-9]{1,3})\u005cs*,\u005cs*([0-9]{1,3})\u005cs*,\u005cs*([0-9]{1,3})\u005cs*,\u005cs*([0-9]+(?:\u005c.[0-9]+)?)\u005cs*\u005c)/.exec(str))return m(parseInt(res[1],10),parseInt(res[2],10),parseInt(res[3],10),parseFloat(res[4]));if(res=/rgb\u005c(\u005cs*([0-9]+(?:\u005c.[0-9]+)?)\u005c%\u005cs*,\u005cs*([0-9]+(?:\u005c.[0-9]+)?)\u005c%\u005cs*,\u005cs*([0-9]+(?:\u005c.[0-9]+)?)\u005c%\u005cs*\u005c)/.exec(str))return m(parseFloat(res[1])*2.55,parseFloat(res[2])*2.55,parseFloat(res[3])*2.55);if(res=/rgba\u005c(\u005cs*([0-9]+(?:\u005c.[0-9]+)?)\u005c%\u005cs*,\u005cs*([0-9]+(?:\u005c.[0-9]+)?)\u005c%\u005cs*,\u005cs*([0-9]+(?:\u005c.[0-9]+)?)\u005c%\u005cs*,\u005cs*([0-9]+(?:\u005c.[0-9]+)?)\u005cs*\u005c)/.exec(str))return m(parseFloat(res[1])*2.55,parseFloat(res[2])*2.55,parseFloat(res[3])*2.55,parseFloat(res[4]));if(res=/#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(str))return m(parseInt(res[1],16),parseInt(res[2],16),parseInt(res[3],16));if(res=/#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(str))return m(parseInt(res[1]+res[1],16),parseInt(res[2]+res[2],16),parseInt(res[3]+res[3],16));var name=$.trim(str).toLowerCase();if(name=="transparent")return m(255,255,255,0);else{res=lookupColors[name]||[0,0,0];return m(res[0],res[1],res[2])}};var lookupColors={aqua:[0,255,255],azure:[240,255,255],beige:[245,245,220],black:[0,0,0],blue:[0,0,255],brown:[165,42,42],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgrey:[169,169,169],darkgreen:[0,100,0],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkviolet:[148,0,211],fuchsia:[255,0,255],gold:[255,215,0],green:[0,128,0],indigo:[75,0,130],khaki:[240,230,140],lightblue:[173,216,230],lightcyan:[224,255,255],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightyellow:[255,255,224],lime:[0,255,0],magenta:[255,0,255],maroon:[128,0,0],navy:[0,0,128],olive:[128,128,0],orange:[255,165,0],pink:[255,192,203],purple:[128,0,128],violet:[128,0,128],red:[255,0,0],silver:[192,192,192],white:[255,255,255],yellow:[255,255,0]}})(jQuery);\u000a\u000a// the actual Flot code\u000a(function($) {\u000a\u000a	// Cache the prototype hasOwnProperty for faster access\u000a\u000a	var hasOwnProperty = Object.prototype.hasOwnProperty;\u000a\u000a    // A shim to provide 'detach' to jQuery versions prior to 1.4.  Using a DOM\u000a    // operation produces the same effect as detach, i.e. removing the element\u000a    // without touching its jQuery data.\u000a\u000a    // Do not merge this into Flot 0.9, since it requires jQuery 1.4.4+.\u000a\u000a    if (!$.fn.detach) {\u000a        $.fn.detach = function() {\u000a            return this.each(function() {\u000a                if (this.parentNode) {\u000a                    this.parentNode.removeChild( this );\u000a                }\u000a            });\u000a        };\u000a    }\u000a\u000a	///////////////////////////////////////////////////////////////////////////\u000a	// The Canvas object is a wrapper around an HTML5 <canvas> tag.\u000a	//\u000a	// @constructor\u000a	// @param {string} cls List of classes to apply to the canvas.\u000a	// @param {element} container Element onto which to append the canvas.\u000a	//\u000a	// Requiring a container is a little iffy, but unfortunately canvas\u000a	// operations don't work unless the canvas is attached to the DOM.\u000a\u000a	function Canvas(cls, container) {\u000a\u000a		var element = container.children("." + cls)[0];\u000a\u000a		if (element == null) {\u000a\u000a			element = document.createElement("canvas");\u000a			element.className = cls;\u000a\u000a			$(element).css({ direction: "ltr", position: "absolute", left: 0, top: 0 })\u000a				.appendTo(container);\u000a\u000a			// If HTML5 Canvas isn't available, fall back to [Ex|Flash]canvas\u000a\u000a			if (!element.getContext) {\u000a				if (window.G_vmlCanvasManager) {\u000a					element = window.G_vmlCanvasManager.initElement(element);\u000a				} else {\u000a					throw new Error("Canvas is not available. If you're using IE with a fall-back such as Excanvas, then there's either a mistake in your conditional include, or the page has no DOCTYPE and is rendering in Quirks Mode.");\u000a				}\u000a			}\u000a		}\u000a\u000a		this.element = element;\u000a\u000a		var context = this.context = element.getContext("2d");\u000a\u000a		// Determine the screen's ratio of physical to device-independent\u000a		// pixels.  This is the ratio between the canvas width that the browser\u000a		// advertises and the number of pixels actually present in that space.\u000a\u000a		// The iPhone 4, for example, has a device-independent width of 320px,\u000a		// but its screen is actually 640px wide.  It therefore has a pixel\u000a		// ratio of 2, while most normal devices have a ratio of 1.\u000a\u000a		var devicePixelRatio = window.devicePixelRatio || 1,\u000a			backingStoreRatio =\u000a				context.webkitBackingStorePixelRatio ||\u000a				context.mozBackingStorePixelRatio ||\u000a				context.msBackingStorePixelRatio ||\u000a				context.oBackingStorePixelRatio ||\u000a				context.backingStorePixelRatio || 1;\u000a\u000a		this.pixelRatio = devicePixelRatio / backingStoreRatio;\u000a\u000a		// Size the canvas to match the internal dimensions of its container\u000a\u000a		this.resize(container.width(), container.height());\u000a\u000a		// Collection of HTML div layers for text overlaid onto the canvas\u000a\u000a		this.textContainer = null;\u000a		this.text = {};\u000a\u000a		// Cache of text fragments and metrics, so we can avoid expensively\u000a		// re-calculating them when the plot is re-rendered in a loop.\u000a\u000a		this._textCache = {};\u000a	}\u000a\u000a	// Resizes the canvas to the given dimensions.\u000a	//\u000a	// @param {number} width New width of the canvas, in pixels.\u000a	// @param {number} width New height of the canvas, in pixels.\u000a\u000a	Canvas.prototype.resize = function(width, height) {\u000a\u000a		if (width <= 0 || height <= 0) {\u000a			throw new Error("Invalid dimensions for plot, width = " + width + ", height = " + height);\u000a		}\u000a\u000a		var element = this.element,\u000a			context = this.context,\u000a			pixelRatio = this.pixelRatio;\u000a\u000a		// Resize the canvas, increasing its density based on the display's\u000a		// pixel ratio; basically giving it more pixels without increasing the\u000a		// size of its element, to take advantage of the fact that retina\u000a		// displays have that many more pixels in the same advertised space.\u000a\u000a		// Resizing should reset the state (excanvas seems to be buggy though)\u000a\u000a		if (this.width != width) {\u000a			element.width = width * pixelRatio;\u000a			element.style.width = width + "px";\u000a			this.width = width;\u000a		}\u000a\u000a		if (this.height != height) {\u000a			element.height = height * pixelRatio;\u000a			element.style.height = height + "px";\u000a			this.height = height;\u000a		}\u000a\u000a		// Save the context, so we can reset in case we get replotted.  The\u000a		// restore ensure that we're really back at the initial state, and\u000a		// should be safe even if we haven't saved the initial state yet.\u000a\u000a		context.restore();\u000a		context.save();\u000a\u000a		// Scale the coordinate space to match the display density; so even though we\u000a		// may have twice as many pixels, we still want lines and other drawing to\u000a		// appear at the same size; the extra pixels will just make them crisper.\u000a\u000a		context.scale(pixelRatio, pixelRatio);\u000a	};\u000a\u000a	// Clears the entire canvas area, not including any overlaid HTML text\u000a\u000a	Canvas.prototype.clear = function() {\u000a		this.context.clearRect(0, 0, this.width, this.height);\u000a	};\u000a\u000a	// Finishes rendering the canvas, including managing the text overlay.\u000a\u000a	Canvas.prototype.render = function() {\u000a\u000a		var cache = this._textCache;\u000a\u000a		// For each text layer, add elements marked as active that haven't\u000a		// already been rendered, and remove those that are no longer active.\u000a\u000a		for (var layerKey in cache) {\u000a			if (hasOwnProperty.call(cache, layerKey)) {\u000a\u000a				var layer = this.getTextLayer(layerKey),\u000a					layerCache = cache[layerKey];\u000a\u000a				layer.hide();\u000a\u000a				for (var styleKey in layerCache) {\u000a					if (hasOwnProperty.call(layerCache, styleKey)) {\u000a						var styleCache = layerCache[styleKey];\u000a						for (var key in styleCache) {\u000a							if (hasOwnProperty.call(styleCache, key)) {\u000a\u000a								var positions = styleCache[key].positions;\u000a\u000a								for (var i = 0, position; position = positions[i]; i++) {\u000a									if (position.active) {\u000a										if (!position.rendered) {\u000a											layer.append(position.element);\u000a											position.rendered = true;\u000a										}\u000a									} else {\u000a										positions.splice(i--, 1);\u000a										if (position.rendered) {\u000a											position.element.detach();\u000a										}\u000a									}\u000a								}\u000a\u000a								if (positions.length == 0) {\u000a									delete styleCache[key];\u000a								}\u000a							}\u000a						}\u000a					}\u000a				}\u000a\u000a				layer.show();\u000a			}\u000a		}\u000a	};\u000a\u000a	// Creates (if necessary) and returns the text overlay container.\u000a	//\u000a	// @param {string} classes String of space-separated CSS classes used to\u000a	//     uniquely identify the text layer.\u000a	// @return {object} The jQuery-wrapped text-layer div.\u000a\u000a	Canvas.prototype.getTextLayer = function(classes) {\u000a\u000a		var layer = this.text[classes];\u000a\u000a		// Create the text layer if it doesn't exist\u000a\u000a		if (layer == null) {\u000a\u000a			// Create the text layer container, if it doesn't exist\u000a\u000a			if (this.textContainer == null) {\u000a				this.textContainer = $("<div class='flot-text'></div>")\u000a					.css({\u000a						position: "absolute",\u000a						top: 0,\u000a						left: 0,\u000a						bottom: 0,\u000a						right: 0,\u000a						'font-size': "smaller",\u000a						color: "#545454"\u000a					})\u000a					.insertAfter(this.element);\u000a			}\u000a\u000a			layer = this.text[classes] = $("<div></div>")\u000a				.addClass(classes)\u000a				.css({\u000a					position: "absolute",\u000a					top: 0,\u000a					left: 0,\u000a					bottom: 0,\u000a					right: 0\u000a				})\u000a				.appendTo(this.textContainer);\u000a		}\u000a\u000a		return layer;\u000a	};\u000a\u000a	// Creates (if necessary) and returns a text info object.\u000a	//\u000a	// The object looks like this:\u000a	//\u000a	// {\u000a	//     width: Width of the text's wrapper div.\u000a	//     height: Height of the text's wrapper div.\u000a	//     element: The jQuery-wrapped HTML div containing the text.\u000a	//     positions: Array of positions at which this text is drawn.\u000a	// }\u000a	//\u000a	// The positions array contains objects that look like this:\u000a	//\u000a	// {\u000a	//     active: Flag indicating whether the text should be visible.\u000a	//     rendered: Flag indicating whether the text is currently visible.\u000a	//     element: The jQuery-wrapped HTML div containing the text.\u000a	//     x: X coordinate at which to draw the text.\u000a	//     y: Y coordinate at which to draw the text.\u000a	// }\u000a	//\u000a	// Each position after the first receives a clone of the original element.\u000a	//\u000a	// The idea is that that the width, height, and general 'identity' of the\u000a	// text is constant no matter where it is placed; the placements are a\u000a	// secondary property.\u000a	//\u000a	// Canvas maintains a cache of recently-used text info objects; getTextInfo\u000a	// either returns the cached element or creates a new entry.\u000a	//\u000a	// @param {string} layer A string of space-separated CSS classes uniquely\u000a	//     identifying the layer containing this text.\u000a	// @param {string} text Text string to retrieve info for.\u000a	// @param {(string|object)=} font Either a string of space-separated CSS\u000a	//     classes or a font-spec object, defining the text's font and style.\u000a	// @param {number=} angle Angle at which to rotate the text, in degrees.\u000a	//     Angle is currently unused, it will be implemented in the future.\u000a	// @param {number=} width Maximum width of the text before it wraps.\u000a	// @return {object} a text info object.\u000a\u000a	Canvas.prototype.getTextInfo = function(layer, text, font, angle, width) {\u000a\u000a		var textStyle, layerCache, styleCache, info;\u000a\u000a		// Cast the value to a string, in case we were given a number or such\u000a\u000a		text = "" + text;\u000a\u000a		// If the font is a font-spec object, generate a CSS font definition\u000a\u000a		if (typeof font === "object") {\u000a			textStyle = font.style + " " + font.variant + " " + font.weight + " " + font.size + "px/" + font.lineHeight + "px " + font.family;\u000a		} else {\u000a			textStyle = font;\u000a		}\u000a\u000a		// Retrieve (or create) the cache for the text's layer and styles\u000a\u000a		layerCache = this._textCache[layer];\u000a\u000a		if (layerCache == null) {\u000a			layerCache = this._textCache[layer] = {};\u000a		}\u000a\u000a		styleCache = layerCache[textStyle];\u000a\u000a		if (styleCache == null) {\u000a			styleCache = layerCache[textStyle] = {};\u000a		}\u000a\u000a		info = styleCache[text];\u000a\u000a		// If we can't find a matching element in our cache, create a new one\u000a\u000a		if (info == null) {\u000a\u000a			var element = $("<div></div>").html(text)\u000a				.css({\u000a					position: "absolute",\u000a					'max-width': width,\u000a					top: -9999\u000a				})\u000a				.appendTo(this.getTextLayer(layer));\u000a\u000a			if (typeof font === "object") {\u000a				element.css({\u000a					font: textStyle,\u000a					color: font.color\u000a				});\u000a			} else if (typeof font === "string") {\u000a				element.addClass(font);\u000a			}\u000a\u000a			info = styleCache[text] = {\u000a				width: element.outerWidth(true),\u000a				height: element.outerHeight(true),\u000a				element: element,\u000a				positions: []\u000a			};\u000a\u000a			element.detach();\u000a		}\u000a\u000a		return info;\u000a	};\u000a\u000a	// Adds a text string to the canvas text overlay.\u000a	//\u000a	// The text isn't drawn immediately; it is marked as rendering, which will\u000a	// result in its addition to the canvas on the next render pass.\u000a	//\u000a	// @param {string} layer A string of space-separated CSS classes uniquely\u000a	//     identifying the layer containing this text.\u000a	// @param {number} x X coordinate at which to draw the text.\u000a	// @param {number} y Y coordinate at which to draw the text.\u000a	// @param {string} text Text string to draw.\u000a	// @param {(string|object)=} font Either a string of space-separated CSS\u000a	//     classes or a font-spec object, defining the text's font and style.\u000a	// @param {number=} angle Angle at which to rotate the text, in degrees.\u000a	//     Angle is currently unused, it will be implemented in the future.\u000a	// @param {number=} width Maximum width of the text before it wraps.\u000a	// @param {string=} halign Horizontal alignment of the text; either "left",\u000a	//     "center" or "right".\u000a	// @param {string=} valign Vertical alignment of the text; either "top",\u000a	//     "middle" or "bottom".\u000a\u000a	Canvas.prototype.addText = function(layer, x, y, text, font, angle, width, halign, valign) {\u000a\u000a		var info = this.getTextInfo(layer, text, font, angle, width),\u000a			positions = info.positions;\u000a\u000a		// Tweak the div's position to match the text's alignment\u000a\u000a		if (halign == "center") {\u000a			x -= info.width / 2;\u000a		} else if (halign == "right") {\u000a			x -= info.width;\u000a		}\u000a\u000a		if (valign == "middle") {\u000a			y -= info.height / 2;\u000a		} else if (valign == "bottom") {\u000a			y -= info.height;\u000a		}\u000a\u000a		// Determine whether this text already exists at this position.\u000a		// If so, mark it for inclusion in the next render pass.\u000a\u000a		for (var i = 0, position; position = positions[i]; i++) {\u000a			if (position.x == x && position.y == y) {\u000a				position.active = true;\u000a				return;\u000a			}\u000a		}\u000a\u000a		// If the text doesn't exist at this position, create a new entry\u000a\u000a		// For the very first position we'll re-use the original element,\u000a		// while for subsequent ones we'll clone it.\u000a\u000a		position = {\u000a			active: true,\u000a			rendered: false,\u000a			element: positions.length ? info.element.clone() : info.element,\u000a			x: x,\u000a			y: y\u000a		};\u000a\u000a		positions.push(position);\u000a\u000a		// Move the element to its final position within the container\u000a\u000a		position.element.css({\u000a			top: Math.round(y),\u000a			left: Math.round(x),\u000a			'text-align': halign	// In case the text wraps\u000a		});\u000a	};\u000a\u000a	// Removes one or more text strings from the canvas text overlay.\u000a	//\u000a	// If no parameters are given, all text within the layer is removed.\u000a	//\u000a	// Note that the text is not immediately removed; it is simply marked as\u000a	// inactive, which will result in its removal on the next render pass.\u000a	// This avoids the performance penalty for 'clear and redraw' behavior,\u000a	// where we potentially get rid of all text on a layer, but will likely\u000a	// add back most or all of it later, as when redrawing axes, for example.\u000a	//\u000a	// @param {string} layer A string of space-separated CSS classes uniquely\u000a	//     identifying the layer containing this text.\u000a	// @param {number=} x X coordinate of the text.\u000a	// @param {number=} y Y coordinate of the text.\u000a	// @param {string=} text Text string to remove.\u000a	// @param {(string|object)=} font Either a string of space-separated CSS\u000a	//     classes or a font-spec object, defining the text's font and style.\u000a	// @param {number=} angle Angle at which the text is rotated, in degrees.\u000a	//     Angle is currently unused, it will be implemented in the future.\u000a\u000a	Canvas.prototype.removeText = function(layer, x, y, text, font, angle) {\u000a		if (text == null) {\u000a			var layerCache = this._textCache[layer];\u000a			if (layerCache != null) {\u000a				for (var styleKey in layerCache) {\u000a					if (hasOwnProperty.call(layerCache, styleKey)) {\u000a						var styleCache = layerCache[styleKey];\u000a						for (var key in styleCache) {\u000a							if (hasOwnProperty.call(styleCache, key)) {\u000a								var positions = styleCache[key].positions;\u000a								for (var i = 0, position; position = positions[i]; i++) {\u000a									position.active = false;\u000a								}\u000a							}\u000a						}\u000a					}\u000a				}\u000a			}\u000a		} else {\u000a			var positions = this.getTextInfo(layer, text, font, angle).positions;\u000a			for (var i = 0, position; position = positions[i]; i++) {\u000a				if (position.x == x && position.y == y) {\u000a					position.active = false;\u000a				}\u000a			}\u000a		}\u000a	};\u000a\u000a	///////////////////////////////////////////////////////////////////////////\u000a	// The top-level container for the entire plot.\u000a\u000a    function Plot(placeholder, data_, options_, plugins) {\u000a        // data is on the form:\u000a        //   [ series1, series2 ... ]\u000a        // where series is either just the data as [ [x1, y1], [x2, y2], ... ]\u000a        // or { data: [ [x1, y1], [x2, y2], ... ], label: "some label", ... }\u000a\u000a        var series = [],\u000a            options = {\u000a                // the color theme used for graphs\u000a                colors: ["#edc240", "#afd8f8", "#cb4b4b", "#4da74d", "#9440ed"],\u000a                legend: {\u000a                    show: true,\u000a                    noColumns: 1, // number of colums in legend table\u000a                    labelFormatter: null, // fn: string -> string\u000a                    labelBoxBorderColor: "#ccc", // border color for the little label boxes\u000a                    container: null, // container (as jQuery object) to put legend in, null means default on top of graph\u000a                    position: "ne", // position of default legend container within plot\u000a                    margin: 5, // distance from grid edge to default legend container within plot\u000a                    backgroundColor: null, // null means auto-detect\u000a                    backgroundOpacity: 0.85, // set to 0 to avoid background\u000a                    sorted: null    // default to no legend sorting\u000a                },\u000a                xaxis: {\u000a                    show: null, // null = auto-detect, true = always, false = never\u000a                    position: "bottom", // or "top"\u000a                    mode: null, // null or "time"\u000a                    font: null, // null (derived from CSS in placeholder) or object like { size: 11, lineHeight: 13, style: "italic", weight: "bold", family: "sans-serif", variant: "small-caps" }\u000a                    color: null, // base color, labels, ticks\u000a                    tickColor: null, // possibly different color of ticks, e.g. "rgba(0,0,0,0.15)"\u000a                    transform: null, // null or f: number -> number to transform axis\u000a                    inverseTransform: null, // if transform is set, this should be the inverse function\u000a                    min: null, // min. value to show, null means set automatically\u000a                    max: null, // max. value to show, null means set automatically\u000a                    autoscaleMargin: null, // margin in % to add if auto-setting min/max\u000a                    ticks: null, // either [1, 3] or [[1, "a"], 3] or (fn: axis info -> ticks) or app. number of ticks for auto-ticks\u000a                    tickFormatter: null, // fn: number -> string\u000a                    labelWidth: null, // size of tick labels in pixels\u000a                    labelHeight: null,\u000a                    reserveSpace: null, // whether to reserve space even if axis isn't shown\u000a                    tickLength: null, // size in pixels of ticks, or "full" for whole line\u000a                    alignTicksWithAxis: null, // axis number or null for no sync\u000a                    tickDecimals: null, // no. of decimals, null means auto\u000a                    tickSize: null, // number or [number, "unit"]\u000a                    minTickSize: null // number or [number, "unit"]\u000a                },\u000a                yaxis: {\u000a                    autoscaleMargin: 0.02,\u000a                    position: "left" // or "right"\u000a                },\u000a                xaxes: [],\u000a                yaxes: [],\u000a                series: {\u000a                    points: {\u000a                        show: false,\u000a                        radius: 3,\u000a                        lineWidth: 2, // in pixels\u000a                        fill: true,\u000a                        fillColor: "#ffffff",\u000a                        symbol: "circle" // or callback\u000a                    },\u000a                    lines: {\u000a                        // we don't put in show: false so we can see\u000a                        // whether lines were actively disabled\u000a                        lineWidth: 2, // in pixels\u000a                        fill: false,\u000a                        fillColor: null,\u000a                        steps: false\u000a                        // Omit 'zero', so we can later default its value to\u000a                        // match that of the 'fill' option.\u000a                    },\u000a                    bars: {\u000a                        show: false,\u000a                        lineWidth: 2, // in pixels\u000a                        barWidth: 1, // in units of the x axis\u000a                        fill: true,\u000a                        fillColor: null,\u000a                        align: "left", // "left", "right", or "center"\u000a                        horizontal: false,\u000a                        zero: true\u000a                    },\u000a                    shadowSize: 3,\u000a                    highlightColor: null\u000a                },\u000a                grid: {\u000a                    show: true,\u000a                    aboveData: false,\u000a                    color: "#545454", // primary color used for outline and labels\u000a                    backgroundColor: null, // null for transparent, else color\u000a                    borderColor: null, // set if different from the grid color\u000a                    tickColor: null, // color for the ticks, e.g. "rgba(0,0,0,0.15)"\u000a                    margin: 0, // distance from the canvas edge to the grid\u000a                    labelMargin: 5, // in pixels\u000a                    axisMargin: 8, // in pixels\u000a                    borderWidth: 2, // in pixels\u000a                    minBorderMargin: null, // in pixels, null means taken from points radius\u000a                    markings: null, // array of ranges or fn: axes -> array of ranges\u000a                    markingsColor: "#f4f4f4",\u000a                    markingsLineWidth: 2,\u000a                    // interactive stuff\u000a                    clickable: false,\u000a                    hoverable: false,\u000a                    autoHighlight: true, // highlight in case mouse is near\u000a                    mouseActiveRadius: 10 // how far the mouse can be away to activate an item\u000a                },\u000a                interaction: {\u000a                    redrawOverlayInterval: 1000/60 // time between updates, -1 means in same flow\u000a                },\u000a                hooks: {}\u000a            },\u000a        surface = null,     // the canvas for the plot itself\u000a        overlay = null,     // canvas for interactive stuff on top of plot\u000a        eventHolder = null, // jQuery object that events should be bound to\u000a        ctx = null, octx = null,\u000a        xaxes = [], yaxes = [],\u000a        plotOffset = { left: 0, right: 0, top: 0, bottom: 0},\u000a        plotWidth = 0, plotHeight = 0,\u000a        hooks = {\u000a            processOptions: [],\u000a            processRawData: [],\u000a            processDatapoints: [],\u000a            processOffset: [],\u000a            drawBackground: [],\u000a            drawSeries: [],\u000a            draw: [],\u000a            bindEvents: [],\u000a            drawOverlay: [],\u000a            shutdown: []\u000a        },\u000a        plot = this;\u000a\u000a        // public functions\u000a        plot.setData = setData;\u000a        plot.setupGrid = setupGrid;\u000a        plot.draw = draw;\u000a        plot.getPlaceholder = function() { return placeholder; };\u000a        plot.getCanvas = function() { return surface.element; };\u000a        plot.getPlotOffset = function() { return plotOffset; };\u000a        plot.width = function () { return plotWidth; };\u000a        plot.height = function () { return plotHeight; };\u000a        plot.offset = function () {\u000a            var o = eventHolder.offset();\u000a            o.left += plotOffset.left;\u000a            o.top += plotOffset.top;\u000a            return o;\u000a        };\u000a        plot.getData = function () { return series; };\u000a        plot.getAxes = function () {\u000a            var res = {}, i;\u000a            $.each(xaxes.concat(yaxes), function (_, axis) {\u000a                if (axis)\u000a                    res[axis.direction + (axis.n != 1 ? axis.n : "") + "axis"] = axis;\u000a            });\u000a            return res;\u000a        };\u000a        plot.getXAxes = function () { return xaxes; };\u000a        plot.getYAxes = function () { return yaxes; };\u000a        plot.c2p = canvasToAxisCoords;\u000a        plot.p2c = axisToCanvasCoords;\u000a        plot.getOptions = function () { return options; };\u000a        plot.highlight = highlight;\u000a        plot.unhighlight = unhighlight;\u000a        plot.triggerRedrawOverlay = triggerRedrawOverlay;\u000a        plot.pointOffset = function(point) {\u000a            return {\u000a                left: parseInt(xaxes[axisNumber(point, "x") - 1].p2c(+point.x) + plotOffset.left, 10),\u000a                top: parseInt(yaxes[axisNumber(point, "y") - 1].p2c(+point.y) + plotOffset.top, 10)\u000a            };\u000a        };\u000a        plot.shutdown = shutdown;\u000a        plot.destroy = function () {\u000a            shutdown();\u000a            placeholder.removeData("plot").empty();\u000a\u000a            series = [];\u000a            options = null;\u000a            surface = null;\u000a            overlay = null;\u000a            eventHolder = null;\u000a            ctx = null;\u000a            octx = null;\u000a            xaxes = [];\u000a            yaxes = [];\u000a            hooks = null;\u000a            highlights = [];\u000a            plot = null;\u000a        };\u000a        plot.resize = function () {\u000a        	var width = placeholder.width(),\u000a        		height = placeholder.height();\u000a            surface.resize(width, height);\u000a            overlay.resize(width, height);\u000a        };\u000a\u000a        // public attributes\u000a        plot.hooks = hooks;\u000a\u000a        // initialize\u000a        initPlugins(plot);\u000a        parseOptions(options_);\u000a        setupCanvases();\u000a        setData(data_);\u000a        setupGrid();\u000a        draw();\u000a        bindEvents();\u000a\u000a\u000a        function executeHooks(hook, args) {\u000a            args = [plot].concat(args);\u000a            for (var i = 0; i < hook.length; ++i)\u000a                hook[i].apply(this, args);\u000a        }\u000a\u000a        function initPlugins() {\u000a\u000a            // References to key classes, allowing plugins to modify them\u000a\u000a            var classes = {\u000a                Canvas: Canvas\u000a            };\u000a\u000a            for (var i = 0; i < plugins.length; ++i) {\u000a                var p = plugins[i];\u000a                p.init(plot, classes);\u000a                if (p.options)\u000a                    $.extend(true, options, p.options);\u000a            }\u000a        }\u000a\u000a        function parseOptions(opts) {\u000a\u000a            $.extend(true, options, opts);\u000a\u000a            // $.extend merges arrays, rather than replacing them.  When less\u000a            // colors are provided than the size of the default palette, we\u000a            // end up with those colors plus the remaining defaults, which is\u000a            // not expected behavior; avoid it by replacing them here.\u000a\u000a            if (opts && opts.colors) {\u000a            	options.colors = opts.colors;\u000a            }\u000a\u000a            if (options.xaxis.color == null)\u000a                options.xaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();\u000a            if (options.yaxis.color == null)\u000a                options.yaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();\u000a\u000a            if (options.xaxis.tickColor == null) // grid.tickColor for back-compatibility\u000a                options.xaxis.tickColor = options.grid.tickColor || options.xaxis.color;\u000a            if (options.yaxis.tickColor == null) // grid.tickColor for back-compatibility\u000a                options.yaxis.tickColor = options.grid.tickColor || options.yaxis.color;\u000a\u000a            if (options.grid.borderColor == null)\u000a                options.grid.borderColor = options.grid.color;\u000a            if (options.grid.tickColor == null)\u000a                options.grid.tickColor = $.color.parse(options.grid.color).scale('a', 0.22).toString();\u000a\u000a            // Fill in defaults for axis options, including any unspecified\u000a            // font-spec fields, if a font-spec was provided.\u000a\u000a            // If no x/y axis options were provided, create one of each anyway,\u000a            // since the rest of the code assumes that they exist.\u000a\u000a            var i, axisOptions, axisCount,\u000a                fontSize = placeholder.css("font-size"),\u000a                fontSizeDefault = fontSize ? +fontSize.replace("px", "") : 13,\u000a                fontDefaults = {\u000a                    style: placeholder.css("font-style"),\u000a                    size: Math.round(0.8 * fontSizeDefault),\u000a                    variant: placeholder.css("font-variant"),\u000a                    weight: placeholder.css("font-weight"),\u000a                    family: placeholder.css("font-family")\u000a                };\u000a\u000a            axisCount = options.xaxes.length || 1;\u000a            for (i = 0; i < axisCount; ++i) {\u000a\u000a                axisOptions = options.xaxes[i];\u000a                if (axisOptions && !axisOptions.tickColor) {\u000a                    axisOptions.tickColor = axisOptions.color;\u000a                }\u000a\u000a                axisOptions = $.extend(true, {}, options.xaxis, axisOptions);\u000a                options.xaxes[i] = axisOptions;\u000a\u000a                if (axisOptions.font) {\u000a                    axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);\u000a                    if (!axisOptions.font.color) {\u000a                        axisOptions.font.color = axisOptions.color;\u000a                    }\u000a                    if (!axisOptions.font.lineHeight) {\u000a                        axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);\u000a                    }\u000a                }\u000a            }\u000a\u000a            axisCount = options.yaxes.length || 1;\u000a            for (i = 0; i < axisCount; ++i) {\u000a\u000a                axisOptions = options.yaxes[i];\u000a                if (axisOptions && !axisOptions.tickColor) {\u000a                    axisOptions.tickColor = axisOptions.color;\u000a                }\u000a\u000a                axisOptions = $.extend(true, {}, options.yaxis, axisOptions);\u000a                options.yaxes[i] = axisOptions;\u000a\u000a                if (axisOptions.font) {\u000a                    axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);\u000a                    if (!axisOptions.font.color) {\u000a                        axisOptions.font.color = axisOptions.color;\u000a                    }\u000a                    if (!axisOptions.font.lineHeight) {\u000a                        axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);\u000a                    }\u000a                }\u000a            }\u000a\u000a            // backwards compatibility, to be removed in future\u000a            if (options.xaxis.noTicks && options.xaxis.ticks == null)\u000a                options.xaxis.ticks = options.xaxis.noTicks;\u000a            if (options.yaxis.noTicks && options.yaxis.ticks == null)\u000a                options.yaxis.ticks = options.yaxis.noTicks;\u000a            if (options.x2axis) {\u000a                options.xaxes[1] = $.extend(true, {}, options.xaxis, options.x2axis);\u000a                options.xaxes[1].position = "top";\u000a                // Override the inherit to allow the axis to auto-scale\u000a                if (options.x2axis.min == null) {\u000a                    options.xaxes[1].min = null;\u000a                }\u000a                if (options.x2axis.max == null) {\u000a                    options.xaxes[1].max = null;\u000a                }\u000a            }\u000a            if (options.y2axis) {\u000a                options.yaxes[1] = $.extend(true, {}, options.yaxis, options.y2axis);\u000a                options.yaxes[1].position = "right";\u000a                // Override the inherit to allow the axis to auto-scale\u000a                if (options.y2axis.min == null) {\u000a                    options.yaxes[1].min = null;\u000a                }\u000a                if (options.y2axis.max == null) {\u000a                    options.yaxes[1].max = null;\u000a                }\u000a            }\u000a            if (options.grid.coloredAreas)\u000a                options.grid.markings = options.grid.coloredAreas;\u000a            if (options.grid.coloredAreasColor)\u000a                options.grid.markingsColor = options.grid.coloredAreasColor;\u000a            if (options.lines)\u000a                $.extend(true, options.series.lines, options.lines);\u000a            if (options.points)\u000a                $.extend(true, options.series.points, options.points);\u000a            if (options.bars)\u000a                $.extend(true, options.series.bars, options.bars);\u000a            if (options.shadowSize != null)\u000a                options.series.shadowSize = options.shadowSize;\u000a            if (options.highlightColor != null)\u000a                options.series.highlightColor = options.highlightColor;\u000a\u000a            // save options on axes for future reference\u000a            for (i = 0; i < options.xaxes.length; ++i)\u000a                getOrCreateAxis(xaxes, i + 1).options = options.xaxes[i];\u000a            for (i = 0; i < options.yaxes.length; ++i)\u000a                getOrCreateAxis(yaxes, i + 1).options = options.yaxes[i];\u000a\u000a            // add hooks from options\u000a            for (var n in hooks)\u000a                if (options.hooks[n] && options.hooks[n].length)\u000a                    hooks[n] = hooks[n].concat(options.hooks[n]);\u000a\u000a            executeHooks(hooks.processOptions, [options]);\u000a        }\u000a\u000a        function setData(d) {\u000a            series = parseData(d);\u000a            fillInSeriesOptions();\u000a            processData();\u000a        }\u000a\u000a        function parseData(d) {\u000a            var res = [];\u000a            for (var i = 0; i < d.length; ++i) {\u000a                var s = $.extend(true, {}, options.series);\u000a\u000a                if (d[i].data != null) {\u000a                    s.data = d[i].data; // move the data instead of deep-copy\u000a                    delete d[i].data;\u000a\u000a                    $.extend(true, s, d[i]);\u000a\u000a                    d[i].data = s.data;\u000a                }\u000a                else\u000a                    s.data = d[i];\u000a                res.push(s);\u000a            }\u000a\u000a            return res;\u000a        }\u000a\u000a        function axisNumber(obj, coord) {\u000a            var a = obj[coord + "axis"];\u000a            if (typeof a == "object") // if we got a real axis, extract number\u000a                a = a.n;\u000a            if (typeof a != "number")\u000a                a = 1; // default to first axis\u000a            return a;\u000a        }\u000a\u000a        function allAxes() {\u000a            // return flat array without annoying null entries\u000a            return $.grep(xaxes.concat(yaxes), function (a) { return a; });\u000a        }\u000a\u000a        function canvasToAxisCoords(pos) {\u000a            // return an object with x/y corresponding to all used axes\u000a            var res = {}, i, axis;\u000a            for (i = 0; i < xaxes.length; ++i) {\u000a                axis = xaxes[i];\u000a                if (axis && axis.used)\u000a                    res["x" + axis.n] = axis.c2p(pos.left);\u000a            }\u000a\u000a            for (i = 0; i < yaxes.length; ++i) {\u000a                axis = yaxes[i];\u000a                if (axis && axis.used)\u000a                    res["y" + axis.n] = axis.c2p(pos.top);\u000a            }\u000a\u000a            if (res.x1 !== undefined)\u000a                res.x = res.x1;\u000a            if (res.y1 !== undefined)\u000a                res.y = res.y1;\u000a\u000a            return res;\u000a        }\u000a\u000a        function axisToCanvasCoords(pos) {\u000a            // get canvas coords from the first pair of x/y found in pos\u000a            var res = {}, i, axis, key;\u000a\u000a            for (i = 0; i < xaxes.length; ++i) {\u000a                axis = xaxes[i];\u000a                if (axis && axis.used) {\u000a                    key = "x" + axis.n;\u000a                    if (pos[key] == null && axis.n == 1)\u000a                        key = "x";\u000a\u000a                    if (pos[key] != null) {\u000a                        res.left = axis.p2c(pos[key]);\u000a                        break;\u000a                    }\u000a                }\u000a            }\u000a\u000a            for (i = 0; i < yaxes.length; ++i) {\u000a                axis = yaxes[i];\u000a                if (axis && axis.used) {\u000a                    key = "y" + axis.n;\u000a                    if (pos[key] == null && axis.n == 1)\u000a                        key = "y";\u000a\u000a                    if (pos[key] != null) {\u000a                        res.top = axis.p2c(pos[key]);\u000a                        break;\u000a                    }\u000a                }\u000a            }\u000a\u000a            return res;\u000a        }\u000a\u000a        function getOrCreateAxis(axes, number) {\u000a            if (!axes[number - 1])\u000a                axes[number - 1] = {\u000a                    n: number, // save the number for future reference\u000a                    direction: axes == xaxes ? "x" : "y",\u000a                    options: $.extend(true, {}, axes == xaxes ? options.xaxis : options.yaxis)\u000a                };\u000a\u000a            return axes[number - 1];\u000a        }\u000a\u000a        function fillInSeriesOptions() {\u000a\u000a            var neededColors = series.length, maxIndex = -1, i;\u000a\u000a            // Subtract the number of series that already have fixed colors or\u000a            // color indexes from the number that we still need to generate.\u000a\u000a            for (i = 0; i < series.length; ++i) {\u000a                var sc = series[i].color;\u000a                if (sc != null) {\u000a                    neededColors--;\u000a                    if (typeof sc == "number" && sc > maxIndex) {\u000a                        maxIndex = sc;\u000a                    }\u000a                }\u000a            }\u000a\u000a            // If any of the series have fixed color indexes, then we need to\u000a            // generate at least as many colors as the highest index.\u000a\u000a            if (neededColors <= maxIndex) {\u000a                neededColors = maxIndex + 1;\u000a            }\u000a\u000a            // Generate all the colors, using first the option colors and then\u000a            // variations on those colors once they're exhausted.\u000a\u000a            var c, colors = [], colorPool = options.colors,\u000a                colorPoolSize = colorPool.length, variation = 0;\u000a\u000a            for (i = 0; i < neededColors; i++) {\u000a\u000a                c = $.color.parse(colorPool[i % colorPoolSize] || "#666");\u000a\u000a                // Each time we exhaust the colors in the pool we adjust\u000a                // a scaling factor used to produce more variations on\u000a                // those colors. The factor alternates negative/positive\u000a                // to produce lighter/darker colors.\u000a\u000a                // Reset the variation after every few cycles, or else\u000a                // it will end up producing only white or black colors.\u000a\u000a                if (i % colorPoolSize == 0 && i) {\u000a                    if (variation >= 0) {\u000a                        if (variation < 0.5) {\u000a                            variation = -variation - 0.2;\u000a                        } else variation = 0;\u000a                    } else variation = -variation;\u000a                }\u000a\u000a                colors[i] = c.scale('rgb', 1 + variation);\u000a            }\u000a\u000a            // Finalize the series options, filling in their colors\u000a\u000a            var colori = 0, s;\u000a            for (i = 0; i < series.length; ++i) {\u000a                s = series[i];\u000a\u000a                // assign colors\u000a                if (s.color == null) {\u000a                    s.color = colors[colori].toString();\u000a                    ++colori;\u000a                }\u000a                else if (typeof s.color == "number")\u000a                    s.color = colors[s.color].toString();\u000a\u000a                // turn on lines automatically in case nothing is set\u000a                if (s.lines.show == null) {\u000a                    var v, show = true;\u000a                    for (v in s)\u000a                        if (s[v] && s[v].show) {\u000a                            show = false;\u000a                            break;\u000a                        }\u000a                    if (show)\u000a                        s.lines.show = true;\u000a                }\u000a\u000a                // If nothing was provided for lines.zero, default it to match\u000a                // lines.fill, since areas by default should extend to zero.\u000a\u000a                if (s.lines.zero == null) {\u000a                    s.lines.zero = !!s.lines.fill;\u000a                }\u000a\u000a                // setup axes\u000a                s.xaxis = getOrCreateAxis(xaxes, axisNumber(s, "x"));\u000a                s.yaxis = getOrCreateAxis(yaxes, axisNumber(s, "y"));\u000a            }\u000a        }\u000a\u000a        function processData() {\u000a            var topSentry = Number.POSITIVE_INFINITY,\u000a                bottomSentry = Number.NEGATIVE_INFINITY,\u000a                fakeInfinity = Number.MAX_VALUE,\u000a                i, j, k, m, length,\u000a                s, points, ps, x, y, axis, val, f, p,\u000a                data, format;\u000a\u000a            function updateAxis(axis, min, max) {\u000a                if (min < axis.datamin && min != -fakeInfinity)\u000a                    axis.datamin = min;\u000a                if (max > axis.datamax && max != fakeInfinity)\u000a                    axis.datamax = max;\u000a            }\u000a\u000a            $.each(allAxes(), function (_, axis) {\u000a                // init axis\u000a                axis.datamin = topSentry;\u000a                axis.datamax = bottomSentry;\u000a                axis.used = false;\u000a            });\u000a\u000a            for (i = 0; i < series.length; ++i) {\u000a                s = series[i];\u000a                s.datapoints = { points: [] };\u000a\u000a                executeHooks(hooks.processRawData, [ s, s.data, s.datapoints ]);\u000a            }\u000a\u000a            // first pass: clean and copy data\u000a            for (i = 0; i < series.length; ++i) {\u000a                s = series[i];\u000a\u000a                data = s.data;\u000a                format = s.datapoints.format;\u000a\u000a                if (!format) {\u000a                    format = [];\u000a                    // find out how to copy\u000a                    format.push({ x: true, number: true, required: true });\u000a                    format.push({ y: true, number: true, required: true });\u000a\u000a                    if (s.bars.show || (s.lines.show && s.lines.fill)) {\u000a                        var autoscale = !!((s.bars.show && s.bars.zero) || (s.lines.show && s.lines.zero));\u000a                        format.push({ y: true, number: true, required: false, defaultValue: 0, autoscale: autoscale });\u000a                        if (s.bars.horizontal) {\u000a                            delete format[format.length - 1].y;\u000a                            format[format.length - 1].x = true;\u000a                        }\u000a                    }\u000a\u000a                    s.datapoints.format = format;\u000a                }\u000a\u000a                if (s.datapoints.pointsize != null)\u000a                    continue; // already filled in\u000a\u000a                s.datapoints.pointsize = format.length;\u000a\u000a                ps = s.datapoints.pointsize;\u000a                points = s.datapoints.points;\u000a\u000a                var insertSteps = s.lines.show && s.lines.steps;\u000a                s.xaxis.used = s.yaxis.used = true;\u000a\u000a                for (j = k = 0; j < data.length; ++j, k += ps) {\u000a                    p = data[j];\u000a\u000a                    var nullify = p == null;\u000a                    if (!nullify) {\u000a                        for (m = 0; m < ps; ++m) {\u000a                            val = p[m];\u000a                            f = format[m];\u000a\u000a                            if (f) {\u000a                                if (f.number && val != null) {\u000a                                    val = +val; // convert to number\u000a                                    if (isNaN(val))\u000a                                        val = null;\u000a                                    else if (val == Infinity)\u000a                                        val = fakeInfinity;\u000a                                    else if (val == -Infinity)\u000a                                        val = -fakeInfinity;\u000a                                }\u000a\u000a                                if (val == null) {\u000a                                    if (f.required)\u000a                                        nullify = true;\u000a\u000a                                    if (f.defaultValue != null)\u000a                                        val = f.defaultValue;\u000a                                }\u000a                            }\u000a\u000a                            points[k + m] = val;\u000a                        }\u000a                    }\u000a\u000a                    if (nullify) {\u000a                        for (m = 0; m < ps; ++m) {\u000a                            val = points[k + m];\u000a                            if (val != null) {\u000a                                f = format[m];\u000a                                // extract min/max info\u000a                                if (f.autoscale !== false) {\u000a                                    if (f.x) {\u000a                                        updateAxis(s.xaxis, val, val);\u000a                                    }\u000a                                    if (f.y) {\u000a                                        updateAxis(s.yaxis, val, val);\u000a                                    }\u000a                                }\u000a                            }\u000a                            points[k + m] = null;\u000a                        }\u000a                    }\u000a                    else {\u000a                        // a little bit of line specific stuff that\u000a                        // perhaps shouldn't be here, but lacking\u000a                        // better means...\u000a                        if (insertSteps && k > 0\u000a                            && points[k - ps] != null\u000a                            && points[k - ps] != points[k]\u000a                            && points[k - ps + 1] != points[k + 1]) {\u000a                            // copy the point to make room for a middle point\u000a                            for (m = 0; m < ps; ++m)\u000a                                points[k + ps + m] = points[k + m];\u000a\u000a                            // middle point has same y\u000a                            points[k + 1] = points[k - ps + 1];\u000a\u000a                            // we've added a point, better reflect that\u000a                            k += ps;\u000a                        }\u000a                    }\u000a                }\u000a            }\u000a\u000a            // give the hooks a chance to run\u000a            for (i = 0; i < series.length; ++i) {\u000a                s = series[i];\u000a\u000a                executeHooks(hooks.processDatapoints, [ s, s.datapoints]);\u000a            }\u000a\u000a            // second pass: find datamax/datamin for auto-scaling\u000a            for (i = 0; i < series.length; ++i) {\u000a                s = series[i];\u000a                points = s.datapoints.points;\u000a                ps = s.datapoints.pointsize;\u000a                format = s.datapoints.format;\u000a\u000a                var xmin = topSentry, ymin = topSentry,\u000a                    xmax = bottomSentry, ymax = bottomSentry;\u000a\u000a                for (j = 0; j < points.length; j += ps) {\u000a                    if (points[j] == null)\u000a                        continue;\u000a\u000a                    for (m = 0; m < ps; ++m) {\u000a                        val = points[j + m];\u000a                        f = format[m];\u000a                        if (!f || f.autoscale === false || val == fakeInfinity || val == -fakeInfinity)\u000a                            continue;\u000a\u000a                        if (f.x) {\u000a                            if (val < xmin)\u000a                                xmin = val;\u000a                            if (val > xmax)\u000a                                xmax = val;\u000a                        }\u000a                        if (f.y) {\u000a                            if (val < ymin)\u000a                                ymin = val;\u000a                            if (val > ymax)\u000a                                ymax = val;\u000a                        }\u000a                    }\u000a                }\u000a\u000a                if (s.bars.show) {\u000a                    // make sure we got room for the bar on the dancing floor\u000a                    var delta;\u000a\u000a                    switch (s.bars.align) {\u000a                        case "left":\u000a                            delta = 0;\u000a                            break;\u000a                        case "right":\u000a                            delta = -s.bars.barWidth;\u000a                            break;\u000a                        default:\u000a                            delta = -s.bars.barWidth / 2;\u000a                    }\u000a\u000a                    if (s.bars.horizontal) {\u000a                        ymin += delta;\u000a                        ymax += delta + s.bars.barWidth;\u000a                    }\u000a                    else {\u000a                        xmin += delta;\u000a                        xmax += delta + s.bars.barWidth;\u000a                    }\u000a                }\u000a\u000a                updateAxis(s.xaxis, xmin, xmax);\u000a                updateAxis(s.yaxis, ymin, ymax);\u000a            }\u000a\u000a            $.each(allAxes(), function (_, axis) {\u000a                if (axis.datamin == topSentry)\u000a                    axis.datamin = null;\u000a                if (axis.datamax == bottomSentry)\u000a                    axis.datamax = null;\u000a            });\u000a        }\u000a\u000a        function setupCanvases() {\u000a\u000a            // Make sure the placeholder is clear of everything except canvases\u000a            // from a previous plot in this container that we'll try to re-use.\u000a\u000a            placeholder.css("padding", 0) // padding messes up the positioning\u000a                .children().filter(function(){\u000a                    return !$(this).hasClass("flot-overlay") && !$(this).hasClass('flot-base');\u000a                }).remove();\u000a\u000a            if (placeholder.css("position") == 'static')\u000a                placeholder.css("position", "relative"); // for positioning labels and overlay\u000a\u000a            surface = new Canvas("flot-base", placeholder);\u000a            overlay = new Canvas("flot-overlay", placeholder); // overlay canvas for interactive features\u000a\u000a            ctx = surface.context;\u000a            octx = overlay.context;\u000a\u000a            // define which element we're listening for events on\u000a            eventHolder = $(overlay.element).unbind();\u000a\u000a            // If we're re-using a plot object, shut down the old one\u000a\u000a            var existing = placeholder.data("plot");\u000a\u000a            if (existing) {\u000a                existing.shutdown();\u000a                overlay.clear();\u000a            }\u000a\u000a            // save in case we get replotted\u000a            placeholder.data("plot", plot);\u000a        }\u000a\u000a        function bindEvents() {\u000a            // bind events\u000a            if (options.grid.hoverable) {\u000a                eventHolder.mousemove(onMouseMove);\u000a\u000a                // Use bind, rather than .mouseleave, because we officially\u000a                // still support jQuery 1.2.6, which doesn't define a shortcut\u000a                // for mouseenter or mouseleave.  This was a bug/oversight that\u000a                // was fixed somewhere around 1.3.x.  We can return to using\u000a                // .mouseleave when we drop support for 1.2.6.\u000a\u000a                eventHolder.bind("mouseleave", onMouseLeave);\u000a            }\u000a\u000a            if (options.grid.clickable)\u000a                eventHolder.click(onClick);\u000a\u000a            executeHooks(hooks.bindEvents, [eventHolder]);\u000a        }\u000a\u000a        function shutdown() {\u000a            if (redrawTimeout)\u000a                clearTimeout(redrawTimeout);\u000a\u000a            eventHolder.unbind("mousemove", onMouseMove);\u000a            eventHolder.unbind("mouseleave", onMouseLeave);\u000a            eventHolder.unbind("click", onClick);\u000a\u000a            executeHooks(hooks.shutdown, [eventHolder]);\u000a        }\u000a\u000a        function setTransformationHelpers(axis) {\u000a            // set helper functions on the axis, assumes plot area\u000a            // has been computed already\u000a\u000a            function identity(x) { return x; }\u000a\u000a            var s, m, t = axis.options.transform || identity,\u000a                it = axis.options.inverseTransform;\u000a\u000a            // precompute how much the axis is scaling a point\u000a            // in canvas space\u000a            if (axis.direction == "x") {\u000a                s = axis.scale = plotWidth / Math.abs(t(axis.max) - t(axis.min));\u000a                m = Math.min(t(axis.max), t(axis.min));\u000a            }\u000a            else {\u000a                s = axis.scale = plotHeight / Math.abs(t(axis.max) - t(axis.min));\u000a                s = -s;\u000a                m = Math.max(t(axis.max), t(axis.min));\u000a            }\u000a\u000a            // data point to canvas coordinate\u000a            if (t == identity) // slight optimization\u000a                axis.p2c = function (p) { return (p - m) * s; };\u000a            else\u000a                axis.p2c = function (p) { return (t(p) - m) * s; };\u000a            // canvas coordinate to data point\u000a            if (!it)\u000a                axis.c2p = function (c) { return m + c / s; };\u000a            else\u000a                axis.c2p = function (c) { return it(m + c / s); };\u000a        }\u000a\u000a        function measureTickLabels(axis) {\u000a\u000a            var opts = axis.options,\u000a                ticks = axis.ticks || [],\u000a                labelWidth = opts.labelWidth || 0,\u000a                labelHeight = opts.labelHeight || 0,\u000a                maxWidth = labelWidth || (axis.direction == "x" ? Math.floor(surface.width / (ticks.length || 1)) : null),\u000a                legacyStyles = axis.direction + "Axis " + axis.direction + axis.n + "Axis",\u000a                layer = "flot-" + axis.direction + "-axis flot-" + axis.direction + axis.n + "-axis " + legacyStyles,\u000a                font = opts.font || "flot-tick-label tickLabel";\u000a\u000a            for (var i = 0; i < ticks.length; ++i) {\u000a\u000a                var t = ticks[i];\u000a\u000a                if (!t.label)\u000a                    continue;\u000a\u000a                var info = surface.getTextInfo(layer, t.label, font, null, maxWidth);\u000a\u000a                labelWidth = Math.max(labelWidth, info.width);\u000a                labelHeight = Math.max(labelHeight, info.height);\u000a            }\u000a\u000a            axis.labelWidth = opts.labelWidth || labelWidth;\u000a            axis.labelHeight = opts.labelHeight || labelHeight;\u000a        }\u000a\u000a        function allocateAxisBoxFirstPhase(axis) {\u000a            // find the bounding box of the axis by looking at label\u000a            // widths/heights and ticks, make room by diminishing the\u000a            // plotOffset; this first phase only looks at one\u000a            // dimension per axis, the other dimension depends on the\u000a            // other axes so will have to wait\u000a\u000a            var lw = axis.labelWidth,\u000a                lh = axis.labelHeight,\u000a                pos = axis.options.position,\u000a                isXAxis = axis.direction === "x",\u000a                tickLength = axis.options.tickLength,\u000a                axisMargin = options.grid.axisMargin,\u000a                padding = options.grid.labelMargin,\u000a                innermost = true,\u000a                outermost = true,\u000a                first = true,\u000a                found = false;\u000a\u000a            // Determine the axis's position in its direction and on its side\u000a\u000a            $.each(isXAxis ? xaxes : yaxes, function(i, a) {\u000a                if (a && (a.show || a.reserveSpace)) {\u000a                    if (a === axis) {\u000a                        found = true;\u000a                    } else if (a.options.position === pos) {\u000a                        if (found) {\u000a                            outermost = false;\u000a                        } else {\u000a                            innermost = false;\u000a                        }\u000a                    }\u000a                    if (!found) {\u000a                        first = false;\u000a                    }\u000a                }\u000a            });\u000a\u000a            // The outermost axis on each side has no margin\u000a\u000a            if (outermost) {\u000a                axisMargin = 0;\u000a            }\u000a\u000a            // The ticks for the first axis in each direction stretch across\u000a\u000a            if (tickLength == null) {\u000a                tickLength = first ? "full" : 5;\u000a            }\u000a\u000a            if (!isNaN(+tickLength))\u000a                padding += +tickLength;\u000a\u000a            if (isXAxis) {\u000a                lh += padding;\u000a\u000a                if (pos == "bottom") {\u000a                    plotOffset.bottom += lh + axisMargin;\u000a                    axis.box = { top: surface.height - plotOffset.bottom, height: lh };\u000a                }\u000a                else {\u000a                    axis.box = { top: plotOffset.top + axisMargin, height: lh };\u000a                    plotOffset.top += lh + axisMargin;\u000a                }\u000a            }\u000a            else {\u000a                lw += padding;\u000a\u000a                if (pos == "left") {\u000a                    axis.box = { left: plotOffset.left + axisMargin, width: lw };\u000a                    plotOffset.left += lw + axisMargin;\u000a                }\u000a                else {\u000a                    plotOffset.right += lw + axisMargin;\u000a                    axis.box = { left: surface.width - plotOffset.right, width: lw };\u000a                }\u000a            }\u000a\u000a             // save for future reference\u000a            axis.position = pos;\u000a            axis.tickLength = tickLength;\u000a            axis.box.padding = padding;\u000a            axis.innermost = innermost;\u000a        }\u000a\u000a        function allocateAxisBoxSecondPhase(axis) {\u000a            // now that all axis boxes have been placed in one\u000a            // dimension, we can set the remaining dimension coordinates\u000a            if (axis.direction == "x") {\u000a                axis.box.left = plotOffset.left - axis.labelWidth / 2;\u000a                axis.box.width = surface.width - plotOffset.left - plotOffset.right + axis.labelWidth;\u000a            }\u000a            else {\u000a                axis.box.top = plotOffset.top - axis.labelHeight / 2;\u000a                axis.box.height = surface.height - plotOffset.bottom - plotOffset.top + axis.labelHeight;\u000a            }\u000a        }\u000a\u000a        function adjustLayoutForThingsStickingOut() {\u000a            // possibly adjust plot offset to ensure everything stays\u000a            // inside the canvas and isn't clipped off\u000a\u000a            var minMargin = options.grid.minBorderMargin,\u000a                axis, i;\u000a\u000a            // check stuff from the plot (FIXME: this should just read\u000a            // a value from the series, otherwise it's impossible to\u000a            // customize)\u000a            if (minMargin == null) {\u000a                minMargin = 0;\u000a                for (i = 0; i < series.length; ++i)\u000a                    minMargin = Math.max(minMargin, 2 * (series[i].points.radius + series[i].points.lineWidth/2));\u000a            }\u000a\u000a            var margins = {\u000a                left: minMargin,\u000a                right: minMargin,\u000a                top: minMargin,\u000a                bottom: minMargin\u000a            };\u000a\u000a            // check axis labels, note we don't check the actual\u000a            // labels but instead use the overall width/height to not\u000a            // jump as much around with replots\u000a            $.each(allAxes(), function (_, axis) {\u000a                if (axis.reserveSpace && axis.ticks && axis.ticks.length) {\u000a                    if (axis.direction === "x") {\u000a                        margins.left = Math.max(margins.left, axis.labelWidth / 2);\u000a                        margins.right = Math.max(margins.right, axis.labelWidth / 2);\u000a                    } else {\u000a                        margins.bottom = Math.max(margins.bottom, axis.labelHeight / 2);\u000a                        margins.top = Math.max(margins.top, axis.labelHeight / 2);\u000a                    }\u000a                }\u000a            });\u000a\u000a            plotOffset.left = Math.ceil(Math.max(margins.left, plotOffset.left));\u000a            plotOffset.right = Math.ceil(Math.max(margins.right, plotOffset.right));\u000a            plotOffset.top = Math.ceil(Math.max(margins.top, plotOffset.top));\u000a            plotOffset.bottom = Math.ceil(Math.max(margins.bottom, plotOffset.bottom));\u000a        }\u000a\u000a        function setupGrid() {\u000a            var i, axes = allAxes(), showGrid = options.grid.show;\u000a\u000a            // Initialize the plot's offset from the edge of the canvas\u000a\u000a            for (var a in plotOffset) {\u000a                var margin = options.grid.margin || 0;\u000a                plotOffset[a] = typeof margin == "number" ? margin : margin[a] || 0;\u000a            }\u000a\u000a            executeHooks(hooks.processOffset, [plotOffset]);\u000a\u000a            // If the grid is visible, add its border width to the offset\u000a\u000a            for (var a in plotOffset) {\u000a                if(typeof(options.grid.borderWidth) == "object") {\u000a                    plotOffset[a] += showGrid ? options.grid.borderWidth[a] : 0;\u000a                }\u000a                else {\u000a                    plotOffset[a] += showGrid ? options.grid.borderWidth : 0;\u000a                }\u000a            }\u000a\u000a            $.each(axes, function (_, axis) {\u000a                var axisOpts = axis.options;\u000a                axis.show = axisOpts.show == null ? axis.used : axisOpts.show;\u000a                axis.reserveSpace = axisOpts.reserveSpace == null ? axis.show : axisOpts.reserveSpace;\u000a                setRange(axis);\u000a            });\u000a\u000a            if (showGrid) {\u000a\u000a                var allocatedAxes = $.grep(axes, function (axis) {\u000a                    return axis.show || axis.reserveSpace;\u000a                });\u000a\u000a                $.each(allocatedAxes, function (_, axis) {\u000a                    // make the ticks\u000a                    setupTickGeneration(axis);\u000a                    setTicks(axis);\u000a                    snapRangeToTicks(axis, axis.ticks);\u000a                    // find labelWidth/Height for axis\u000a                    measureTickLabels(axis);\u000a                });\u000a\u000a                // with all dimensions calculated, we can compute the\u000a                // axis bounding boxes, start from the outside\u000a                // (reverse order)\u000a                for (i = allocatedAxes.length - 1; i >= 0; --i)\u000a                    allocateAxisBoxFirstPhase(allocatedAxes[i]);\u000a\u000a                // make sure we've got enough space for things that\u000a                // might stick out\u000a                adjustLayoutForThingsStickingOut();\u000a\u000a                $.each(allocatedAxes, function (_, axis) {\u000a                    allocateAxisBoxSecondPhase(axis);\u000a                });\u000a            }\u000a\u000a            plotWidth = surface.width - plotOffset.left - plotOffset.right;\u000a            plotHeight = surface.height - plotOffset.bottom - plotOffset.top;\u000a\u000a            // now we got the proper plot dimensions, we can compute the scaling\u000a            $.each(axes, function (_, axis) {\u000a                setTransformationHelpers(axis);\u000a            });\u000a\u000a            if (showGrid) {\u000a                drawAxisLabels();\u000a            }\u000a\u000a            insertLegend();\u000a        }\u000a\u000a        function setRange(axis) {\u000a            var opts = axis.options,\u000a                min = +(opts.min != null ? opts.min : axis.datamin),\u000a                max = +(opts.max != null ? opts.max : axis.datamax),\u000a                delta = max - min;\u000a\u000a            if (delta == 0.0) {\u000a                // degenerate case\u000a                var widen = max == 0 ? 1 : 0.01;\u000a\u000a                if (opts.min == null)\u000a                    min -= widen;\u000a                // always widen max if we couldn't widen min to ensure we\u000a                // don't fall into min == max which doesn't work\u000a                if (opts.max == null || opts.min != null)\u000a                    max += widen;\u000a            }\u000a            else {\u000a                // consider autoscaling\u000a                var margin = opts.autoscaleMargin;\u000a                if (margin != null) {\u000a                    if (opts.min == null) {\u000a                        min -= delta * margin;\u000a                        // make sure we don't go below zero if all values\u000a                        // are positive\u000a                        if (min < 0 && axis.datamin != null && axis.datamin >= 0)\u000a                            min = 0;\u000a                    }\u000a                    if (opts.max == null) {\u000a                        max += delta * margin;\u000a                        if (max > 0 && axis.datamax != null && axis.datamax <= 0)\u000a                            max = 0;\u000a                    }\u000a                }\u000a            }\u000a            axis.min = min;\u000a            axis.max = max;\u000a        }\u000a\u000a        function setupTickGeneration(axis) {\u000a            var opts = axis.options;\u000a\u000a            // estimate number of ticks\u000a            var noTicks;\u000a            if (typeof opts.ticks == "number" && opts.ticks > 0)\u000a                noTicks = opts.ticks;\u000a            else\u000a                // heuristic based on the model a*sqrt(x) fitted to\u000a                // some data points that seemed reasonable\u000a                noTicks = 0.3 * Math.sqrt(axis.direction == "x" ? surface.width : surface.height);\u000a\u000a            var delta = (axis.max - axis.min) / noTicks,\u000a                dec = -Math.floor(Math.log(delta) / Math.LN10),\u000a                maxDec = opts.tickDecimals;\u000a\u000a            if (maxDec != null && dec > maxDec) {\u000a                dec = maxDec;\u000a            }\u000a\u000a            var magn = Math.pow(10, -dec),\u000a                norm = delta / magn, // norm is between 1.0 and 10.0\u000a                size;\u000a\u000a            if (norm < 1.5) {\u000a                size = 1;\u000a            } else if (norm < 3) {\u000a                size = 2;\u000a                // special case for 2.5, requires an extra decimal\u000a                if (norm > 2.25 && (maxDec == null || dec + 1 <= maxDec)) {\u000a                    size = 2.5;\u000a                    ++dec;\u000a                }\u000a            } else if (norm < 7.5) {\u000a                size = 5;\u000a            } else {\u000a                size = 10;\u000a            }\u000a\u000a            size *= magn;\u000a\u000a            if (opts.minTickSize != null && size < opts.minTickSize) {\u000a                size = opts.minTickSize;\u000a            }\u000a\u000a            axis.delta = delta;\u000a            axis.tickDecimals = Math.max(0, maxDec != null ? maxDec : dec);\u000a            axis.tickSize = opts.tickSize || size;\u000a\u000a            // Time mode was moved to a plug-in in 0.8, and since so many people use it\u000a            // we'll add an especially friendly reminder to make sure they included it.\u000a\u000a            if (opts.mode == "time" && !axis.tickGenerator) {\u000a                throw new Error("Time mode requires the flot.time plugin.");\u000a            }\u000a\u000a            // Flot supports base-10 axes; any other mode else is handled by a plug-in,\u000a            // like flot.time.js.\u000a\u000a            if (!axis.tickGenerator) {\u000a\u000a                axis.tickGenerator = function (axis) {\u000a\u000a                    var ticks = [],\u000a                        start = floorInBase(axis.min, axis.tickSize),\u000a                        i = 0,\u000a                        v = Number.NaN,\u000a                        prev;\u000a\u000a                    do {\u000a                        prev = v;\u000a                        v = start + i * axis.tickSize;\u000a                        ticks.push(v);\u000a                        ++i;\u000a                    } while (v < axis.max && v != prev);\u000a                    return ticks;\u000a                };\u000a\u000a				axis.tickFormatter = function (value, axis) {\u000a\u000a					var factor = axis.tickDecimals ? Math.pow(10, axis.tickDecimals) : 1;\u000a					var formatted = "" + Math.round(value * factor) / factor;\u000a\u000a					// If tickDecimals was specified, ensure that we have exactly that\u000a					// much precision; otherwise default to the value's own precision.\u000a\u000a					if (axis.tickDecimals != null) {\u000a						var decimal = formatted.indexOf(".");\u000a						var precision = decimal == -1 ? 0 : formatted.length - decimal - 1;\u000a						if (precision < axis.tickDecimals) {\u000a							return (precision ? formatted : formatted + ".") + ("" + factor).substr(1, axis.tickDecimals - precision);\u000a						}\u000a					}\u000a\u000a                    return formatted;\u000a                };\u000a            }\u000a\u000a            if ($.isFunction(opts.tickFormatter))\u000a                axis.tickFormatter = function (v, axis) { return "" + opts.tickFormatter(v, axis); };\u000a\u000a            if (opts.alignTicksWithAxis != null) {\u000a                var otherAxis = (axis.direction == "x" ? xaxes : yaxes)[opts.alignTicksWithAxis - 1];\u000a                if (otherAxis && otherAxis.used && otherAxis != axis) {\u000a                    // consider snapping min/max to outermost nice ticks\u000a                    var niceTicks = axis.tickGenerator(axis);\u000a                    if (niceTicks.length > 0) {\u000a                        if (opts.min == null)\u000a                            axis.min = Math.min(axis.min, niceTicks[0]);\u000a                        if (opts.max == null && niceTicks.length > 1)\u000a                            axis.max = Math.max(axis.max, niceTicks[niceTicks.length - 1]);\u000a                    }\u000a\u000a                    axis.tickGenerator = function (axis) {\u000a                        // copy ticks, scaled to this axis\u000a                        var ticks = [], v, i;\u000a                        for (i = 0; i < otherAxis.ticks.length; ++i) {\u000a                            v = (otherAxis.ticks[i].v - otherAxis.min) / (otherAxis.max - otherAxis.min);\u000a                            v = axis.min + v * (axis.max - axis.min);\u000a                            ticks.push(v);\u000a                        }\u000a                        return ticks;\u000a                    };\u000a\u000a                    // we might need an extra decimal since forced\u000a                    // ticks don't necessarily fit naturally\u000a                    if (!axis.mode && opts.tickDecimals == null) {\u000a                        var extraDec = Math.max(0, -Math.floor(Math.log(axis.delta) / Math.LN10) + 1),\u000a                            ts = axis.tickGenerator(axis);\u000a\u000a                        // only proceed if the tick interval rounded\u000a                        // with an extra decimal doesn't give us a\u000a                        // zero at end\u000a                        if (!(ts.length > 1 && /\u005c..*0$/.test((ts[1] - ts[0]).toFixed(extraDec))))\u000a                            axis.tickDecimals = extraDec;\u000a                    }\u000a                }\u000a            }\u000a        }\u000a\u000a        function setTicks(axis) {\u000a            var oticks = axis.options.ticks, ticks = [];\u000a            if (oticks == null || (typeof oticks == "number" && oticks > 0))\u000a                ticks = axis.tickGenerator(axis);\u000a            else if (oticks) {\u000a                if ($.isFunction(oticks))\u000a                    // generate the ticks\u000a                    ticks = oticks(axis);\u000a                else\u000a                    ticks = oticks;\u000a            }\u000a\u000a            // clean up/labelify the supplied ticks, copy them over\u000a            var i, v;\u000a            axis.ticks = [];\u000a            for (i = 0; i < ticks.length; ++i) {\u000a                var label = null;\u000a                var t = ticks[i];\u000a                if (typeof t == "object") {\u000a                    v = +t[0];\u000a                    if (t.length > 1)\u000a                        label = t[1];\u000a                }\u000a                else\u000a                    v = +t;\u000a                if (label == null)\u000a                    label = axis.tickFormatter(v, axis);\u000a                if (!isNaN(v))\u000a                    axis.ticks.push({ v: v, label: label });\u000a            }\u000a        }\u000a\u000a        function snapRangeToTicks(axis, ticks) {\u000a            if (axis.options.autoscaleMargin && ticks.length > 0) {\u000a                // snap to ticks\u000a                if (axis.options.min == null)\u000a                    axis.min = Math.min(axis.min, ticks[0].v);\u000a                if (axis.options.max == null && ticks.length > 1)\u000a                    axis.max = Math.max(axis.max, ticks[ticks.length - 1].v);\u000a            }\u000a        }\u000a\u000a        function draw() {\u000a\u000a            surface.clear();\u000a\u000a            executeHooks(hooks.drawBackground, [ctx]);\u000a\u000a            var grid = options.grid;\u000a\u000a            // draw background, if any\u000a            if (grid.show && grid.backgroundColor)\u000a                drawBackground();\u000a\u000a            if (grid.show && !grid.aboveData) {\u000a                drawGrid();\u000a            }\u000a\u000a            for (var i = 0; i < series.length; ++i) {\u000a                executeHooks(hooks.drawSeries, [ctx, series[i]]);\u000a                drawSeries(series[i]);\u000a            }\u000a\u000a            executeHooks(hooks.draw, [ctx]);\u000a\u000a            if (grid.show && grid.aboveData) {\u000a                drawGrid();\u000a            }\u000a\u000a            surface.render();\u000a\u000a            // A draw implies that either the axes or data have changed, so we\u000a            // should probably update the overlay highlights as well.\u000a\u000a            triggerRedrawOverlay();\u000a        }\u000a\u000a        function extractRange(ranges, coord) {\u000a            var axis, from, to, key, axes = allAxes();\u000a\u000a            for (var i = 0; i < axes.length; ++i) {\u000a                axis = axes[i];\u000a                if (axis.direction == coord) {\u000a                    key = coord + axis.n + "axis";\u000a                    if (!ranges[key] && axis.n == 1)\u000a                        key = coord + "axis"; // support x1axis as xaxis\u000a                    if (ranges[key]) {\u000a                        from = ranges[key].from;\u000a                        to = ranges[key].to;\u000a                        break;\u000a                    }\u000a                }\u000a            }\u000a\u000a            // backwards-compat stuff - to be removed in future\u000a            if (!ranges[key]) {\u000a                axis = coord == "x" ? xaxes[0] : yaxes[0];\u000a                from = ranges[coord + "1"];\u000a                to = ranges[coord + "2"];\u000a            }\u000a\u000a            // auto-reverse as an added bonus\u000a            if (from != null && to != null && from > to) {\u000a                var tmp = from;\u000a                from = to;\u000a                to = tmp;\u000a            }\u000a\u000a            return { from: from, to: to, axis: axis };\u000a        }\u000a\u000a        function drawBackground() {\u000a            ctx.save();\u000a            ctx.translate(plotOffset.left, plotOffset.top);\u000a\u000a            ctx.fillStyle = getColorOrGradient(options.grid.backgroundColor, plotHeight, 0, "rgba(255, 255, 255, 0)");\u000a            ctx.fillRect(0, 0, plotWidth, plotHeight);\u000a            ctx.restore();\u000a        }\u000a\u000a        function drawGrid() {\u000a            var i, axes, bw, bc;\u000a\u000a            ctx.save();\u000a            ctx.translate(plotOffset.left, plotOffset.top);\u000a\u000a            // draw markings\u000a            var markings = options.grid.markings;\u000a            if (markings) {\u000a                if ($.isFunction(markings)) {\u000a                    axes = plot.getAxes();\u000a                    // xmin etc. is backwards compatibility, to be\u000a                    // removed in the future\u000a                    axes.xmin = axes.xaxis.min;\u000a                    axes.xmax = axes.xaxis.max;\u000a                    axes.ymin = axes.yaxis.min;\u000a                    axes.ymax = axes.yaxis.max;\u000a\u000a                    markings = markings(axes);\u000a                }\u000a\u000a                for (i = 0; i < markings.length; ++i) {\u000a                    var m = markings[i],\u000a                        xrange = extractRange(m, "x"),\u000a                        yrange = extractRange(m, "y");\u000a\u000a                    // fill in missing\u000a                    if (xrange.from == null)\u000a                        xrange.from = xrange.axis.min;\u000a                    if (xrange.to == null)\u000a                        xrange.to = xrange.axis.max;\u000a                    if (yrange.from == null)\u000a                        yrange.from = yrange.axis.min;\u000a                    if (yrange.to == null)\u000a                        yrange.to = yrange.axis.max;\u000a\u000a                    // clip\u000a                    if (xrange.to < xrange.axis.min || xrange.from > xrange.axis.max ||\u000a                        yrange.to < yrange.axis.min || yrange.from > yrange.axis.max)\u000a                        continue;\u000a\u000a                    xrange.from = Math.max(xrange.from, xrange.axis.min);\u000a                    xrange.to = Math.min(xrange.to, xrange.axis.max);\u000a                    yrange.from = Math.max(yrange.from, yrange.axis.min);\u000a                    yrange.to = Math.min(yrange.to, yrange.axis.max);\u000a\u000a                    var xequal = xrange.from === xrange.to,\u000a                        yequal = yrange.from === yrange.to;\u000a\u000a                    if (xequal && yequal) {\u000a                        continue;\u000a                    }\u000a\u000a                    // then draw\u000a                    xrange.from = Math.floor(xrange.axis.p2c(xrange.from));\u000a                    xrange.to = Math.floor(xrange.axis.p2c(xrange.to));\u000a                    yrange.from = Math.floor(yrange.axis.p2c(yrange.from));\u000a                    yrange.to = Math.floor(yrange.axis.p2c(yrange.to));\u000a\u000a                    if (xequal || yequal) {\u000a                        var lineWidth = m.lineWidth || options.grid.markingsLineWidth,\u000a                            subPixel = lineWidth % 2 ? 0.5 : 0;\u000a                        ctx.beginPath();\u000a                        ctx.strokeStyle = m.color || options.grid.markingsColor;\u000a                        ctx.lineWidth = lineWidth;\u000a                        if (xequal) {\u000a                            ctx.moveTo(xrange.to + subPixel, yrange.from);\u000a                            ctx.lineTo(xrange.to + subPixel, yrange.to);\u000a                        } else {\u000a                            ctx.moveTo(xrange.from, yrange.to + subPixel);\u000a                            ctx.lineTo(xrange.to, yrange.to + subPixel);                            \u000a                        }\u000a                        ctx.stroke();\u000a                    } else {\u000a                        ctx.fillStyle = m.color || options.grid.markingsColor;\u000a                        ctx.fillRect(xrange.from, yrange.to,\u000a                                     xrange.to - xrange.from,\u000a                                     yrange.from - yrange.to);\u000a                    }\u000a                }\u000a            }\u000a\u000a            // draw the ticks\u000a            axes = allAxes();\u000a            bw = options.grid.borderWidth;\u000a\u000a            for (var j = 0; j < axes.length; ++j) {\u000a                var axis = axes[j], box = axis.box,\u000a                    t = axis.tickLength, x, y, xoff, yoff;\u000a                if (!axis.show || axis.ticks.length == 0)\u000a                    continue;\u000a\u000a                ctx.lineWidth = 1;\u000a\u000a                // find the edges\u000a                if (axis.direction == "x") {\u000a                    x = 0;\u000a                    if (t == "full")\u000a                        y = (axis.position == "top" ? 0 : plotHeight);\u000a                    else\u000a                        y = box.top - plotOffset.top + (axis.position == "top" ? box.height : 0);\u000a                }\u000a                else {\u000a                    y = 0;\u000a                    if (t == "full")\u000a                        x = (axis.position == "left" ? 0 : plotWidth);\u000a                    else\u000a                        x = box.left - plotOffset.left + (axis.position == "left" ? box.width : 0);\u000a                }\u000a\u000a                // draw tick bar\u000a                if (!axis.innermost) {\u000a                    ctx.strokeStyle = axis.options.color;\u000a                    ctx.beginPath();\u000a                    xoff = yoff = 0;\u000a                    if (axis.direction == "x")\u000a                        xoff = plotWidth + 1;\u000a                    else\u000a                        yoff = plotHeight + 1;\u000a\u000a                    if (ctx.lineWidth == 1) {\u000a                        if (axis.direction == "x") {\u000a                            y = Math.floor(y) + 0.5;\u000a                        } else {\u000a                            x = Math.floor(x) + 0.5;\u000a                        }\u000a                    }\u000a\u000a                    ctx.moveTo(x, y);\u000a                    ctx.lineTo(x + xoff, y + yoff);\u000a                    ctx.stroke();\u000a                }\u000a\u000a                // draw ticks\u000a\u000a                ctx.strokeStyle = axis.options.tickColor;\u000a\u000a                ctx.beginPath();\u000a                for (i = 0; i < axis.ticks.length; ++i) {\u000a                    var v = axis.ticks[i].v;\u000a\u000a                    xoff = yoff = 0;\u000a\u000a                    if (isNaN(v) || v < axis.min || v > axis.max\u000a                        // skip those lying on the axes if we got a border\u000a                        || (t == "full"\u000a                            && ((typeof bw == "object" && bw[axis.position] > 0) || bw > 0)\u000a                            && (v == axis.min || v == axis.max)))\u000a                        continue;\u000a\u000a                    if (axis.direction == "x") {\u000a                        x = axis.p2c(v);\u000a                        yoff = t == "full" ? -plotHeight : t;\u000a\u000a                        if (axis.position == "top")\u000a                            yoff = -yoff;\u000a                    }\u000a                    else {\u000a                        y = axis.p2c(v);\u000a                        xoff = t == "full" ? -plotWidth : t;\u000a\u000a                        if (axis.position == "left")\u000a                            xoff = -xoff;\u000a                    }\u000a\u000a                    if (ctx.lineWidth == 1) {\u000a                        if (axis.direction == "x")\u000a                            x = Math.floor(x) + 0.5;\u000a                        else\u000a                            y = Math.floor(y) + 0.5;\u000a                    }\u000a\u000a                    ctx.moveTo(x, y);\u000a                    ctx.lineTo(x + xoff, y + yoff);\u000a                }\u000a\u000a                ctx.stroke();\u000a            }\u000a\u000a\u000a            // draw border\u000a            if (bw) {\u000a                // If either borderWidth or borderColor is an object, then draw the border\u000a                // line by line instead of as one rectangle\u000a                bc = options.grid.borderColor;\u000a                if(typeof bw == "object" || typeof bc == "object") {\u000a                    if (typeof bw !== "object") {\u000a                        bw = {top: bw, right: bw, bottom: bw, left: bw};\u000a                    }\u000a                    if (typeof bc !== "object") {\u000a                        bc = {top: bc, right: bc, bottom: bc, left: bc};\u000a                    }\u000a\u000a                    if (bw.top > 0) {\u000a                        ctx.strokeStyle = bc.top;\u000a                        ctx.lineWidth = bw.top;\u000a                        ctx.beginPath();\u000a                        ctx.moveTo(0 - bw.left, 0 - bw.top/2);\u000a                        ctx.lineTo(plotWidth, 0 - bw.top/2);\u000a                        ctx.stroke();\u000a                    }\u000a\u000a                    if (bw.right > 0) {\u000a                        ctx.strokeStyle = bc.right;\u000a                        ctx.lineWidth = bw.right;\u000a                        ctx.beginPath();\u000a                        ctx.moveTo(plotWidth + bw.right / 2, 0 - bw.top);\u000a                        ctx.lineTo(plotWidth + bw.right / 2, plotHeight);\u000a                        ctx.stroke();\u000a                    }\u000a\u000a                    if (bw.bottom > 0) {\u000a                        ctx.strokeStyle = bc.bottom;\u000a                        ctx.lineWidth = bw.bottom;\u000a                        ctx.beginPath();\u000a                        ctx.moveTo(plotWidth + bw.right, plotHeight + bw.bottom / 2);\u000a                        ctx.lineTo(0, plotHeight + bw.bottom / 2);\u000a                        ctx.stroke();\u000a                    }\u000a\u000a                    if (bw.left > 0) {\u000a                        ctx.strokeStyle = bc.left;\u000a                        ctx.lineWidth = bw.left;\u000a                        ctx.beginPath();\u000a                        ctx.moveTo(0 - bw.left/2, plotHeight + bw.bottom);\u000a                        ctx.lineTo(0- bw.left/2, 0);\u000a                        ctx.stroke();\u000a                    }\u000a                }\u000a                else {\u000a                    ctx.lineWidth = bw;\u000a                    ctx.strokeStyle = options.grid.borderColor;\u000a                    ctx.strokeRect(-bw/2, -bw/2, plotWidth + bw, plotHeight + bw);\u000a                }\u000a            }\u000a\u000a            ctx.restore();\u000a        }\u000a\u000a        function drawAxisLabels() {\u000a\u000a            $.each(allAxes(), function (_, axis) {\u000a                var box = axis.box,\u000a                    legacyStyles = axis.direction + "Axis " + axis.direction + axis.n + "Axis",\u000a                    layer = "flot-" + axis.direction + "-axis flot-" + axis.direction + axis.n + "-axis " + legacyStyles,\u000a                    font = axis.options.font || "flot-tick-label tickLabel",\u000a                    tick, x, y, halign, valign;\u000a\u000a                // Remove text before checking for axis.show and ticks.length;\u000a                // otherwise plugins, like flot-tickrotor, that draw their own\u000a                // tick labels will end up with both theirs and the defaults.\u000a\u000a                surface.removeText(layer);\u000a\u000a                if (!axis.show || axis.ticks.length == 0)\u000a                    return;\u000a\u000a                for (var i = 0; i < axis.ticks.length; ++i) {\u000a\u000a                    tick = axis.ticks[i];\u000a                    if (!tick.label || tick.v < axis.min || tick.v > axis.max)\u000a                        continue;\u000a\u000a                    if (axis.direction == "x") {\u000a                        halign = "center";\u000a                        x = plotOffset.left + axis.p2c(tick.v);\u000a                        if (axis.position == "bottom") {\u000a                            y = box.top + box.padding;\u000a                        } else {\u000a                            y = box.top + box.height - box.padding;\u000a                            valign = "bottom";\u000a                        }\u000a                    } else {\u000a                        valign = "middle";\u000a                        y = plotOffset.top + axis.p2c(tick.v);\u000a                        if (axis.position == "left") {\u000a                            x = box.left + box.width - box.padding;\u000a                            halign = "right";\u000a                        } else {\u000a                            x = box.left + box.padding;\u000a                        }\u000a                    }\u000a\u000a                    surface.addText(layer, x, y, tick.label, font, null, null, halign, valign);\u000a                }\u000a            });\u000a        }\u000a\u000a        function drawSeries(series) {\u000a            if (series.lines.show)\u000a                drawSeriesLines(series);\u000a            if (series.bars.show)\u000a                drawSeriesBars(series);\u000a            if (series.points.show)\u000a                drawSeriesPoints(series);\u000a        }\u000a\u000a        function drawSeriesLines(series) {\u000a            function plotLine(datapoints, xoffset, yoffset, axisx, axisy) {\u000a                var points = datapoints.points,\u000a                    ps = datapoints.pointsize,\u000a                    prevx = null, prevy = null;\u000a\u000a                ctx.beginPath();\u000a                for (var i = ps; i < points.length; i += ps) {\u000a                    var x1 = points[i - ps], y1 = points[i - ps + 1],\u000a                        x2 = points[i], y2 = points[i + 1];\u000a\u000a                    if (x1 == null || x2 == null)\u000a                        continue;\u000a\u000a                    // clip with ymin\u000a                    if (y1 <= y2 && y1 < axisy.min) {\u000a                        if (y2 < axisy.min)\u000a                            continue;   // line segment is outside\u000a                        // compute new intersection point\u000a                        x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\u000a                        y1 = axisy.min;\u000a                    }\u000a                    else if (y2 <= y1 && y2 < axisy.min) {\u000a                        if (y1 < axisy.min)\u000a                            continue;\u000a                        x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\u000a                        y2 = axisy.min;\u000a                    }\u000a\u000a                    // clip with ymax\u000a                    if (y1 >= y2 && y1 > axisy.max) {\u000a                        if (y2 > axisy.max)\u000a                            continue;\u000a                        x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\u000a                        y1 = axisy.max;\u000a                    }\u000a                    else if (y2 >= y1 && y2 > axisy.max) {\u000a                        if (y1 > axisy.max)\u000a                            continue;\u000a                        x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\u000a                        y2 = axisy.max;\u000a                    }\u000a\u000a                    // clip with xmin\u000a                    if (x1 <= x2 && x1 < axisx.min) {\u000a                        if (x2 < axisx.min)\u000a                            continue;\u000a                        y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\u000a                        x1 = axisx.min;\u000a                    }\u000a                    else if (x2 <= x1 && x2 < axisx.min) {\u000a                        if (x1 < axisx.min)\u000a                            continue;\u000a                        y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\u000a                        x2 = axisx.min;\u000a                    }\u000a\u000a                    // clip with xmax\u000a                    if (x1 >= x2 && x1 > axisx.max) {\u000a                        if (x2 > axisx.max)\u000a                            continue;\u000a                        y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\u000a                        x1 = axisx.max;\u000a                    }\u000a                    else if (x2 >= x1 && x2 > axisx.max) {\u000a                        if (x1 > axisx.max)\u000a                            continue;\u000a                        y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\u000a                        x2 = axisx.max;\u000a                    }\u000a\u000a                    if (x1 != prevx || y1 != prevy)\u000a                        ctx.moveTo(axisx.p2c(x1) + xoffset, axisy.p2c(y1) + yoffset);\u000a\u000a                    prevx = x2;\u000a                    prevy = y2;\u000a                    ctx.lineTo(axisx.p2c(x2) + xoffset, axisy.p2c(y2) + yoffset);\u000a                }\u000a                ctx.stroke();\u000a            }\u000a\u000a            function plotLineArea(datapoints, axisx, axisy) {\u000a                var points = datapoints.points,\u000a                    ps = datapoints.pointsize,\u000a                    bottom = Math.min(Math.max(0, axisy.min), axisy.max),\u000a                    i = 0, top, areaOpen = false,\u000a                    ypos = 1, segmentStart = 0, segmentEnd = 0;\u000a\u000a                // we process each segment in two turns, first forward\u000a                // direction to sketch out top, then once we hit the\u000a                // end we go backwards to sketch the bottom\u000a                while (true) {\u000a                    if (ps > 0 && i > points.length + ps)\u000a                        break;\u000a\u000a                    i += ps; // ps is negative if going backwards\u000a\u000a                    var x1 = points[i - ps],\u000a                        y1 = points[i - ps + ypos],\u000a                        x2 = points[i], y2 = points[i + ypos];\u000a\u000a                    if (areaOpen) {\u000a                        if (ps > 0 && x1 != null && x2 == null) {\u000a                            // at turning point\u000a                            segmentEnd = i;\u000a                            ps = -ps;\u000a                            ypos = 2;\u000a                            continue;\u000a                        }\u000a\u000a                        if (ps < 0 && i == segmentStart + ps) {\u000a                            // done with the reverse sweep\u000a                            ctx.fill();\u000a                            areaOpen = false;\u000a                            ps = -ps;\u000a                            ypos = 1;\u000a                            i = segmentStart = segmentEnd + ps;\u000a                            continue;\u000a                        }\u000a                    }\u000a\u000a                    if (x1 == null || x2 == null)\u000a                        continue;\u000a\u000a                    // clip x values\u000a\u000a                    // clip with xmin\u000a                    if (x1 <= x2 && x1 < axisx.min) {\u000a                        if (x2 < axisx.min)\u000a                            continue;\u000a                        y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\u000a                        x1 = axisx.min;\u000a                    }\u000a                    else if (x2 <= x1 && x2 < axisx.min) {\u000a                        if (x1 < axisx.min)\u000a                            continue;\u000a                        y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\u000a                        x2 = axisx.min;\u000a                    }\u000a\u000a                    // clip with xmax\u000a                    if (x1 >= x2 && x1 > axisx.max) {\u000a                        if (x2 > axisx.max)\u000a                            continue;\u000a                        y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\u000a                        x1 = axisx.max;\u000a                    }\u000a                    else if (x2 >= x1 && x2 > axisx.max) {\u000a                        if (x1 > axisx.max)\u000a                            continue;\u000a                        y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\u000a                        x2 = axisx.max;\u000a                    }\u000a\u000a                    if (!areaOpen) {\u000a                        // open area\u000a                        ctx.beginPath();\u000a                        ctx.moveTo(axisx.p2c(x1), axisy.p2c(bottom));\u000a                        areaOpen = true;\u000a                    }\u000a\u000a                    // now first check the case where both is outside\u000a                    if (y1 >= axisy.max && y2 >= axisy.max) {\u000a                        ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.max));\u000a                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.max));\u000a                        continue;\u000a                    }\u000a                    else if (y1 <= axisy.min && y2 <= axisy.min) {\u000a                        ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.min));\u000a                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.min));\u000a                        continue;\u000a                    }\u000a\u000a                    // else it's a bit more complicated, there might\u000a                    // be a flat maxed out rectangle first, then a\u000a                    // triangular cutout or reverse; to find these\u000a                    // keep track of the current x values\u000a                    var x1old = x1, x2old = x2;\u000a\u000a                    // clip the y values, without shortcutting, we\u000a                    // go through all cases in turn\u000a\u000a                    // clip with ymin\u000a                    if (y1 <= y2 && y1 < axisy.min && y2 >= axisy.min) {\u000a                        x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\u000a                        y1 = axisy.min;\u000a                    }\u000a                    else if (y2 <= y1 && y2 < axisy.min && y1 >= axisy.min) {\u000a                        x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\u000a                        y2 = axisy.min;\u000a                    }\u000a\u000a                    // clip with ymax\u000a                    if (y1 >= y2 && y1 > axisy.max && y2 <= axisy.max) {\u000a                        x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\u000a                        y1 = axisy.max;\u000a                    }\u000a                    else if (y2 >= y1 && y2 > axisy.max && y1 <= axisy.max) {\u000a                        x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\u000a                        y2 = axisy.max;\u000a                    }\u000a\u000a                    // if the x value was changed we got a rectangle\u000a                    // to fill\u000a                    if (x1 != x1old) {\u000a                        ctx.lineTo(axisx.p2c(x1old), axisy.p2c(y1));\u000a                        // it goes to (x1, y1), but we fill that below\u000a                    }\u000a\u000a                    // fill triangular section, this sometimes result\u000a                    // in redundant points if (x1, y1) hasn't changed\u000a                    // from previous line to, but we just ignore that\u000a                    ctx.lineTo(axisx.p2c(x1), axisy.p2c(y1));\u000a                    ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));\u000a\u000a                    // fill the other rectangle if it's there\u000a                    if (x2 != x2old) {\u000a                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));\u000a                        ctx.lineTo(axisx.p2c(x2old), axisy.p2c(y2));\u000a                    }\u000a                }\u000a            }\u000a\u000a            ctx.save();\u000a            ctx.translate(plotOffset.left, plotOffset.top);\u000a            ctx.lineJoin = "round";\u000a\u000a            var lw = series.lines.lineWidth,\u000a                sw = series.shadowSize;\u000a            // FIXME: consider another form of shadow when filling is turned on\u000a            if (lw > 0 && sw > 0) {\u000a                // draw shadow as a thick and thin line with transparency\u000a                ctx.lineWidth = sw;\u000a                ctx.strokeStyle = "rgba(0,0,0,0.1)";\u000a                // position shadow at angle from the mid of line\u000a                var angle = Math.PI/18;\u000a                plotLine(series.datapoints, Math.sin(angle) * (lw/2 + sw/2), Math.cos(angle) * (lw/2 + sw/2), series.xaxis, series.yaxis);\u000a                ctx.lineWidth = sw/2;\u000a                plotLine(series.datapoints, Math.sin(angle) * (lw/2 + sw/4), Math.cos(angle) * (lw/2 + sw/4), series.xaxis, series.yaxis);\u000a            }\u000a\u000a            ctx.lineWidth = lw;\u000a            ctx.strokeStyle = series.color;\u000a            var fillStyle = getFillStyle(series.lines, series.color, 0, plotHeight);\u000a            if (fillStyle) {\u000a                ctx.fillStyle = fillStyle;\u000a                plotLineArea(series.datapoints, series.xaxis, series.yaxis);\u000a            }\u000a\u000a            if (lw > 0)\u000a                plotLine(series.datapoints, 0, 0, series.xaxis, series.yaxis);\u000a            ctx.restore();\u000a        }\u000a\u000a        function drawSeriesPoints(series) {\u000a            function plotPoints(datapoints, radius, fillStyle, offset, shadow, axisx, axisy, symbol) {\u000a                var points = datapoints.points, ps = datapoints.pointsize;\u000a\u000a                for (var i = 0; i < points.length; i += ps) {\u000a                    var x = points[i], y = points[i + 1];\u000a                    if (x == null || x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max)\u000a                        continue;\u000a\u000a                    ctx.beginPath();\u000a                    x = axisx.p2c(x);\u000a                    y = axisy.p2c(y) + offset;\u000a                    if (symbol == "circle")\u000a                        ctx.arc(x, y, radius, 0, shadow ? Math.PI : Math.PI * 2, false);\u000a                    else\u000a                        symbol(ctx, x, y, radius, shadow);\u000a                    ctx.closePath();\u000a\u000a                    if (fillStyle) {\u000a                        ctx.fillStyle = fillStyle;\u000a                        ctx.fill();\u000a                    }\u000a                    ctx.stroke();\u000a                }\u000a            }\u000a\u000a            ctx.save();\u000a            ctx.translate(plotOffset.left, plotOffset.top);\u000a\u000a            var lw = series.points.lineWidth,\u000a                sw = series.shadowSize,\u000a                radius = series.points.radius,\u000a                symbol = series.points.symbol;\u000a\u000a            // If the user sets the line width to 0, we change it to a very \u000a            // small value. A line width of 0 seems to force the default of 1.\u000a            // Doing the conditional here allows the shadow setting to still be \u000a            // optional even with a lineWidth of 0.\u000a\u000a            if( lw == 0 )\u000a                lw = 0.0001;\u000a\u000a            if (lw > 0 && sw > 0) {\u000a                // draw shadow in two steps\u000a                var w = sw / 2;\u000a                ctx.lineWidth = w;\u000a                ctx.strokeStyle = "rgba(0,0,0,0.1)";\u000a                plotPoints(series.datapoints, radius, null, w + w/2, true,\u000a                           series.xaxis, series.yaxis, symbol);\u000a\u000a                ctx.strokeStyle = "rgba(0,0,0,0.2)";\u000a                plotPoints(series.datapoints, radius, null, w/2, true,\u000a                           series.xaxis, series.yaxis, symbol);\u000a            }\u000a\u000a            ctx.lineWidth = lw;\u000a            ctx.strokeStyle = series.color;\u000a            plotPoints(series.datapoints, radius,\u000a                       getFillStyle(series.points, series.color), 0, false,\u000a                       series.xaxis, series.yaxis, symbol);\u000a            ctx.restore();\u000a        }\u000a\u000a        function drawBar(x, y, b, barLeft, barRight, fillStyleCallback, axisx, axisy, c, horizontal, lineWidth) {\u000a            var left, right, bottom, top,\u000a                drawLeft, drawRight, drawTop, drawBottom,\u000a                tmp;\u000a\u000a            // in horizontal mode, we start the bar from the left\u000a            // instead of from the bottom so it appears to be\u000a            // horizontal rather than vertical\u000a            if (horizontal) {\u000a                drawBottom = drawRight = drawTop = true;\u000a                drawLeft = false;\u000a                left = b;\u000a                right = x;\u000a                top = y + barLeft;\u000a                bottom = y + barRight;\u000a\u000a                // account for negative bars\u000a                if (right < left) {\u000a                    tmp = right;\u000a                    right = left;\u000a                    left = tmp;\u000a                    drawLeft = true;\u000a                    drawRight = false;\u000a                }\u000a            }\u000a            else {\u000a                drawLeft = drawRight = drawTop = true;\u000a                drawBottom = false;\u000a                left = x + barLeft;\u000a                right = x + barRight;\u000a                bottom = b;\u000a                top = y;\u000a\u000a                // account for negative bars\u000a                if (top < bottom) {\u000a                    tmp = top;\u000a                    top = bottom;\u000a                    bottom = tmp;\u000a                    drawBottom = true;\u000a                    drawTop = false;\u000a                }\u000a            }\u000a\u000a            // clip\u000a            if (right < axisx.min || left > axisx.max ||\u000a                top < axisy.min || bottom > axisy.max)\u000a                return;\u000a\u000a            if (left < axisx.min) {\u000a                left = axisx.min;\u000a                drawLeft = false;\u000a            }\u000a\u000a            if (right > axisx.max) {\u000a                right = axisx.max;\u000a                drawRight = false;\u000a            }\u000a\u000a            if (bottom < axisy.min) {\u000a                bottom = axisy.min;\u000a                drawBottom = false;\u000a            }\u000a\u000a            if (top > axisy.max) {\u000a                top = axisy.max;\u000a                drawTop = false;\u000a            }\u000a\u000a            left = axisx.p2c(left);\u000a            bottom = axisy.p2c(bottom);\u000a            right = axisx.p2c(right);\u000a            top = axisy.p2c(top);\u000a\u000a            // fill the bar\u000a            if (fillStyleCallback) {\u000a                c.fillStyle = fillStyleCallback(bottom, top);\u000a                c.fillRect(left, top, right - left, bottom - top)\u000a            }\u000a\u000a            // draw outline\u000a            if (lineWidth > 0 && (drawLeft || drawRight || drawTop || drawBottom)) {\u000a                c.beginPath();\u000a\u000a                // FIXME: inline moveTo is buggy with excanvas\u000a                c.moveTo(left, bottom);\u000a                if (drawLeft)\u000a                    c.lineTo(left, top);\u000a                else\u000a                    c.moveTo(left, top);\u000a                if (drawTop)\u000a                    c.lineTo(right, top);\u000a                else\u000a                    c.moveTo(right, top);\u000a                if (drawRight)\u000a                    c.lineTo(right, bottom);\u000a                else\u000a                    c.moveTo(right, bottom);\u000a                if (drawBottom)\u000a                    c.lineTo(left, bottom);\u000a                else\u000a                    c.moveTo(left, bottom);\u000a                c.stroke();\u000a            }\u000a        }\u000a\u000a        function drawSeriesBars(series) {\u000a            function plotBars(datapoints, barLeft, barRight, fillStyleCallback, axisx, axisy) {\u000a                var points = datapoints.points, ps = datapoints.pointsize;\u000a\u000a                for (var i = 0; i < points.length; i += ps) {\u000a                    if (points[i] == null)\u000a                        continue;\u000a                    drawBar(points[i], points[i + 1], points[i + 2], barLeft, barRight, fillStyleCallback, axisx, axisy, ctx, series.bars.horizontal, series.bars.lineWidth);\u000a                }\u000a            }\u000a\u000a            ctx.save();\u000a            ctx.translate(plotOffset.left, plotOffset.top);\u000a\u000a            // FIXME: figure out a way to add shadows (for instance along the right edge)\u000a            ctx.lineWidth = series.bars.lineWidth;\u000a            ctx.strokeStyle = series.color;\u000a\u000a            var barLeft;\u000a\u000a            switch (series.bars.align) {\u000a                case "left":\u000a                    barLeft = 0;\u000a                    break;\u000a                case "right":\u000a                    barLeft = -series.bars.barWidth;\u000a                    break;\u000a                default:\u000a                    barLeft = -series.bars.barWidth / 2;\u000a            }\u000a\u000a            var fillStyleCallback = series.bars.fill ? function (bottom, top) { return getFillStyle(series.bars, series.color, bottom, top); } : null;\u000a            plotBars(series.datapoints, barLeft, barLeft + series.bars.barWidth, fillStyleCallback, series.xaxis, series.yaxis);\u000a            ctx.restore();\u000a        }\u000a\u000a        function getFillStyle(filloptions, seriesColor, bottom, top) {\u000a            var fill = filloptions.fill;\u000a            if (!fill)\u000a                return null;\u000a\u000a            if (filloptions.fillColor)\u000a                return getColorOrGradient(filloptions.fillColor, bottom, top, seriesColor);\u000a\u000a            var c = $.color.parse(seriesColor);\u000a            c.a = typeof fill == "number" ? fill : 0.4;\u000a            c.normalize();\u000a            return c.toString();\u000a        }\u000a\u000a        function insertLegend() {\u000a\u000a            if (options.legend.container != null) {\u000a                $(options.legend.container).html("");\u000a            } else {\u000a                placeholder.find(".legend").remove();\u000a            }\u000a\u000a            if (!options.legend.show) {\u000a                return;\u000a            }\u000a\u000a            var fragments = [], entries = [], rowStarted = false,\u000a                lf = options.legend.labelFormatter, s, label;\u000a\u000a            // Build a list of legend entries, with each having a label and a color\u000a\u000a            for (var i = 0; i < series.length; ++i) {\u000a                s = series[i];\u000a                if (s.label) {\u000a                    label = lf ? lf(s.label, s) : s.label;\u000a                    if (label) {\u000a                        entries.push({\u000a                            label: label,\u000a                            color: s.color\u000a                        });\u000a                    }\u000a                }\u000a            }\u000a\u000a            // Sort the legend using either the default or a custom comparator\u000a\u000a            if (options.legend.sorted) {\u000a                if ($.isFunction(options.legend.sorted)) {\u000a                    entries.sort(options.legend.sorted);\u000a                } else if (options.legend.sorted == "reverse") {\u000a                	entries.reverse();\u000a                } else {\u000a                    var ascending = options.legend.sorted != "descending";\u000a                    entries.sort(function(a, b) {\u000a                        return a.label == b.label ? 0 : (\u000a                            (a.label < b.label) != ascending ? 1 : -1   // Logical XOR\u000a                        );\u000a                    });\u000a                }\u000a            }\u000a\u000a            // Generate markup for the list of entries, in their final order\u000a\u000a            for (var i = 0; i < entries.length; ++i) {\u000a\u000a                var entry = entries[i];\u000a\u000a                if (i % options.legend.noColumns == 0) {\u000a                    if (rowStarted)\u000a                        fragments.push('</tr>');\u000a                    fragments.push('<tr>');\u000a                    rowStarted = true;\u000a                }\u000a\u000a                fragments.push(\u000a                    '<td class="legendColorBox"><div style="border:1px solid ' + options.legend.labelBoxBorderColor + ';padding:1px"><div style="width:4px;height:0;border:5px solid ' + entry.color + ';overflow:hidden"></div></div></td>' +\u000a                    '<td class="legendLabel">' + entry.label + '</td>'\u000a                );\u000a            }\u000a\u000a            if (rowStarted)\u000a                fragments.push('</tr>');\u000a\u000a            if (fragments.length == 0)\u000a                return;\u000a\u000a            var table = '<table style="font-size:smaller;color:' + options.grid.color + '">' + fragments.join("") + '</table>';\u000a            if (options.legend.container != null)\u000a                $(options.legend.container).html(table);\u000a            else {\u000a                var pos = "",\u000a                    p = options.legend.position,\u000a                    m = options.legend.margin;\u000a                if (m[0] == null)\u000a                    m = [m, m];\u000a                if (p.charAt(0) == "n")\u000a                    pos += 'top:' + (m[1] + plotOffset.top) + 'px;';\u000a                else if (p.charAt(0) == "s")\u000a                    pos += 'bottom:' + (m[1] + plotOffset.bottom) + 'px;';\u000a                if (p.charAt(1) == "e")\u000a                    pos += 'right:' + (m[0] + plotOffset.right) + 'px;';\u000a                else if (p.charAt(1) == "w")\u000a                    pos += 'left:' + (m[0] + plotOffset.left) + 'px;';\u000a                var legend = $('<div class="legend">' + table.replace('style="', 'style="position:absolute;' + pos +';') + '</div>').appendTo(placeholder);\u000a                if (options.legend.backgroundOpacity != 0.0) {\u000a                    // put in the transparent background\u000a                    // separately to avoid blended labels and\u000a                    // label boxes\u000a                    var c = options.legend.backgroundColor;\u000a                    if (c == null) {\u000a                        c = options.grid.backgroundColor;\u000a                        if (c && typeof c == "string")\u000a                            c = $.color.parse(c);\u000a                        else\u000a                            c = $.color.extract(legend, 'background-color');\u000a                        c.a = 1;\u000a                        c = c.toString();\u000a                    }\u000a                    var div = legend.children();\u000a                    $('<div style="position:absolute;width:' + div.width() + 'px;height:' + div.height() + 'px;' + pos +'background-color:' + c + ';"> </div>').prependTo(legend).css('opacity', options.legend.backgroundOpacity);\u000a                }\u000a            }\u000a        }\u000a\u000a\u000a        // interactive features\u000a\u000a        var highlights = [],\u000a            redrawTimeout = null;\u000a\u000a        // returns the data item the mouse is over, or null if none is found\u000a        function findNearbyItem(mouseX, mouseY, seriesFilter) {\u000a            var maxDistance = options.grid.mouseActiveRadius,\u000a                smallestDistance = maxDistance * maxDistance + 1,\u000a                item = null, foundPoint = false, i, j, ps;\u000a\u000a            for (i = series.length - 1; i >= 0; --i) {\u000a                if (!seriesFilter(series[i]))\u000a                    continue;\u000a\u000a                var s = series[i],\u000a                    axisx = s.xaxis,\u000a                    axisy = s.yaxis,\u000a                    points = s.datapoints.points,\u000a                    mx = axisx.c2p(mouseX), // precompute some stuff to make the loop faster\u000a                    my = axisy.c2p(mouseY),\u000a                    maxx = maxDistance / axisx.scale,\u000a                    maxy = maxDistance / axisy.scale;\u000a\u000a                ps = s.datapoints.pointsize;\u000a                // with inverse transforms, we can't use the maxx/maxy\u000a                // optimization, sadly\u000a                if (axisx.options.inverseTransform)\u000a                    maxx = Number.MAX_VALUE;\u000a                if (axisy.options.inverseTransform)\u000a                    maxy = Number.MAX_VALUE;\u000a\u000a                if (s.lines.show || s.points.show) {\u000a                    for (j = 0; j < points.length; j += ps) {\u000a                        var x = points[j], y = points[j + 1];\u000a                        if (x == null)\u000a                            continue;\u000a\u000a                        // For points and lines, the cursor must be within a\u000a                        // certain distance to the data point\u000a                        if (x - mx > maxx || x - mx < -maxx ||\u000a                            y - my > maxy || y - my < -maxy)\u000a                            continue;\u000a\u000a                        // We have to calculate distances in pixels, not in\u000a                        // data units, because the scales of the axes may be different\u000a                        var dx = Math.abs(axisx.p2c(x) - mouseX),\u000a                            dy = Math.abs(axisy.p2c(y) - mouseY),\u000a                            dist = dx * dx + dy * dy; // we save the sqrt\u000a\u000a                        // use <= to ensure last point takes precedence\u000a                        // (last generally means on top of)\u000a                        if (dist < smallestDistance) {\u000a                            smallestDistance = dist;\u000a                            item = [i, j / ps];\u000a                        }\u000a                    }\u000a                }\u000a\u000a                if (s.bars.show && !item) { // no other point can be nearby\u000a\u000a                    var barLeft, barRight;\u000a\u000a                    switch (s.bars.align) {\u000a                        case "left":\u000a                            barLeft = 0;\u000a                            break;\u000a                        case "right":\u000a                            barLeft = -s.bars.barWidth;\u000a                            break;\u000a                        default:\u000a                            barLeft = -s.bars.barWidth / 2;\u000a                    }\u000a\u000a                    barRight = barLeft + s.bars.barWidth;\u000a\u000a                    for (j = 0; j < points.length; j += ps) {\u000a                        var x = points[j], y = points[j + 1], b = points[j + 2];\u000a                        if (x == null)\u000a                            continue;\u000a\u000a                        // for a bar graph, the cursor must be inside the bar\u000a                        if (series[i].bars.horizontal ?\u000a                            (mx <= Math.max(b, x) && mx >= Math.min(b, x) &&\u000a                             my >= y + barLeft && my <= y + barRight) :\u000a                            (mx >= x + barLeft && mx <= x + barRight &&\u000a                             my >= Math.min(b, y) && my <= Math.max(b, y)))\u000a                                item = [i, j / ps];\u000a                    }\u000a                }\u000a            }\u000a\u000a            if (item) {\u000a                i = item[0];\u000a                j = item[1];\u000a                ps = series[i].datapoints.pointsize;\u000a\u000a                return { datapoint: series[i].datapoints.points.slice(j * ps, (j + 1) * ps),\u000a                         dataIndex: j,\u000a                         series: series[i],\u000a                         seriesIndex: i };\u000a            }\u000a\u000a            return null;\u000a        }\u000a\u000a        function onMouseMove(e) {\u000a            if (options.grid.hoverable)\u000a                triggerClickHoverEvent("plothover", e,\u000a                                       function (s) { return s["hoverable"] != false; });\u000a        }\u000a\u000a        function onMouseLeave(e) {\u000a            if (options.grid.hoverable)\u000a                triggerClickHoverEvent("plothover", e,\u000a                                       function (s) { return false; });\u000a        }\u000a\u000a        function onClick(e) {\u000a            triggerClickHoverEvent("plotclick", e,\u000a                                   function (s) { return s["clickable"] != false; });\u000a        }\u000a\u000a        // trigger click or hover event (they send the same parameters\u000a        // so we share their code)\u000a        function triggerClickHoverEvent(eventname, event, seriesFilter) {\u000a            var offset = eventHolder.offset(),\u000a                canvasX = event.pageX - offset.left - plotOffset.left,\u000a                canvasY = event.pageY - offset.top - plotOffset.top,\u000a            pos = canvasToAxisCoords({ left: canvasX, top: canvasY });\u000a\u000a            pos.pageX = event.pageX;\u000a            pos.pageY = event.pageY;\u000a\u000a            var item = findNearbyItem(canvasX, canvasY, seriesFilter);\u000a\u000a            if (item) {\u000a                // fill in mouse pos for any listeners out there\u000a                item.pageX = parseInt(item.series.xaxis.p2c(item.datapoint[0]) + offset.left + plotOffset.left, 10);\u000a                item.pageY = parseInt(item.series.yaxis.p2c(item.datapoint[1]) + offset.top + plotOffset.top, 10);\u000a            }\u000a\u000a            if (options.grid.autoHighlight) {\u000a                // clear auto-highlights\u000a                for (var i = 0; i < highlights.length; ++i) {\u000a                    var h = highlights[i];\u000a                    if (h.auto == eventname &&\u000a                        !(item && h.series == item.series &&\u000a                          h.point[0] == item.datapoint[0] &&\u000a                          h.point[1] == item.datapoint[1]))\u000a                        unhighlight(h.series, h.point);\u000a                }\u000a\u000a                if (item)\u000a                    highlight(item.series, item.datapoint, eventname);\u000a            }\u000a\u000a            placeholder.trigger(eventname, [ pos, item ]);\u000a        }\u000a\u000a        function triggerRedrawOverlay() {\u000a            var t = options.interaction.redrawOverlayInterval;\u000a            if (t == -1) {      // skip event queue\u000a                drawOverlay();\u000a                return;\u000a            }\u000a\u000a            if (!redrawTimeout)\u000a                redrawTimeout = setTimeout(drawOverlay, t);\u000a        }\u000a\u000a        function drawOverlay() {\u000a            redrawTimeout = null;\u000a\u000a            // draw highlights\u000a            octx.save();\u000a            overlay.clear();\u000a            octx.translate(plotOffset.left, plotOffset.top);\u000a\u000a            var i, hi;\u000a            for (i = 0; i < highlights.length; ++i) {\u000a                hi = highlights[i];\u000a\u000a                if (hi.series.bars.show)\u000a                    drawBarHighlight(hi.series, hi.point);\u000a                else\u000a                    drawPointHighlight(hi.series, hi.point);\u000a            }\u000a            octx.restore();\u000a\u000a            executeHooks(hooks.drawOverlay, [octx]);\u000a        }\u000a\u000a        function highlight(s, point, auto) {\u000a            if (typeof s == "number")\u000a                s = series[s];\u000a\u000a            if (typeof point == "number") {\u000a                var ps = s.datapoints.pointsize;\u000a                point = s.datapoints.points.slice(ps * point, ps * (point + 1));\u000a            }\u000a\u000a            var i = indexOfHighlight(s, point);\u000a            if (i == -1) {\u000a                highlights.push({ series: s, point: point, auto: auto });\u000a\u000a                triggerRedrawOverlay();\u000a            }\u000a            else if (!auto)\u000a                highlights[i].auto = false;\u000a        }\u000a\u000a        function unhighlight(s, point) {\u000a            if (s == null && point == null) {\u000a                highlights = [];\u000a                triggerRedrawOverlay();\u000a                return;\u000a            }\u000a\u000a            if (typeof s == "number")\u000a                s = series[s];\u000a\u000a            if (typeof point == "number") {\u000a                var ps = s.datapoints.pointsize;\u000a                point = s.datapoints.points.slice(ps * point, ps * (point + 1));\u000a            }\u000a\u000a            var i = indexOfHighlight(s, point);\u000a            if (i != -1) {\u000a                highlights.splice(i, 1);\u000a\u000a                triggerRedrawOverlay();\u000a            }\u000a        }\u000a\u000a        function indexOfHighlight(s, p) {\u000a            for (var i = 0; i < highlights.length; ++i) {\u000a                var h = highlights[i];\u000a                if (h.series == s && h.point[0] == p[0]\u000a                    && h.point[1] == p[1])\u000a                    return i;\u000a            }\u000a            return -1;\u000a        }\u000a\u000a        function drawPointHighlight(series, point) {\u000a            var x = point[0], y = point[1],\u000a                axisx = series.xaxis, axisy = series.yaxis,\u000a                highlightColor = (typeof series.highlightColor === "string") ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString();\u000a\u000a            if (x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max)\u000a                return;\u000a\u000a            var pointRadius = series.points.radius + series.points.lineWidth / 2;\u000a            octx.lineWidth = pointRadius;\u000a            octx.strokeStyle = highlightColor;\u000a            var radius = 1.5 * pointRadius;\u000a            x = axisx.p2c(x);\u000a            y = axisy.p2c(y);\u000a\u000a            octx.beginPath();\u000a            if (series.points.symbol == "circle")\u000a                octx.arc(x, y, radius, 0, 2 * Math.PI, false);\u000a            else\u000a                series.points.symbol(octx, x, y, radius, false);\u000a            octx.closePath();\u000a            octx.stroke();\u000a        }\u000a\u000a        function drawBarHighlight(series, point) {\u000a            var highlightColor = (typeof series.highlightColor === "string") ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString(),\u000a                fillStyle = highlightColor,\u000a                barLeft;\u000a\u000a            switch (series.bars.align) {\u000a                case "left":\u000a                    barLeft = 0;\u000a                    break;\u000a                case "right":\u000a                    barLeft = -series.bars.barWidth;\u000a                    break;\u000a                default:\u000a                    barLeft = -series.bars.barWidth / 2;\u000a            }\u000a\u000a            octx.lineWidth = series.bars.lineWidth;\u000a            octx.strokeStyle = highlightColor;\u000a\u000a            drawBar(point[0], point[1], point[2] || 0, barLeft, barLeft + series.bars.barWidth,\u000a                    function () { return fillStyle; }, series.xaxis, series.yaxis, octx, series.bars.horizontal, series.bars.lineWidth);\u000a        }\u000a\u000a        function getColorOrGradient(spec, bottom, top, defaultColor) {\u000a            if (typeof spec == "string")\u000a                return spec;\u000a            else {\u000a                // assume this is a gradient spec; IE currently only\u000a                // supports a simple vertical gradient properly, so that's\u000a                // what we support too\u000a                var gradient = ctx.createLinearGradient(0, top, 0, bottom);\u000a\u000a                for (var i = 0, l = spec.colors.length; i < l; ++i) {\u000a                    var c = spec.colors[i];\u000a                    if (typeof c != "string") {\u000a                        var co = $.color.parse(defaultColor);\u000a                        if (c.brightness != null)\u000a                            co = co.scale('rgb', c.brightness);\u000a                        if (c.opacity != null)\u000a                            co.a *= c.opacity;\u000a                        c = co.toString();\u000a                    }\u000a                    gradient.addColorStop(i / (l - 1), c);\u000a                }\u000a\u000a                return gradient;\u000a            }\u000a        }\u000a    }\u000a\u000a    // Add the plot function to the top level of the jQuery object\u000a\u000a    $.plot = function(placeholder, data, options) {\u000a        //var t0 = new Date();\u000a        var plot = new Plot($(placeholder), data, options, $.plot.plugins);\u000a        //(window.console ? console.log : alert)("time used (msecs): " + ((new Date()).getTime() - t0.getTime()));\u000a        return plot;\u000a    };\u000a\u000a    $.plot.version = "0.8.3";\u000a\u000a    $.plot.plugins = [];\u000a\u000a    // Also add the plot function as a chainable property\u000a\u000a    $.fn.plot = function(data, options) {\u000a        return this.each(function() {\u000a            $.plot(this, data, options);\u000a        });\u000a    };\u000a\u000a    // round to nearby lower multiple of base\u000a    function floorInBase(n, base) {\u000a        return base * Math.floor(n / base);\u000a    }\u000a\u000a})(jQuery);\u000a\u000a;\u000a
p0
.