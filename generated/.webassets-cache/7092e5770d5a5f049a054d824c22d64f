V// source: js/app/viewmodels/settings.js\u000a$(function () {\u000a    function SettingsViewModel(parameters) {\u000a        var self = this;\u000a\u000a        self.loginState = parameters[0];\u000a        self.access = parameters[1];\u000a        self.printerProfiles = parameters[2];\u000a        self.about = parameters[3];\u000a\u000a        // TODO: remove in upcoming version, this is only for backwards compatibility\u000a        self.users = parameters[4];\u000a\u000a        // use this promise to do certain things once the SettingsViewModel has processed\u000a        // its first request\u000a        var firstRequest = $.Deferred();\u000a        self.firstRequest = firstRequest.promise();\u000a\u000a        self.allViewModels = [];\u000a\u000a        self.receiving = ko.observable(false);\u000a        self.sending = ko.observable(false);\u000a        self.exchanging = ko.pureComputed(function () {\u000a            return self.receiving() || self.sending();\u000a        });\u000a        self.outstanding = [];\u000a\u000a        self.active = false;\u000a        self.sawUpdateEventWhileActive = false;\u000a        self.ignoreNextUpdateEvent = false;\u000a\u000a        self.settingsDialog = undefined;\u000a        self.settings_dialog_update_detected = undefined;\u000a        self.translationManagerDialog = undefined;\u000a        self.translationUploadElement = $(\u000a            "#settings_appearance_managelanguagesdialog_upload"\u000a        );\u000a        self.translationUploadButton = $(\u000a            "#settings_appearance_managelanguagesdialog_upload_start"\u000a        );\u000a\u000a        self.translationUploadFilename = ko.observable();\u000a        self.invalidTranslationArchive = ko.pureComputed(function () {\u000a            var name = self.translationUploadFilename();\u000a            return (\u000a                name !== undefined &&\u000a                !(\u000a                    _.endsWith(name.toLocaleLowerCase(), ".zip") ||\u000a                    _.endsWith(name.toLocaleLowerCase(), ".tar.gz") ||\u000a                    _.endsWith(name.toLocaleLowerCase(), ".tgz") ||\u000a                    _.endsWith(name.toLocaleLowerCase(), ".tar")\u000a                )\u000a            );\u000a        });\u000a        self.enableTranslationUpload = ko.pureComputed(function () {\u000a            var name = self.translationUploadFilename();\u000a            return (\u000a                name !== undefined &&\u000a                name.trim() != "" &&\u000a                !self.invalidTranslationArchive()\u000a            );\u000a        });\u000a\u000a        self.translations = new ItemListHelper(\u000a            "settings.translations",\u000a            {\u000a                locale: function (a, b) {\u000a                    // sorts ascending\u000a                    if (a["locale"].toLocaleLowerCase() < b["locale"].toLocaleLowerCase())\u000a                        return -1;\u000a                    if (a["locale"].toLocaleLowerCase() > b["locale"].toLocaleLowerCase())\u000a                        return 1;\u000a                    return 0;\u000a                }\u000a            },\u000a            {},\u000a            "locale",\u000a            [],\u000a            [],\u000a            0\u000a        );\u000a\u000a        self.appearance_available_colors = ko.observable([\u000a            {key: "default", name: gettext("default")},\u000a            {key: "red", name: gettext("red")},\u000a            {key: "orange", name: gettext("orange")},\u000a            {key: "yellow", name: gettext("yellow")},\u000a            {key: "green", name: gettext("green")},\u000a            {key: "blue", name: gettext("blue")},\u000a            {key: "violet", name: gettext("violet")},\u000a            {key: "black", name: gettext("black")},\u000a            {key: "white", name: gettext("white")}\u000a        ]);\u000a\u000a        self.appearance_colorName = function (color) {\u000a            switch (color) {\u000a                case "red":\u000a                    return gettext("red");\u000a                case "orange":\u000a                    return gettext("orange");\u000a                case "yellow":\u000a                    return gettext("yellow");\u000a                case "green":\u000a                    return gettext("green");\u000a                case "blue":\u000a                    return gettext("blue");\u000a                case "violet":\u000a                    return gettext("violet");\u000a                case "black":\u000a                    return gettext("black");\u000a                case "white":\u000a                    return gettext("white");\u000a                case "default":\u000a                    return gettext("default");\u000a                default:\u000a                    return color;\u000a            }\u000a        };\u000a\u000a        self.webcam_available_ratios = ["16:9", "4:3"];\u000a        self.webcam_available_videocodecs = ["libx264", "mpeg2video"];\u000a\u000a        var auto_locale = {\u000a            language: "_default",\u000a            display: gettext("Autodetect from browser"),\u000a            english: undefined\u000a        };\u000a        self.locales = ko.observableArray(\u000a            [auto_locale].concat(\u000a                _.sortBy(_.values(AVAILABLE_LOCALES), function (n) {\u000a                    return n.display;\u000a                })\u000a            )\u000a        );\u000a        self.locale_languages = _.keys(AVAILABLE_LOCALES);\u000a\u000a        self.api_key = ko.observable(undefined);\u000a        self.api_allowCrossOrigin = ko.observable(undefined);\u000a\u000a        self.appearance_name = ko.observable(undefined);\u000a        self.appearance_color = ko.observable(undefined);\u000a        self.appearance_colorTransparent = ko.observable();\u000a        self.appearance_colorIcon = ko.observable();\u000a        self.appearance_defaultLanguage = ko.observable();\u000a        self.appearance_showFahrenheitAlso = ko.observable(undefined);\u000a        self.appearance_fuzzyTimes = ko.observable(undefined);\u000a        self.appearance_closeModalsWithClick = ko.observable(undefined);\u000a        self.appearance_showInternalFilename = ko.observable(undefined);\u000a\u000a        self.printer_defaultExtrusionLength = ko.observable(undefined);\u000a\u000a        self.webcam_webcamEnabled = ko.observable(undefined);\u000a        self.webcam_timelapseEnabled = ko.observable(undefined);\u000a        self.webcam_streamUrl = ko.observable(undefined);\u000a        self.webcam_streamRatio = ko.observable(undefined);\u000a        self.webcam_streamTimeout = ko.observable(undefined);\u000a        self.webcam_snapshotUrl = ko.observable(undefined);\u000a        self.webcam_snapshotTimeout = ko.observable(undefined);\u000a        self.webcam_snapshotSslValidation = ko.observable(undefined);\u000a        self.webcam_ffmpegPath = ko.observable(undefined);\u000a        self.webcam_bitrate = ko.observable(undefined);\u000a        self.webcam_ffmpegThreads = ko.observable(undefined);\u000a        self.webcam_ffmpegVideoCodec = ko.observable(undefined);\u000a        self.webcam_watermark = ko.observable(undefined);\u000a        self.webcam_flipH = ko.observable(undefined);\u000a        self.webcam_flipV = ko.observable(undefined);\u000a        self.webcam_rotate90 = ko.observable(undefined);\u000a\u000a        self.feature_temperatureGraph = ko.observable(undefined);\u000a        self.feature_sdSupport = ko.observable(undefined);\u000a        self.feature_keyboardControl = ko.observable(undefined);\u000a        self.feature_pollWatched = ko.observable(undefined);\u000a        self.feature_modelSizeDetection = ko.observable(undefined);\u000a        self.feature_printStartConfirmation = ko.observable(undefined);\u000a        self.feature_printCancelConfirmation = ko.observable(undefined);\u000a        self.feature_g90InfluencesExtruder = ko.observable(undefined);\u000a        self.feature_autoUppercaseBlacklist = ko.observable(undefined);\u000a\u000a        self.gcodeAnalysis_runAt = ko.observable(undefined);\u000a\u000a        self.serial_port = ko.observable();\u000a        self.serial_baudrate = ko.observable();\u000a        self.serial_exclusive = ko.observable();\u000a        self.serial_portOptions = ko.observableArray([]);\u000a        self.serial_baudrateOptions = ko.observableArray([]);\u000a        self.serial_autoconnect = ko.observable(undefined);\u000a        self.serial_timeoutConnection = ko.observable(undefined);\u000a        self.serial_timeoutDetectionFirst = ko.observable(undefined);\u000a        self.serial_timeoutDetectionConsecutive = ko.observable(undefined);\u000a        self.serial_timeoutCommunication = ko.observable(undefined);\u000a        self.serial_timeoutCommunicationBusy = ko.observable(undefined);\u000a        self.serial_timeoutTemperature = ko.observable(undefined);\u000a        self.serial_timeoutTemperatureTargetSet = ko.observable(undefined);\u000a        self.serial_timeoutTemperatureAutoreport = ko.observable(undefined);\u000a        self.serial_timeoutSdStatus = ko.observable(undefined);\u000a        self.serial_timeoutSdStatusAutoreport = ko.observable(undefined);\u000a        self.serial_timeoutBaudrateDetectionPause = ko.observable(undefined);\u000a        self.serial_timeoutPositionLogWait = ko.observable(undefined);\u000a        self.serial_log = ko.observable(undefined);\u000a        self.serial_additionalPorts = ko.observable(undefined);\u000a        self.serial_additionalBaudrates = ko.observable(undefined);\u000a        self.serial_blacklistedPorts = ko.observable(undefined);\u000a        self.serial_blacklistedBaudrates = ko.observable(undefined);\u000a        self.serial_longRunningCommands = ko.observable(undefined);\u000a        self.serial_checksumRequiringCommands = ko.observable(undefined);\u000a        self.serial_blockedCommands = ko.observable(undefined);\u000a        self.serial_pausingCommands = ko.observable(undefined);\u000a        self.serial_emergencyCommands = ko.observable(undefined);\u000a        self.serial_helloCommand = ko.observable(undefined);\u000a        self.serial_serialErrorBehaviour = ko.observable("cancel");\u000a        self.serial_triggerOkForM29 = ko.observable(undefined);\u000a        self.serial_waitForStart = ko.observable(undefined);\u000a        self.serial_sendChecksum = ko.observable("print");\u000a        self.serial_sdRelativePath = ko.observable(undefined);\u000a        self.serial_sdAlwaysAvailable = ko.observable(undefined);\u000a        self.serial_swallowOkAfterResend = ko.observable(undefined);\u000a        self.serial_repetierTargetTemp = ko.observable(undefined);\u000a        self.serial_disableExternalHeatupDetection = ko.observable(undefined);\u000a        self.serial_ignoreIdenticalResends = ko.observable(undefined);\u000a        self.serial_firmwareDetection = ko.observable(undefined);\u000a        self.serial_blockWhileDwelling = ko.observable(undefined);\u000a        self.serial_useParityWorkaround = ko.observable(undefined);\u000a        self.serial_sanityCheckTools = ko.observable(undefined);\u000a        self.serial_supportResendsWithoutOk = ko.observable(undefined);\u000a        self.serial_logPositionOnPause = ko.observable(undefined);\u000a        self.serial_logPositionOnCancel = ko.observable(undefined);\u000a        self.serial_abortHeatupOnCancel = ko.observable(undefined);\u000a        self.serial_maxTimeoutsIdle = ko.observable(undefined);\u000a        self.serial_maxTimeoutsPrinting = ko.observable(undefined);\u000a        self.serial_maxTimeoutsLong = ko.observable(undefined);\u000a        self.serial_capAutoreportTemp = ko.observable(undefined);\u000a        self.serial_capAutoreportSdStatus = ko.observable(undefined);\u000a        self.serial_capBusyProtocol = ko.observable(undefined);\u000a        self.serial_capEmergencyParser = ko.observable(undefined);\u000a        self.serial_sendM112OnError = ko.observable(undefined);\u000a        self.serial_disableSdPrintingDetection = ko.observable(undefined);\u000a        self.serial_ackMax = ko.observable(undefined);\u000a        self.serial_resendRatioThreshold = ko.observable(100);\u000a        self.serial_resendRatioStart = ko.observable(100);\u000a\u000a        self.folder_uploads = ko.observable(undefined);\u000a        self.folder_timelapse = ko.observable(undefined);\u000a        self.folder_timelapseTmp = ko.observable(undefined);\u000a        self.folder_logs = ko.observable(undefined);\u000a        self.folder_watched = ko.observable(undefined);\u000a\u000a        self.scripts_gcode_beforePrintStarted = ko.observable(undefined);\u000a        self.scripts_gcode_afterPrintDone = ko.observable(undefined);\u000a        self.scripts_gcode_afterPrintCancelled = ko.observable(undefined);\u000a        self.scripts_gcode_afterPrintPaused = ko.observable(undefined);\u000a        self.scripts_gcode_beforePrintResumed = ko.observable(undefined);\u000a        self.scripts_gcode_afterPrinterConnected = ko.observable(undefined);\u000a        self.scripts_gcode_beforePrinterDisconnected = ko.observable(undefined);\u000a        self.scripts_gcode_afterToolChange = ko.observable(undefined);\u000a        self.scripts_gcode_beforeToolChange = ko.observable(undefined);\u000a\u000a        self.temperature_profiles = ko.observableArray(undefined);\u000a        self.temperature_cutoff = ko.observable(undefined);\u000a        self.temperature_sendAutomatically = ko.observable(undefined);\u000a        self.temperature_sendAutomaticallyAfter = ko.observable(undefined);\u000a\u000a        self.system_actions = ko.observableArray([]);\u000a\u000a        self.terminalFilters = ko.observableArray([]);\u000a\u000a        self.server_commands_systemShutdownCommand = ko.observable(undefined);\u000a        self.server_commands_systemRestartCommand = ko.observable(undefined);\u000a        self.server_commands_serverRestartCommand = ko.observable(undefined);\u000a\u000a        self.server_diskspace_warning = ko.observable();\u000a        self.server_diskspace_critical = ko.observable();\u000a        self.server_diskspace_warning_str = sizeObservable(self.server_diskspace_warning);\u000a        self.server_diskspace_critical_str = sizeObservable(\u000a            self.server_diskspace_critical\u000a        );\u000a\u000a        self.server_onlineCheck_enabled = ko.observable();\u000a        self.server_onlineCheck_interval = ko.observable();\u000a        self.server_onlineCheck_host = ko.observable();\u000a        self.server_onlineCheck_port = ko.observable();\u000a        self.server_onlineCheck_name = ko.observable();\u000a\u000a        self.server_pluginBlacklist_enabled = ko.observable();\u000a        self.server_pluginBlacklist_url = ko.observable();\u000a        self.server_pluginBlacklist_ttl = ko.observable();\u000a\u000a        self.server_allowFraming = ko.observable();\u000a\u000a        self.settings = undefined;\u000a        self.lastReceivedSettings = undefined;\u000a\u000a        self.webcam_ffmpegPathText = ko.observable();\u000a        self.webcam_ffmpegPathOk = ko.observable(false);\u000a        self.webcam_ffmpegPathBroken = ko.observable(false);\u000a        self.webcam_ffmpegPathReset = function () {\u000a            self.webcam_ffmpegPathText("");\u000a            self.webcam_ffmpegPathOk(false);\u000a            self.webcam_ffmpegPathBroken(false);\u000a        };\u000a\u000a        self.server_onlineCheckText = ko.observable();\u000a        self.server_onlineCheckOk = ko.observable(false);\u000a        self.server_onlineCheckBroken = ko.observable(false);\u000a        self.server_onlineCheckReset = function () {\u000a            self.server_onlineCheckText("");\u000a            self.server_onlineCheckOk(false);\u000a            self.server_onlineCheckBroken(false);\u000a        };\u000a        self.server_onlineCheckResolutionText = ko.observable();\u000a        self.server_onlineCheckResolutionOk = ko.observable(false);\u000a        self.server_onlineCheckResolutionBroken = ko.observable(false);\u000a        self.server_onlineCheckResolutionReset = function () {\u000a            self.server_onlineCheckResolutionText("");\u000a            self.server_onlineCheckResolutionOk(false);\u000a            self.server_onlineCheckResolutionBroken(false);\u000a        };\u000a\u000a        var folderTypes = ["uploads", "timelapse", "timelapseTmp", "logs", "watched"];\u000a\u000a        var checkForDuplicateFolders = function () {\u000a            _.each(folderTypes, function (folderType) {\u000a                var path = self["folder_" + folderType]();\u000a                var duplicate = false;\u000a                _.each(folderTypes, function (otherFolderType) {\u000a                    if (folderType !== otherFolderType) {\u000a                        duplicate =\u000a                            duplicate || path === self["folder_" + otherFolderType]();\u000a                    }\u000a                });\u000a                self.testFolderConfigDuplicate[folderType](duplicate);\u000a            });\u000a        };\u000a\u000a        self.testFolderConfigText = {};\u000a        self.testFolderConfigOk = {};\u000a        self.testFolderConfigBroken = {};\u000a        self.testFolderConfigDuplicate = {};\u000a        self.testFolderConfigError = {};\u000a        self.testFolderConfigSuccess = {};\u000a        _.each(folderTypes, function (folderType) {\u000a            self.testFolderConfigText[folderType] = ko.observable("");\u000a            self.testFolderConfigOk[folderType] = ko.observable(false);\u000a            self.testFolderConfigBroken[folderType] = ko.observable(false);\u000a            self.testFolderConfigDuplicate[folderType] = ko.observable(false);\u000a            self.testFolderConfigError[folderType] = ko.pureComputed(function () {\u000a                return (\u000a                    self.testFolderConfigBroken[folderType]() ||\u000a                    self.testFolderConfigDuplicate[folderType]()\u000a                );\u000a            });\u000a            self.testFolderConfigSuccess[folderType] = ko.pureComputed(function () {\u000a                return (\u000a                    self.testFolderConfigOk[folderType]() &&\u000a                    !self.testFolderConfigDuplicate[folderType]()\u000a                );\u000a            });\u000a            self["folder_" + folderType].subscribe(checkForDuplicateFolders);\u000a        });\u000a        self.testFolderConfigReset = function () {\u000a            _.each(folderTypes, function (folderType) {\u000a                self.testFolderConfigText[folderType]("");\u000a                self.testFolderConfigOk[folderType](false);\u000a                self.testFolderConfigBroken[folderType](false);\u000a            });\u000a        };\u000a        self.testFoldersDuplicate = ko.pureComputed(function () {\u000a            var foundDupe = false;\u000a            _.each(folderTypes, function (folderType) {\u000a                foundDupe = foundDupe || self.testFolderConfigDuplicate[folderType]();\u000a            });\u000a            return foundDupe;\u000a        });\u000a\u000a        self.observableCopies = {\u000a            feature_waitForStart: "serial_waitForStart",\u000a            feature_sendChecksum: "serial_sendChecksum",\u000a            feature_sdRelativePath: "serial_sdRelativePath",\u000a            feature_sdAlwaysAvailable: "serial_sdAlwaysAvailable",\u000a            feature_swallowOkAfterResend: "serial_swallowOkAfterResend",\u000a            feature_repetierTargetTemp: "serial_repetierTargetTemp",\u000a            feature_disableExternalHeatupDetection:\u000a                "serial_disableExternalHeatupDetection",\u000a            feature_ignoreIdenticalResends: "serial_ignoreIdenticalResends",\u000a            feature_firmwareDetection: "serial_firmwareDetection",\u000a            feature_blockWhileDwelling: "serial_blockWhileDwelling",\u000a            serial_: "feature_"\u000a        };\u000a        _.each(self.observableCopies, function (value, key) {\u000a            if (self.hasOwnProperty(value)) {\u000a                self[key] = self[value];\u000a            }\u000a        });\u000a\u000a        self.addTemperatureProfile = function () {\u000a            self.temperature_profiles.push({\u000a                name: "New",\u000a                extruder: 0,\u000a                bed: 0,\u000a                chamber: 0\u000a            });\u000a        };\u000a\u000a        self.removeTemperatureProfile = function (profile) {\u000a            self.temperature_profiles.remove(profile);\u000a        };\u000a\u000a        self.addTerminalFilter = function () {\u000a            self.terminalFilters.push({\u000a                name: "New",\u000a                regex: "(Send: (Nd+s+)?M105)|(Recv:s+(oks+)?.*(B|Td*):d+)"\u000a            });\u000a        };\u000a\u000a        self.removeTerminalFilter = function (filter) {\u000a            self.terminalFilters.remove(filter);\u000a        };\u000a\u000a        self.testWebcamStreamUrlBusy = ko.observable(false);\u000a        self.testWebcamStreamUrl = function () {\u000a            if (!self.webcam_streamUrl()) {\u000a                return;\u000a            }\u000a\u000a            if (self.testWebcamStreamUrlBusy()) {\u000a                return;\u000a            }\u000a\u000a            var text = gettext(\u000a                "If you see your webcam stream below, the entered stream URL is ok."\u000a            );\u000a            var streamType = determineWebcamStreamType(self.webcam_streamUrl());\u000a            var webcam_element;\u000a            if (streamType == "mjpg") {\u000a                webcam_element = $('<img src="' + self.webcam_streamUrl() + '">');\u000a            } else if (streamType == "hls") {\u000a                webcam_element = $(\u000a                    '<video id="webcam_hls" muted autoplay style="width: 100%"/>'\u000a                );\u000a                video_element = webcam_element[0];\u000a                if (video_element.canPlayType("application/vnd.apple.mpegurl")) {\u000a                    video_element.src = self.webcam_streamUrl();\u000a                } else if (Hls.isSupported()) {\u000a                    var hls = new Hls();\u000a                    hls.loadSource(self.webcam_streamUrl());\u000a                    hls.attachMedia(video_element);\u000a                }\u000a            } else {\u000a                throw "Unknown stream type " + streamType;\u000a            }\u000a\u000a            var message = $("<p></p>").append(text).append(webcam_element);\u000a\u000a            self.testWebcamStreamUrlBusy(true);\u000a            showMessageDialog({\u000a                title: gettext("Stream test"),\u000a                message: message,\u000a                onclose: function () {\u000a                    self.testWebcamStreamUrlBusy(false);\u000a                }\u000a            });\u000a        };\u000a\u000a        self.testWebcamSnapshotUrlBusy = ko.observable(false);\u000a        self.testWebcamSnapshotUrl = function (viewModel, event) {\u000a            if (!self.webcam_snapshotUrl()) {\u000a                return;\u000a            }\u000a\u000a            if (self.testWebcamSnapshotUrlBusy()) {\u000a                return;\u000a            }\u000a\u000a            var errorText = gettext(\u000a                "Could not retrieve snapshot URL, please double check the URL"\u000a            );\u000a            var errorTitle = gettext("Snapshot test failed");\u000a\u000a            self.testWebcamSnapshotUrlBusy(true);\u000a            OctoPrint.util\u000a                .testUrl(self.webcam_snapshotUrl(), {\u000a                    method: "GET",\u000a                    response: "bytes",\u000a                    timeout: self.webcam_snapshotTimeout(),\u000a                    validSsl: self.webcam_snapshotSslValidation(),\u000a                    content_type_whitelist: ["image/*"],\u000a                    content_type_guess: true\u000a                })\u000a                .done(function (response) {\u000a                    if (!response.result) {\u000a                        if (\u000a                            response.status &&\u000a                            response.response &&\u000a                            response.response.content_type\u000a                        ) {\u000a                            // we could contact the server, but something else was wrong, probably the mime type\u000a                            errorText = gettext(\u000a                                "Could retrieve the snapshot URL, but it didn't look like an " +\u000a                                    "image. Got this as a content type header: <code>%(content_type)s</code>. Please " +\u000a                                    "double check that the URL is returning static images, not multipart data " +\u000a                                    "or videos."\u000a                            );\u000a                            errorText = _.sprintf(errorText, {\u000a                                content_type: _.escape(response.response.content_type)\u000a                            });\u000a                        }\u000a\u000a                        showMessageDialog({\u000a                            title: errorTitle,\u000a                            message: errorText,\u000a                            onclose: function () {\u000a                                self.testWebcamSnapshotUrlBusy(false);\u000a                            }\u000a                        });\u000a                        return;\u000a                    }\u000a\u000a                    var content = response.response.content;\u000a                    var contentType = response.response.assumed_content_type;\u000a\u000a                    var mimeType = "image/jpeg";\u000a                    if (contentType) {\u000a                        mimeType = contentType.split(";")[0];\u000a                    }\u000a\u000a                    var text = gettext(\u000a                        "If you see your webcam snapshot picture below, the entered snapshot URL is ok."\u000a                    );\u000a                    showMessageDialog({\u000a                        title: gettext("Snapshot test"),\u000a                        message: $(\u000a                            "<p>" +\u000a                                text +\u000a                                '</p><p><img src="data:' +\u000a                                mimeType +\u000a                                ";base64," +\u000a                                content +\u000a                                '" style="border: 1px solid black" /></p>'\u000a                        ),\u000a                        onclose: function () {\u000a                            self.testWebcamSnapshotUrlBusy(false);\u000a                        }\u000a                    });\u000a                })\u000a                .fail(function () {\u000a                    showMessageDialog({\u000a                        title: errorTitle,\u000a                        message: errorText,\u000a                        onclose: function () {\u000a                            self.testWebcamSnapshotUrlBusy(false);\u000a                        }\u000a                    });\u000a                });\u000a        };\u000a\u000a        self.testWebcamFfmpegPathBusy = ko.observable(false);\u000a        self.testWebcamFfmpegPath = function () {\u000a            if (!self.webcam_ffmpegPath()) {\u000a                return;\u000a            }\u000a\u000a            if (self.testWebcamFfmpegPathBusy()) {\u000a                return;\u000a            }\u000a\u000a            self.testWebcamFfmpegPathBusy(true);\u000a            OctoPrint.util\u000a                .testExecutable(self.webcam_ffmpegPath())\u000a                .done(function (response) {\u000a                    if (!response.result) {\u000a                        if (!response.exists) {\u000a                            self.webcam_ffmpegPathText(gettext("The path doesn't exist"));\u000a                        } else if (!response.typeok) {\u000a                            self.webcam_ffmpegPathText(gettext("The path is not a file"));\u000a                        } else if (!response.access) {\u000a                            self.webcam_ffmpegPathText(\u000a                                gettext("The path is not an executable")\u000a                            );\u000a                        }\u000a                    } else {\u000a                        self.webcam_ffmpegPathText(gettext("The path is valid"));\u000a                    }\u000a                    self.webcam_ffmpegPathOk(response.result);\u000a                    self.webcam_ffmpegPathBroken(!response.result);\u000a                })\u000a                .always(function () {\u000a                    self.testWebcamFfmpegPathBusy(false);\u000a                });\u000a        };\u000a\u000a        self.testOnlineConnectivityConfigBusy = ko.observable(false);\u000a        self.testOnlineConnectivityConfig = function () {\u000a            if (!self.server_onlineCheck_host()) return;\u000a            if (!self.server_onlineCheck_port()) return;\u000a            if (self.testOnlineConnectivityConfigBusy()) return;\u000a\u000a            self.testOnlineConnectivityConfigBusy(true);\u000a            OctoPrint.util\u000a                .testServer(\u000a                    self.server_onlineCheck_host(),\u000a                    self.server_onlineCheck_port()\u000a                )\u000a                .done(function (response) {\u000a                    if (!response.result) {\u000a                        self.server_onlineCheckText(\u000a                            gettext("The server is not reachable")\u000a                        );\u000a                    } else {\u000a                        self.server_onlineCheckText(gettext("The server is reachable"));\u000a                    }\u000a                    self.server_onlineCheckOk(response.result);\u000a                    self.server_onlineCheckBroken(!response.result);\u000a                })\u000a                .always(function () {\u000a                    self.testOnlineConnectivityConfigBusy(false);\u000a                });\u000a        };\u000a\u000a        self.testOnlineConnectivityResolutionConfigBusy = ko.observable(false);\u000a        self.testOnlineConnectivityResolutionConfig = function () {\u000a            if (!self.server_onlineCheck_name()) return;\u000a            if (self.testOnlineConnectivityResolutionConfigBusy()) return;\u000a\u000a            self.testOnlineConnectivityResolutionConfigBusy(true);\u000a            OctoPrint.util\u000a                .testResolution(self.server_onlineCheck_name())\u000a                .done(function (response) {\u000a                    if (!response.result) {\u000a                        self.server_onlineCheckResolutionText(\u000a                            gettext("Name cannot be resolved")\u000a                        );\u000a                    } else {\u000a                        self.server_onlineCheckResolutionText(\u000a                            gettext("Name can be resolved")\u000a                        );\u000a                    }\u000a                    self.server_onlineCheckResolutionOk(response.result);\u000a                    self.server_onlineCheckResolutionBroken(!response.result);\u000a                })\u000a                .always(function () {\u000a                    self.testOnlineConnectivityResolutionConfigBusy(false);\u000a                });\u000a        };\u000a\u000a        self.testFolderConfigBusy = ko.observable(false);\u000a        self.testFolderConfig = function (folder) {\u000a            var observable = "folder_" + folder;\u000a            if (!self.hasOwnProperty(observable)) return;\u000a\u000a            if (self.testFolderConfigBusy()) return;\u000a            self.testFolderConfigBusy(true);\u000a\u000a            var opts = {\u000a                check_type: "dir",\u000a                check_access: "w",\u000a                allow_create_dir: true,\u000a                check_writable_dir: true\u000a            };\u000a            var path = self[observable]();\u000a            OctoPrint.util\u000a                .testPath(path, opts)\u000a                .done(function (response) {\u000a                    if (!response.result) {\u000a                        if (response.broken_symlink) {\u000a                            self.testFolderConfigText[folder](\u000a                                gettext("The path is a broken symlink.")\u000a                            );\u000a                        } else if (!response.exists) {\u000a                            self.testFolderConfigText[folder](\u000a                                gettext("The path does not exist and cannot be created.")\u000a                            );\u000a                        } else if (!response.typeok) {\u000a                            self.testFolderConfigText[folder](\u000a                                gettext("The path is not a folder.")\u000a                            );\u000a                        } else if (!response.access) {\u000a                            self.testFolderConfigText[folder](\u000a                                gettext("The path is not writable.")\u000a                            );\u000a                        }\u000a                    } else {\u000a                        self.testFolderConfigText[folder](gettext("The path is valid"));\u000a                    }\u000a                    self.testFolderConfigOk[folder](response.result);\u000a                    self.testFolderConfigBroken[folder](!response.result);\u000a                })\u000a                .always(function () {\u000a                    self.testFolderConfigBusy(false);\u000a                });\u000a        };\u000a\u000a        self.onSettingsHidden = function () {\u000a            self.webcam_ffmpegPathReset();\u000a            self.server_onlineCheckReset();\u000a            self.server_onlineCheckResolutionReset();\u000a            self.testFolderConfigReset();\u000a        };\u000a\u000a        self.isDialogActive = function () {\u000a            return self.settingsDialog.is(":visible");\u000a        };\u000a\u000a        self.onStartup = function () {\u000a            self.settingsDialog = $("#settings_dialog");\u000a            self.settingsUpdatedDialog = $("#settings_dialog_update_detected");\u000a            self.translationManagerDialog = $(\u000a                "#settings_appearance_managelanguagesdialog"\u000a            );\u000a            self.translationUploadElement = $(\u000a                "#settings_appearance_managelanguagesdialog_upload"\u000a            );\u000a            self.translationUploadButton = $(\u000a                "#settings_appearance_managelanguagesdialog_upload_start"\u000a            );\u000a\u000a            self.translationUploadElement.fileupload({\u000a                dataType: "json",\u000a                maxNumberOfFiles: 1,\u000a                autoUpload: false,\u000a                headers: OctoPrint.getRequestHeaders(),\u000a                add: function (e, data) {\u000a                    if (data.files.length == 0) {\u000a                        return false;\u000a                    }\u000a\u000a                    self.translationUploadFilename(data.files[0].name);\u000a\u000a                    self.translationUploadButton.unbind("click");\u000a                    self.translationUploadButton.bind("click", function () {\u000a                        data.submit();\u000a                        return false;\u000a                    });\u000a                },\u000a                done: function (e, data) {\u000a                    self.translationUploadButton.unbind("click");\u000a                    self.translationUploadFilename(undefined);\u000a                    self.fromTranslationResponse(data.result);\u000a                },\u000a                fail: function (e, data) {\u000a                    self.translationUploadButton.unbind("click");\u000a                    self.translationUploadFilename(undefined);\u000a                }\u000a            });\u000a        };\u000a\u000a        self.onAllBound = function (allViewModels) {\u000a            self.allViewModels = allViewModels;\u000a\u000a            self.settingsDialog.on("show", function (event) {\u000a                OctoPrint.coreui.settingsOpen = true;\u000a                if (event.target.id == "settings_dialog") {\u000a                    self.requestTranslationData();\u000a                    callViewModels(allViewModels, "onSettingsShown");\u000a                }\u000a            });\u000a            self.settingsDialog.on("hidden", function (event) {\u000a                OctoPrint.coreui.settingsOpen = false;\u000a                if (event.target.id == "settings_dialog") {\u000a                    callViewModels(allViewModels, "onSettingsHidden");\u000a                }\u000a            });\u000a            self.settingsDialog.on("beforeSave", function () {\u000a                callViewModels(allViewModels, "onSettingsBeforeSave");\u000a            });\u000a\u000a            $(".reload_all", self.settingsUpdatedDialog).click(function (e) {\u000a                e.preventDefault();\u000a                self.settingsUpdatedDialog.modal("hide");\u000a                self.requestData();\u000a                return false;\u000a            });\u000a            $(".reload_nonconflicts", self.settingsUpdatedDialog).click(function (e) {\u000a                e.preventDefault();\u000a                self.settingsUpdatedDialog.modal("hide");\u000a                self.requestData(undefined, true);\u000a                return false;\u000a            });\u000a\u000a            // reset scroll position on tab change\u000a            $('ul.nav-list a[data-toggle="tab"]', self.settingsDialog).on(\u000a                "show",\u000a                function () {\u000a                    self._resetScrollPosition();\u000a                }\u000a            );\u000a        };\u000a\u000a        self.show = function (tab) {\u000a            // select first or specified tab\u000a            self.selectTab(tab);\u000a\u000a            // reset scroll position\u000a            self._resetScrollPosition();\u000a\u000a            // show settings, ensure centered position\u000a            self.settingsDialog\u000a                .modal({\u000a                    minHeight: function () {\u000a                        return Math.max($.fn.modal.defaults.maxHeight() - 80, 250);\u000a                    }\u000a                })\u000a                .css({\u000a                    "width": "auto",\u000a                    "margin-left": function () {\u000a                        return -($(this).width() / 2);\u000a                    }\u000a                });\u000a\u000a            return false;\u000a        };\u000a\u000a        self.hide = function () {\u000a            self.settingsDialog.modal("hide");\u000a        };\u000a\u000a        self.generateApiKey = function () {\u000a            if (!CONFIG_ACCESS_CONTROL) return;\u000a\u000a            showConfirmationDialog(\u000a                gettext(\u000a                    "This will generate a new API Key. The old API Key will cease to function immediately."\u000a                ),\u000a                function () {\u000a                    OctoPrint.settings.generateApiKey().done(function (response) {\u000a                        self.api_key(response.apikey);\u000a                        self.requestData();\u000a                    });\u000a                }\u000a            );\u000a        };\u000a\u000a        self.copyApiKey = function () {\u000a            copyToClipboard(self.api_key());\u000a        };\u000a\u000a        self.showTranslationManager = function () {\u000a            self.translationManagerDialog.modal();\u000a            return false;\u000a        };\u000a\u000a        self.requestData = function (local) {\u000a            // handle old parameter format\u000a            var callback = undefined;\u000a            if (arguments.length == 2 || _.isFunction(local)) {\u000a                var exc = new Error();\u000a                log.warn(\u000a                    "The callback parameter of SettingsViewModel.requestData is deprecated, the method now returns a promise, please use that instead. Stacktrace:",\u000a                    exc.stack || exc.stacktrace || "<n/a>"\u000a                );\u000a\u000a                if (arguments.length == 2) {\u000a                    callback = arguments[0];\u000a                    local = arguments[1];\u000a                } else {\u000a                    callback = local;\u000a                    local = false;\u000a                }\u000a            }\u000a\u000a            // handler for any explicitly provided callbacks\u000a            var callbackHandler = function () {\u000a                if (!callback) return;\u000a                try {\u000a                    callback();\u000a                } catch (exc) {\u000a                    log.error(\u000a                        "Error calling settings callback",\u000a                        callback,\u000a                        ":",\u000a                        exc.stack || exc.stacktrace || exc\u000a                    );\u000a                }\u000a            };\u000a\u000a            // if a request is already active, create a new deferred and return\u000a            // its promise, it will be resolved in the response handler of the\u000a            // current request\u000a            if (self.receiving()) {\u000a                var deferred = $.Deferred();\u000a                self.outstanding.push(deferred);\u000a\u000a                if (callback) {\u000a                    // if we have a callback, we need to make sure it will\u000a                    // get called when the deferred is resolved\u000a                    deferred.done(callbackHandler);\u000a                }\u000a\u000a                return deferred.promise();\u000a            }\u000a\u000a            // perform the request\u000a            self.receiving(true);\u000a            return OctoPrint.settings\u000a                .get()\u000a                .always(function () {\u000a                    self.receiving(false);\u000a                })\u000a                .done(function (response) {\u000a                    self.fromResponse(response, local);\u000a\u000a                    if (callback) {\u000a                        var deferred = $.Deferred();\u000a                        deferred.done(callbackHandler);\u000a                        self.outstanding.push(deferred);\u000a                    }\u000a\u000a                    // resolve all promises\u000a                    var args = arguments;\u000a                    _.each(self.outstanding, function (deferred) {\u000a                        deferred.resolve(args);\u000a                    });\u000a                    self.outstanding = [];\u000a                })\u000a                .fail(function () {\u000a                    // reject all promises\u000a                    var args = arguments;\u000a                    _.each(self.outstanding, function (deferred) {\u000a                        deferred.reject(args);\u000a                    });\u000a                    self.outstanding = [];\u000a                });\u000a        };\u000a\u000a        self.requestTranslationData = function () {\u000a            return OctoPrint.languages.list().done(self.fromTranslationResponse);\u000a        };\u000a\u000a        self.fromTranslationResponse = function (response) {\u000a            var translationsByLocale = {};\u000a            _.each(response.language_packs, function (item, key) {\u000a                _.each(item.languages, function (pack) {\u000a                    var locale = pack.locale;\u000a                    if (!_.has(translationsByLocale, locale)) {\u000a                        translationsByLocale[locale] = {\u000a                            locale: locale,\u000a                            display: pack.locale_display,\u000a                            english: pack.locale_english,\u000a                            packs: []\u000a                        };\u000a                    }\u000a\u000a                    translationsByLocale[locale]["packs"].push({\u000a                        identifier: key,\u000a                        display: item.display,\u000a                        pack: pack\u000a                    });\u000a                });\u000a            });\u000a\u000a            var translations = [];\u000a            _.each(translationsByLocale, function (item) {\u000a                item["packs"].sort(function (a, b) {\u000a                    if (a.identifier == "_core") return -1;\u000a                    if (b.identifier == "_core") return 1;\u000a\u000a                    if (a.display < b.display) return -1;\u000a                    if (a.display > b.display) return 1;\u000a                    return 0;\u000a                });\u000a                translations.push(item);\u000a            });\u000a\u000a            self.translations.updateItems(translations);\u000a        };\u000a\u000a        self.languagePackDisplay = function (item) {\u000a            return (\u000a                item.display +\u000a                (item.english != undefined ? " (" + item.english + ")" : "")\u000a            );\u000a        };\u000a\u000a        self.languagePacksAvailable = ko.pureComputed(function () {\u000a            return self.translations.allSize() > 0;\u000a        });\u000a\u000a        self.deleteLanguagePack = function (locale, pack) {\u000a            OctoPrint.languages.delete(locale, pack).done(self.fromTranslationResponse);\u000a        };\u000a\u000a        /**\u000a         * Fetches the settings as currently stored in this client instance.\u000a         */\u000a        self.getLocalData = function () {\u000a            var data = {};\u000a            if (self.settings != undefined) {\u000a                data = ko.mapping.toJS(self.settings);\u000a            }\u000a\u000a            // some special read functions for various observables\u000a            var specialMappings = {\u000a                feature: {\u000a                    autoUppercaseBlacklist: function () {\u000a                        return splitTextToArray(\u000a                            self.feature_autoUppercaseBlacklist(),\u000a                            ",",\u000a                            true\u000a                        );\u000a                    }\u000a                },\u000a                serial: {\u000a                    additionalPorts: function () {\u000a                        return commentableLinesToArray(self.serial_additionalPorts());\u000a                    },\u000a                    additionalBaudrates: function () {\u000a                        return _.map(\u000a                            splitTextToArray(\u000a                                self.serial_additionalBaudrates(),\u000a                                ",",\u000a                                true,\u000a                                function (item) {\u000a                                    return !isNaN(parseInt(item));\u000a                                }\u000a                            ),\u000a                            function (item) {\u000a                                return parseInt(item);\u000a                            }\u000a                        );\u000a                    },\u000a                    blacklistedPorts: function () {\u000a                        return commentableLinesToArray(self.serial_blacklistedPorts());\u000a                    },\u000a                    blacklistedBaudrates: function () {\u000a                        return _.map(\u000a                            splitTextToArray(\u000a                                self.serial_blacklistedBaudrates(),\u000a                                ",",\u000a                                true,\u000a                                function (item) {\u000a                                    return !isNaN(parseInt(item));\u000a                                }\u000a                            ),\u000a                            function (item) {\u000a                                return parseInt(item);\u000a                            }\u000a                        );\u000a                    },\u000a                    longRunningCommands: function () {\u000a                        return splitTextToArray(\u000a                            self.serial_longRunningCommands(),\u000a                            ",",\u000a                            true\u000a                        );\u000a                    },\u000a                    checksumRequiringCommands: function () {\u000a                        return splitTextToArray(\u000a                            self.serial_checksumRequiringCommands(),\u000a                            ",",\u000a                            true\u000a                        );\u000a                    },\u000a                    blockedCommands: function () {\u000a                        return splitTextToArray(self.serial_blockedCommands(), ",", true);\u000a                    },\u000a                    pausingCommands: function () {\u000a                        return splitTextToArray(self.serial_pausingCommands(), ",", true);\u000a                    },\u000a                    emergencyCommands: function () {\u000a                        return splitTextToArray(\u000a                            self.serial_emergencyCommands(),\u000a                            ",",\u000a                            true\u000a                        );\u000a                    },\u000a                    externalHeatupDetection: function () {\u000a                        return !self.serial_disableExternalHeatupDetection();\u000a                    },\u000a                    alwaysSendChecksum: function () {\u000a                        return self.serial_sendChecksum() === "always";\u000a                    },\u000a                    neverSendChecksum: function () {\u000a                        return self.serial_sendChecksum() === "never";\u000a                    },\u000a                    ignoreErrorsFromFirmware: function () {\u000a                        return self.serial_serialErrorBehaviour() === "ignore";\u000a                    },\u000a                    disconnectOnErrors: function () {\u000a                        return self.serial_serialErrorBehaviour() === "disconnect";\u000a                    }\u000a                },\u000a                scripts: {\u000a                    gcode: function () {\u000a                        // we have a special handler function for the gcode scripts since the\u000a                        // server will always send us those that have been set already, so we\u000a                        // can't depend on all keys that we support to be present in the\u000a                        // original request we iterate through in mapFromObservables to\u000a                        // generate our response - hence we use our observables instead\u000a                        //\u000a                        // Note: If we ever introduce sub categories in the gcode scripts\u000a                        // here (more _ after the prefix), we'll need to adjust this code\u000a                        // to be able to cope with that, right now it only strips the prefix\u000a                        // and uses the rest as key in the result, no recursive translation\u000a                        // is done!\u000a                        var result = {};\u000a                        var prefix = "scripts_gcode_";\u000a                        var observables = _.filter(_.keys(self), function (key) {\u000a                            return _.startsWith(key, prefix);\u000a                        });\u000a                        _.each(observables, function (observable) {\u000a                            var script = observable.substring(prefix.length);\u000a                            result[script] = self[observable]();\u000a                        });\u000a                        return result;\u000a                    }\u000a                },\u000a                temperature: {\u000a                    profiles: function () {\u000a                        var result = [];\u000a                        _.each(self.temperature_profiles(), function (profile) {\u000a                            try {\u000a                                result.push({\u000a                                    name: profile.name,\u000a                                    extruder: Math.floor(\u000a                                        _.isNumber(profile.extruder)\u000a                                            ? profile.extruder\u000a                                            : parseInt(profile.extruder)\u000a                                    ),\u000a                                    bed: Math.floor(\u000a                                        _.isNumber(profile.bed)\u000a                                            ? profile.bed\u000a                                            : parseInt(profile.bed)\u000a                                    ),\u000a                                    chamber: Math.floor(\u000a                                        _.isNumber(profile.chamber)\u000a                                            ? profile.chamber\u000a                                            : _.isNumber(parseInt(profile.chamber))\u000a                                            ? parseInt(profile.chamber)\u000a                                            : 0\u000a                                    )\u000a                                });\u000a                            } catch (ex) {\u000a                                // ignore\u000a                            }\u000a                        });\u000a                        return result;\u000a                    }\u000a                }\u000a            };\u000a\u000a            var mapFromObservables = function (data, mapping, keyPrefix) {\u000a                var flag = false;\u000a                var result = {};\u000a\u000a                // process all key-value-pairs here\u000a                _.forOwn(data, function (value, key) {\u000a                    var observable = key;\u000a                    if (keyPrefix !== undefined) {\u000a                        observable = keyPrefix + "_" + observable;\u000a                    }\u000a\u000a                    if (self.observableCopies.hasOwnProperty(observable)) {\u000a                        // only a copy, skip\u000a                        return;\u000a                    }\u000a\u000a                    if (mapping && mapping[key] && _.isFunction(mapping[key])) {\u000a                        result[key] = mapping[key]();\u000a                        flag = true;\u000a                    } else if (_.isPlainObject(value)) {\u000a                        // value is another object, we'll dive deeper\u000a                        var subresult = mapFromObservables(\u000a                            value,\u000a                            mapping && mapping[key] ? mapping[key] : undefined,\u000a                            observable\u000a                        );\u000a                        if (subresult !== undefined) {\u000a                            // we only set something on our result if we got something back\u000a                            result[key] = subresult;\u000a                            flag = true;\u000a                        }\u000a                    } else if (self.hasOwnProperty(observable)) {\u000a                        result[key] = self[observable]();\u000a                        flag = true;\u000a                    }\u000a                });\u000a\u000a                // if we set something on our result (flag is true), we return result, else we return undefined\u000a                return flag ? result : undefined;\u000a            };\u000a\u000a            // map local observables based on our existing data\u000a            var dataFromObservables = mapFromObservables(data, specialMappings);\u000a\u000a            data = deepMerge(data, dataFromObservables);\u000a            return data;\u000a        };\u000a\u000a        self.fromResponse = function (response, local) {\u000a            // server side changes to set\u000a            var serverChangedData;\u000a\u000a            // client side changes to keep\u000a            var clientChangedData;\u000a\u000a            if (local) {\u000a                // local is true, so we'll keep all local changes and only update what's been updated server side\u000a                serverChangedData = getOnlyChangedData(\u000a                    response,\u000a                    self.lastReceivedSettings\u000a                );\u000a                clientChangedData = getOnlyChangedData(\u000a                    self.getLocalData(),\u000a                    self.lastReceivedSettings\u000a                );\u000a            } else {\u000a                // local is false or unset, so we'll forcefully update with the settings from the server\u000a                serverChangedData = response;\u000a                clientChangedData = undefined;\u000a            }\u000a\u000a            // last received settings reset to response\u000a            self.lastReceivedSettings = response;\u000a\u000a            if (self.settings === undefined) {\u000a                self.settings = ko.mapping.fromJS(serverChangedData);\u000a            } else {\u000a                ko.mapping.fromJS(serverChangedData, self.settings);\u000a            }\u000a\u000a            // some special apply functions for various observables\u000a            var specialMappings = {\u000a                appearance: {\u000a                    defaultLanguage: function (value) {\u000a                        self.appearance_defaultLanguage("_default");\u000a                        if (_.includes(self.locale_languages, value)) {\u000a                            self.appearance_defaultLanguage(value);\u000a                        }\u000a                    }\u000a                },\u000a                feature: {\u000a                    autoUppercaseBlacklist: function (value) {\u000a                        self.feature_autoUppercaseBlacklist(value.join(", "));\u000a                    }\u000a                },\u000a                serial: {\u000a                    additionalPorts: function (value) {\u000a                        self.serial_additionalPorts(value.join("\u005cn"));\u000a                    },\u000a                    additionalBaudrates: function (value) {\u000a                        self.serial_additionalBaudrates(value.join(", "));\u000a                    },\u000a                    blacklistedPorts: function (value) {\u000a                        self.serial_blacklistedPorts(value.join("\u005cn"));\u000a                    },\u000a                    blacklistedBaudrates: function (value) {\u000a                        self.serial_blacklistedBaudrates(value.join(", "));\u000a                    },\u000a                    longRunningCommands: function (value) {\u000a                        self.serial_longRunningCommands(value.join(", "));\u000a                    },\u000a                    checksumRequiringCommands: function (value) {\u000a                        self.serial_checksumRequiringCommands(value.join(", "));\u000a                    },\u000a                    blockedCommands: function (value) {\u000a                        self.serial_blockedCommands(value.join(", "));\u000a                    },\u000a                    pausingCommands: function (value) {\u000a                        self.serial_pausingCommands(value.join(", "));\u000a                    },\u000a                    emergencyCommands: function (value) {\u000a                        self.serial_emergencyCommands(value.join(", "));\u000a                    },\u000a                    externalHeatupDetection: function (value) {\u000a                        self.serial_disableExternalHeatupDetection(!value);\u000a                    },\u000a                    alwaysSendChecksum: function (value) {\u000a                        if (value) {\u000a                            self.serial_sendChecksum("always");\u000a                        }\u000a                    },\u000a                    neverSendChecksum: function (value) {\u000a                        if (value) {\u000a                            self.serial_sendChecksum("never");\u000a                        }\u000a                    },\u000a                    ignoreErrorsFromFirmware: function (value) {\u000a                        if (value) {\u000a                            self.serial_serialErrorBehaviour("ignore");\u000a                        }\u000a                    },\u000a                    disconnectOnErrors: function (value) {\u000a                        if (value) {\u000a                            self.serial_serialErrorBehaviour("disconnect");\u000a                        }\u000a                    }\u000a                },\u000a                terminalFilters: function (value) {\u000a                    self.terminalFilters($.extend(true, [], value));\u000a                },\u000a                temperature: {\u000a                    profiles: function (value) {\u000a                        self.temperature_profiles($.extend(true, [], value));\u000a                    }\u000a                }\u000a            };\u000a\u000a            var mapToObservables = function (data, mapping, local, keyPrefix) {\u000a                if (!_.isPlainObject(data)) {\u000a                    return;\u000a                }\u000a\u000a                // process all key-value-pairs here\u000a                _.forOwn(data, function (value, key) {\u000a                    var observable = key;\u000a                    if (keyPrefix != undefined) {\u000a                        observable = keyPrefix + "_" + observable;\u000a                    }\u000a\u000a                    if (self.observableCopies.hasOwnProperty(observable)) {\u000a                        // only a copy, skip\u000a                        return;\u000a                    }\u000a\u000a                    var haveLocalVersion = local && local.hasOwnProperty(key);\u000a\u000a                    if (\u000a                        mapping &&\u000a                        mapping[key] &&\u000a                        _.isFunction(mapping[key]) &&\u000a                        !haveLocalVersion\u000a                    ) {\u000a                        // if we have a custom apply function for this, we'll use it\u000a                        mapping[key](value);\u000a                    } else if (_.isPlainObject(value)) {\u000a                        // value is another object, we'll dive deeper\u000a                        mapToObservables(\u000a                            value,\u000a                            mapping && mapping[key] ? mapping[key] : undefined,\u000a                            local && local[key] ? local[key] : undefined,\u000a                            observable\u000a                        );\u000a                    } else if (!haveLocalVersion && self.hasOwnProperty(observable)) {\u000a                        // if we have a matching observable, we'll use that\u000a                        self[observable](value);\u000a                    }\u000a                });\u000a            };\u000a\u000a            mapToObservables(serverChangedData, specialMappings, clientChangedData);\u000a\u000a            firstRequest.resolve();\u000a        };\u000a\u000a        self.cancelData = function () {\u000a            // revert unsaved changes\u000a            self.fromResponse(self.lastReceivedSettings);\u000a\u000a            self.hide();\u000a        };\u000a\u000a        self.saveData = function (data, successCallback, setAsSending) {\u000a            var options;\u000a            if (_.isPlainObject(successCallback)) {\u000a                options = successCallback;\u000a            } else {\u000a                options = {\u000a                    success: successCallback,\u000a                    sending: setAsSending === true\u000a                };\u000a            }\u000a\u000a            self.settingsDialog.trigger("beforeSave");\u000a\u000a            self.sawUpdateEventWhileSending = false;\u000a            self.sending(data === undefined || options.sending || false);\u000a\u000a            if (data === undefined) {\u000a                // we also only send data that actually changed when no data is specified\u000a                var localData = self.getLocalData();\u000a                data = getOnlyChangedData(localData, self.lastReceivedSettings);\u000a            }\u000a\u000a            // final validation\u000a            if (self.testFoldersDuplicate()) {\u000a                // duplicate folders configured, we refuse to send any folder config\u000a                // to the server\u000a                delete data.folder;\u000a            }\u000a\u000a            self.active = true;\u000a            return OctoPrint.settings\u000a                .save(data)\u000a                .done(function (data, status, xhr) {\u000a                    self.ignoreNextUpdateEvent = !self.sawUpdateEventWhileSending;\u000a                    self.active = false;\u000a\u000a                    self.receiving(true);\u000a                    self.sending(false);\u000a\u000a                    try {\u000a                        self.fromResponse(data);\u000a                        if (options.success) options.success(data, status, xhr);\u000a                    } finally {\u000a                        self.receiving(false);\u000a                    }\u000a                })\u000a                .fail(function (xhr, status, error) {\u000a                    self.sending(false);\u000a                    self.active = false;\u000a                    if (options.error) options.error(xhr, status, error);\u000a                })\u000a                .always(function (xhr, status) {\u000a                    if (options.complete) options.complete(xhr, status);\u000a                });\u000a        };\u000a\u000a        self.onEventSettingsUpdated = function () {\u000a            if (self.active) {\u000a                self.sawUpdateEventWhileActive = true;\u000a            }\u000a\u000a            var preventSettingsRefresh = _.any(self.allViewModels, function (viewModel) {\u000a                if (viewModel.hasOwnProperty("onSettingsPreventRefresh")) {\u000a                    try {\u000a                        return viewModel["onSettingsPreventRefresh"]();\u000a                    } catch (e) {\u000a                        log.warn(\u000a                            "Error while calling onSettingsPreventRefresh on",\u000a                            viewModel,\u000a                            ":",\u000a                            e\u000a                        );\u000a                        return false;\u000a                    }\u000a                } else {\u000a                    return false;\u000a                }\u000a            });\u000a\u000a            if (preventSettingsRefresh) {\u000a                // if any of our viewmodels prevented this refresh, we'll just return now\u000a                return;\u000a            }\u000a\u000a            if (self.isDialogActive()) {\u000a                // dialog is open and not currently busy...\u000a                if (\u000a                    self.sending() ||\u000a                    self.receiving() ||\u000a                    self.active ||\u000a                    self.ignoreNextUpdateEvent\u000a                ) {\u000a                    self.ignoreNextUpdateEvent = false;\u000a                    return;\u000a                }\u000a\u000a                if (!hasDataChanged(self.getLocalData(), self.lastReceivedSettings)) {\u000a                    // we don't have local changes, so just fetch new data\u000a                    self.requestData();\u000a                } else {\u000a                    // we have local changes, show update dialog\u000a                    self.settingsUpdatedDialog.modal("show");\u000a                }\u000a            } else {\u000a                // dialog is not open, just fetch new data\u000a                self.requestData();\u000a            }\u000a        };\u000a\u000a        self._resetScrollPosition = function () {\u000a            $("#settings_dialog_content", self.settingsDialog).scrollTop(0);\u000a\u000a            // also reset any contained tabs/pills/lists to first pane\u000a            $(\u000a                '#settings_dialog_content ul.nav-pills a[data-toggle="tab"]:first',\u000a                self.settingsDialog\u000a            ).tab("show");\u000a            $(\u000a                '#settings_dialog_content ul.nav-list a[data-toggle="tab"]:first',\u000a                self.settingsDialog\u000a            ).tab("show");\u000a            $(\u000a                '#settings_dialog_content ul.nav-tabs a[data-toggle="tab"]:first',\u000a                self.settingsDialog\u000a            ).tab("show");\u000a        };\u000a\u000a        self.selectTab = function (tab) {\u000a            if (tab != undefined) {\u000a                if (!_.startsWith(tab, "#")) {\u000a                    tab = "#" + tab;\u000a                }\u000a                $('ul.nav-list a[href="' + tab + '"]', self.settingsDialog).tab("show");\u000a            } else {\u000a                $('ul.nav-list a[data-toggle="tab"]:first', self.settingsDialog).tab(\u000a                    "show"\u000a                );\u000a            }\u000a        };\u000a\u000a        self.onServerReconnect = function () {\u000a            // the settings might have changed if the server was just restarted,\u000a            // better refresh them now\u000a            self.requestData();\u000a        };\u000a\u000a        self.onUserPermissionsChanged = self.onUserLoggedIn = self.onUserLoggedOut = function () {\u000a            // we might have other user rights now, refresh (but only if startup has fully completed)\u000a            if (!self._startupComplete) return;\u000a            self.requestData();\u000a        };\u000a    }\u000a\u000a    OCTOPRINT_VIEWMODELS.push({\u000a        construct: SettingsViewModel,\u000a        dependencies: [\u000a            "loginStateViewModel",\u000a            "accessViewModel",\u000a            "printerProfilesViewModel",\u000a            "aboutViewModel",\u000a            "usersViewModel"\u000a        ],\u000a        elements: ["#settings_dialog", "#navbar_settings"]\u000a    });\u000a});\u000a\u000a;\u000a
p0
.