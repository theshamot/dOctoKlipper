V// source: plugin/gcodeviewer/js/viewer/renderer.js\u000a/**\u000a * User: hudbrog (hudbrog@gmail.com)\u000a * Date: 10/20/12\u000a * Time: 1:36 PM\u000a * To change this template use File | Settings | File Templates.\u000a */\u000a\u000aGCODE.renderer = (function () {\u000a    // ***** PRIVATE ******\u000a    var canvas;\u000a    var ctx;\u000a\u000a    var viewportChanged = true;\u000a    var lineWidthFactor = 1 / 2.8;\u000a\u000a    var zoomFactorDelta = 0.4;\u000a    var gridStep = 10;\u000a    var ctxHeight, ctxWidth;\u000a    var prevX = 0,\u000a        prevY = 0;\u000a    var pixelRatio = window.devicePixelRatio || 1;\u000a\u000a    var layerNumStore,\u000a        progressStore = {from: 0, to: -1};\u000a    var lastX, lastY;\u000a    var dragStart;\u000a    var scaleFactor = 1.1;\u000a    var model = undefined;\u000a    var modelInfo = undefined;\u000a    var initialized = false;\u000a    var renderOptions = {\u000a        colorGrid: "#bbbbbb",\u000a        bgColorGrid: "#ffffff",\u000a        bgColorOffGrid: "#eeeeee",\u000a        colorLine: ["#000000", "#3333cc", "#cc3333", "#33cc33", "#cc33cc"],\u000a        colorMove: "#00ff00",\u000a        colorRetract: "#ff0000",\u000a        colorRestart: "#0000ff",\u000a        colorHead: "#00ff00",\u000a\u000a        showMoves: true,\u000a        showRetracts: true,\u000a        extrusionWidth: 1 * pixelRatio,\u000a        // #000000", "#45c7ba",  "#a9533a", "#ff44cc", "#dd1177", "#eeee22", "#ffbb55", "#ff5511", "#777788"\u000a        sizeRetractSpot: 2 * pixelRatio,\u000a        sizeHeadSpot: 2 * pixelRatio,\u000a        modelCenter: {x: 0, y: 0},\u000a        differentiateColors: true,\u000a        showNextLayer: false,\u000a        showCurrentLayer: false,\u000a        showPreviousLayer: false,\u000a        showBoundingBox: false,\u000a        showFullSize: false,\u000a        showHead: false,\u000a\u000a        moveModel: true,\u000a        zoomInOnModel: false,\u000a        zoomInOnBed: false,\u000a        centerViewport: false,\u000a        invertAxes: {x: false, y: false},\u000a\u000a        bed: {x: 200, y: 200},\u000a        container: undefined,\u000a\u000a        onInternalOptionChange: undefined,\u000a\u000a        onViewportChange: undefined,\u000a        onDragStart: undefined, // Cancellable (return false)\u000a        onDrag: undefined, // Cancellable (return false)\u000a        onDragStop: undefined\u000a    };\u000a\u000a    var offsetModelX = 0,\u000a        offsetModelY = 0;\u000a    var offsetBedX = 0,\u000a        offsetBedY = 0;\u000a    var scaleX = 1,\u000a        scaleY = 1;\u000a    var speeds = [];\u000a    var speedsByLayer = {};\u000a    var currentInvertX = false,\u000a        currentInvertY = false;\u000a\u000a    function notifyIfViewportChanged() {\u000a        if (viewportChanged) {\u000a            if (renderOptions["onViewportChange"]) {\u000a                renderOptions["onViewportChange"](ctx.getTransform());\u000a            }\u000a            viewportChanged = false;\u000a        }\u000a    }\u000a\u000a    var reRender = function () {\u000a        if (!model) return;\u000a\u000a        log.debug(\u000a            "Rerendering layer " +\u000a                layerNumStore +\u000a                " of " +\u000a                model.length +\u000a                " with " +\u000a                GCODE.renderer.getLayerNumSegments(layerNumStore) +\u000a                " segments"\u000a        );\u000a\u000a        notifyIfViewportChanged();\u000a\u000a        var p1 = ctx.transformedPoint(0, 0);\u000a        var p2 = ctx.transformedPoint(canvas.width, canvas.height);\u000a        ctx.clearRect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);\u000a\u000a        drawGrid();\u000a        drawBoundingBox();\u000a        if (model && model.length) {\u000a            if (layerNumStore < model.length) {\u000a                if (renderOptions["showNextLayer"] && layerNumStore < model.length - 1) {\u000a                    drawLayer(\u000a                        layerNumStore + 1,\u000a                        0,\u000a                        GCODE.renderer.getLayerNumSegments(layerNumStore + 1),\u000a                        true\u000a                    );\u000a                }\u000a                if (renderOptions["showCurrentLayer"] && layerNumStore < model.length) {\u000a                    drawLayer(\u000a                        layerNumStore,\u000a                        0,\u000a                        GCODE.renderer.getLayerNumSegments(layerNumStore),\u000a                        true\u000a                    );\u000a                }\u000a                if (renderOptions["showPreviousLayer"] && layerNumStore > 0) {\u000a                    drawLayer(\u000a                        layerNumStore - 1,\u000a                        0,\u000a                        GCODE.renderer.getLayerNumSegments(layerNumStore - 1),\u000a                        true\u000a                    );\u000a                }\u000a                drawLayer(layerNumStore, progressStore.from, progressStore.to);\u000a            } else {\u000a                console.log("Got request to render non-existent layer");\u000a            }\u000a        }\u000a    };\u000a\u000a    function trackTransforms(ctx) {\u000a        var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");\u000a        var xform = svg.createSVGMatrix();\u000a        ctx.getTransform = function () {\u000a            return xform;\u000a        };\u000a\u000a        var savedTransforms = [];\u000a        var save = ctx.save;\u000a        ctx.save = function () {\u000a            savedTransforms.push(xform.translate(0, 0));\u000a            return save.call(ctx);\u000a        };\u000a        var restore = ctx.restore;\u000a        ctx.restore = function () {\u000a            xform = savedTransforms.pop();\u000a            viewportChanged = true;\u000a            return restore.call(ctx);\u000a        };\u000a\u000a        var scale = ctx.scale;\u000a        ctx.scale = function (sx, sy) {\u000a            xform = xform.scaleNonUniform(sx, sy);\u000a            viewportChanged = true;\u000a            return scale.call(ctx, sx, sy);\u000a        };\u000a        var rotate = ctx.rotate;\u000a        ctx.rotate = function (radians) {\u000a            xform = xform.rotate((radians * 180) / Math.PI);\u000a            viewportChanged = true;\u000a            return rotate.call(ctx, radians);\u000a        };\u000a        var translate = ctx.translate;\u000a        ctx.translate = function (dx, dy) {\u000a            xform = xform.translate(dx, dy);\u000a            viewportChanged = true;\u000a            return translate.call(ctx, dx, dy);\u000a        };\u000a        var transform = ctx.transform;\u000a        ctx.transform = function (a, b, c, d, e, f) {\u000a            var m2 = svg.createSVGMatrix();\u000a            m2.a = a;\u000a            m2.b = b;\u000a            m2.c = c;\u000a            m2.d = d;\u000a            m2.e = e;\u000a            m2.f = f;\u000a            xform = xform.multiply(m2);\u000a            viewportChanged = true;\u000a            return transform.call(ctx, a, b, c, d, e, f);\u000a        };\u000a        var setTransform = ctx.setTransform;\u000a        ctx.setTransform = function (a, b, c, d, e, f) {\u000a            xform.a = a;\u000a            xform.b = b;\u000a            xform.c = c;\u000a            xform.d = d;\u000a            xform.e = e;\u000a            xform.f = f;\u000a            viewportChanged = true;\u000a            return setTransform.call(ctx, a, b, c, d, e, f);\u000a        };\u000a        var pt = svg.createSVGPoint();\u000a        ctx.transformedPoint = function (x, y) {\u000a            pt.x = x;\u000a            pt.y = y;\u000a            return pt.matrixTransform(xform.inverse());\u000a        };\u000a    }\u000a\u000a    var startCanvas = function () {\u000a        var jqueryCanvas = $(renderOptions["container"]);\u000a        //jqueryCanvas.css("background-color", renderOptions["bgColorOffGrid"]);\u000a        canvas = jqueryCanvas[0];\u000a\u000a        ctx = canvas.getContext("2d");\u000a        canvas.style.height = canvas.height + "px";\u000a        canvas.style.width = canvas.width + "px";\u000a        canvas.height = canvas.height * pixelRatio;\u000a        canvas.width = canvas.width * pixelRatio;\u000a        ctxHeight = canvas.height;\u000a        ctxWidth = canvas.width;\u000a        lastX = ctxWidth / 2;\u000a        lastY = ctxHeight / 2;\u000a        ctx.lineWidth = 2 * lineWidthFactor;\u000a        ctx.lineCap = "round";\u000a        trackTransforms(ctx);\u000a\u000a        ctx.scale(1, -1); // Invert y-axis\u000a\u000a        // dragging => translating\u000a        canvas.addEventListener(\u000a            "mousedown",\u000a            function (event) {\u000a                document.body.style.mozUserSelect = document.body.style.webkitUserSelect = document.body.style.userSelect =\u000a                    "none";\u000a\u000a                // remember starting point of dragging gesture\u000a                lastX = (event.offsetX || event.pageX - canvas.offsetLeft) * pixelRatio;\u000a                lastY = (event.offsetY || event.pageY - canvas.offsetTop) * pixelRatio;\u000a\u000a                var pt = ctx.transformedPoint(lastX, lastY);\u000a                if (\u000a                    !renderOptions["onDragStart"] ||\u000a                    renderOptions["onDragStart"](pt) !== false\u000a                )\u000a                    dragStart = pt;\u000a            },\u000a            false\u000a        );\u000a\u000a        canvas.addEventListener(\u000a            "mousemove",\u000a            function (event) {\u000a                // save current mouse coordinates\u000a                lastX = (event.offsetX || event.pageX - canvas.offsetLeft) * pixelRatio;\u000a                lastY = (event.offsetY || event.pageY - canvas.offsetTop) * pixelRatio;\u000a\u000a                // mouse movement => dragged\u000a                if (dragStart !== undefined) {\u000a                    // translate\u000a                    var pt = ctx.transformedPoint(lastX, lastY);\u000a\u000a                    if (renderOptions["onDrag"] && renderOptions["onDrag"](pt) === false)\u000a                        return;\u000a\u000a                    ctx.translate(pt.x - dragStart.x, pt.y - dragStart.y);\u000a                    reRender();\u000a\u000a                    renderOptions["centerViewport"] = false;\u000a                    renderOptions["zoomInOnModel"] = false;\u000a                    renderOptions["zoomInOnBed"] = false;\u000a                    offsetModelX = 0;\u000a                    offsetModelY = 0;\u000a                    offsetBedX = 0;\u000a                    offsetBedY = 0;\u000a                    scaleX = 1;\u000a                    scaleY = 1;\u000a\u000a                    if (renderOptions["onInternalOptionChange"] !== undefined) {\u000a                        renderOptions["onInternalOptionChange"]({\u000a                            centerViewport: false,\u000a                            moveModel: false,\u000a                            zoomInOnModel: false,\u000a                            zoomInOnBed: false\u000a                        });\u000a                    }\u000a                }\u000a            },\u000a            false\u000a        );\u000a\u000a        canvas.addEventListener(\u000a            "mouseup",\u000a            function (event) {\u000a                // reset dragStart\u000a                dragStart = undefined;\u000a\u000a                if (renderOptions["onDragStop"]) {\u000a                    var x =\u000a                        (event.offsetX || event.pageX - canvas.offsetLeft) * pixelRatio;\u000a                    var y =\u000a                        (event.offsetY || event.pageY - canvas.offsetTop) * pixelRatio;\u000a                    renderOptions["onDragStop"](ctx.transformedPoint(x, y));\u000a                }\u000a            },\u000a            false\u000a        );\u000a\u000a        // mouse wheel => zooming\u000a        var zoom = function (clicks) {\u000a            // focus on last mouse position prior to zoom\u000a            var pt = ctx.transformedPoint(lastX, lastY);\u000a            ctx.translate(pt.x, pt.y);\u000a\u000a            // determine zooming factor and perform zoom\u000a            var factor = Math.pow(scaleFactor, clicks);\u000a            ctx.scale(factor, factor);\u000a\u000a            // return to old position\u000a            ctx.translate(-pt.x, -pt.y);\u000a\u000a            // render\u000a            reRender();\u000a\u000a            // disable conflicting options\u000a            renderOptions["zoomInOnModel"] = false;\u000a            renderOptions["zoomInOnBed"] = false;\u000a            offsetModelX = 0;\u000a            offsetModelY = 0;\u000a            offsetBedX = 0;\u000a            offsetBedY = 0;\u000a            scaleX = 1;\u000a            scaleY = 1;\u000a\u000a            if (renderOptions["onInternalOptionChange"] !== undefined) {\u000a                renderOptions["onInternalOptionChange"]({\u000a                    zoomInOnModel: false,\u000a                    zoomInOnBed: false\u000a                });\u000a            }\u000a        };\u000a        var handleScroll = function (event) {\u000a            var delta;\u000a\u000a            // determine zoom direction & delta\u000a            if (event.detail < 0 || event.wheelDelta > 0) {\u000a                delta = zoomFactorDelta;\u000a            } else {\u000a                delta = -1 * zoomFactorDelta;\u000a            }\u000a            if (delta) zoom(delta);\u000a\u000a            return event.preventDefault() && false;\u000a        };\u000a        canvas.addEventListener("DOMMouseScroll", handleScroll, false);\u000a        canvas.addEventListener("mousewheel", handleScroll, false);\u000a    };\u000a\u000a    var drawGrid = function () {\u000a        ctx.translate(offsetBedX, offsetBedY);\u000a        if (renderOptions["bed"]["circular"]) {\u000a            drawCircularGrid();\u000a        } else {\u000a            drawRectangularGrid();\u000a        }\u000a        ctx.translate(-offsetBedX, -offsetBedY);\u000a    };\u000a\u000a    var drawRectangularGrid = function () {\u000a        var x, y;\u000a        var width = renderOptions["bed"]["x"];\u000a        var height = renderOptions["bed"]["y"];\u000a\u000a        var minX, maxX, minY, maxY;\u000a        if (renderOptions["bed"]["centeredOrigin"]) {\u000a            var halfWidth = width / 2;\u000a            var halfHeight = height / 2;\u000a\u000a            minX = -halfWidth;\u000a            maxX = halfWidth;\u000a            minY = -halfHeight;\u000a            maxY = halfHeight;\u000a        } else {\u000a            minX = 0;\u000a            maxX = width;\u000a            minY = 0;\u000a            maxY = height;\u000a        }\u000a\u000a        //~ bed outline and origin\u000a        ctx.beginPath();\u000a        ctx.strokeStyle = renderOptions["colorGrid"];\u000a        ctx.fillStyle = "#ffffff";\u000a        ctx.lineWidth = 2 * lineWidthFactor;\u000a\u000a        // outline\u000a        ctx.rect(minX, minY, width, height);\u000a\u000a        // origin\u000a        ctx.moveTo(minX, 0);\u000a        ctx.lineTo(maxX, 0);\u000a        ctx.moveTo(0, minY);\u000a        ctx.lineTo(0, maxY);\u000a\u000a        // draw\u000a        ctx.fill();\u000a        ctx.stroke();\u000a\u000a        // draw origin\u000a        ctx.beginPath();\u000a        ctx.arc(0, 0, 2, 0, Math.PI * 2, true);\u000a        ctx.stroke();\u000a\u000a        ctx.strokeStyle = renderOptions["colorGrid"];\u000a        ctx.lineWidth = lineWidthFactor;\u000a\u000a        //~~ grid starting from origin\u000a        ctx.beginPath();\u000a        for (x = 0; x <= maxX; x += gridStep) {\u000a            ctx.moveTo(x, minY);\u000a            ctx.lineTo(x, maxY);\u000a\u000a            if (renderOptions["bed"]["centeredOrigin"]) {\u000a                ctx.moveTo(-1 * x, minY);\u000a                ctx.lineTo(-1 * x, maxY);\u000a            }\u000a        }\u000a        ctx.stroke();\u000a\u000a        ctx.beginPath();\u000a        for (y = 0; y <= maxY; y += gridStep) {\u000a            ctx.moveTo(minX, y);\u000a            ctx.lineTo(maxX, y);\u000a\u000a            if (renderOptions["bed"]["centeredOrigin"]) {\u000a                ctx.moveTo(minX, -1 * y);\u000a                ctx.lineTo(maxX, -1 * y);\u000a            }\u000a        }\u000a        ctx.stroke();\u000a    };\u000a\u000a    var drawCircularGrid = function () {\u000a        var i;\u000a\u000a        ctx.strokeStyle = renderOptions["colorGrid"];\u000a        ctx.fillStyle = "#ffffff";\u000a        ctx.lineWidth = 2 * lineWidthFactor;\u000a\u000a        //~~ bed outline & origin\u000a        ctx.beginPath();\u000a\u000a        // outline\u000a        var r = renderOptions["bed"]["r"];\u000a        ctx.arc(0, 0, r, 0, Math.PI * 2, true);\u000a\u000a        // origin\u000a        ctx.moveTo(-1 * r, 0);\u000a        ctx.lineTo(r, 0);\u000a        ctx.moveTo(0, r);\u000a        ctx.lineTo(0, -1 * r);\u000a\u000a        // draw\u000a        ctx.fill();\u000a        ctx.stroke();\u000a\u000a        // draw origin\u000a        ctx.beginPath();\u000a        ctx.arc(0, 0, 2, 0, Math.PI * 2, true);\u000a        ctx.stroke();\u000a\u000a        ctx.strokeStyle = renderOptions["colorGrid"];\u000a        ctx.lineWidth = lineWidthFactor;\u000a\u000a        //~~ grid starting from origin\u000a        ctx.beginPath();\u000a        for (i = 0; i <= r; i += gridStep) {\u000a            var x = i;\u000a            var y = Math.sqrt(r * r - x * x);\u000a\u000a            ctx.moveTo(x, -1 * y);\u000a            ctx.lineTo(x, y);\u000a\u000a            ctx.moveTo(y, -1 * x);\u000a            ctx.lineTo(-1 * y, -1 * x);\u000a\u000a            ctx.moveTo(-1 * x, -1 * y);\u000a            ctx.lineTo(-1 * x, y);\u000a\u000a            ctx.moveTo(y, x);\u000a            ctx.lineTo(-1 * y, x);\u000a        }\u000a        ctx.stroke();\u000a    };\u000a\u000a    var drawBoundingBox = function () {\u000a        if (!modelInfo) return;\u000a\u000a        var minX, minY, width, height;\u000a\u000a        if (renderOptions["showFullSize"]) {\u000a            minX = modelInfo.min.x;\u000a            minY = modelInfo.min.y;\u000a            width = modelInfo.modelSize.x;\u000a            height = modelInfo.modelSize.y;\u000a\u000a            ctx.beginPath();\u000a            ctx.strokeStyle = "#0000ff";\u000a            ctx.setLineDash([2, 5]);\u000a\u000a            ctx.rect(minX, minY, width, height);\u000a\u000a            ctx.stroke();\u000a        }\u000a\u000a        if (renderOptions["showBoundingBox"]) {\u000a            minX = modelInfo.boundingBox.minX;\u000a            minY = modelInfo.boundingBox.minY;\u000a            width = modelInfo.boundingBox.maxX - minX;\u000a            height = modelInfo.boundingBox.maxY - minY;\u000a\u000a            ctx.beginPath();\u000a            ctx.strokeStyle = "#ff0000";\u000a            ctx.setLineDash([2, 5]);\u000a\u000a            ctx.rect(minX, minY, width, height);\u000a\u000a            ctx.stroke();\u000a        }\u000a\u000a        ctx.setLineDash([1, 0]);\u000a    };\u000a\u000a    var drawTriangle = function (centerX, centerY, length, up) {\u000a        /*\u000a         *             (cx,cy)\u000a         *                *             ^\u000a         *               / \u005c            |\u000a         *              /   \u005c           |\u000a         *             /     \u005c          |\u000a         *            / (x,y) \u005c         | h\u000a         *           /         \u005c        |\u000a         *          /           \u005c       |\u000a         *         /             \u005c      |\u000a         *        *---------------*     v\u000a         *    (ax,ay)           (bx,by)\u000a         */\u000a\u000a        var ax, bx, cx, ay, by, cy;\u000a        var h = Math.sqrt(0.75 * length * length) / 2;\u000a\u000a        ax = centerX - length / 2;\u000a        bx = ax + length;\u000a        cx = centerX;\u000a\u000a        if (up) {\u000a            ay = centerY - h;\u000a            by = centerY - h;\u000a            cy = centerY + h;\u000a        } else {\u000a            ay = centerY + h;\u000a            by = centerY + h;\u000a            cy = centerY - h;\u000a        }\u000a\u000a        var origLineJoin = ctx.lineJoin;\u000a        ctx.lineJoin = "miter";\u000a\u000a        ctx.beginPath();\u000a        ctx.moveTo(ax, ay);\u000a        ctx.lineTo(bx, by);\u000a        ctx.moveTo(bx, by);\u000a        ctx.lineTo(cx, cy);\u000a        ctx.lineTo(ax, ay);\u000a        ctx.stroke();\u000a        ctx.fill();\u000a\u000a        ctx.lineJoin = origLineJoin;\u000a    };\u000a\u000a    var drawLayer = function (layerNum, fromProgress, toProgress, isNotCurrentLayer) {\u000a        log.trace(\u000a            "Drawing layer " +\u000a                layerNum +\u000a                " from " +\u000a                fromProgress +\u000a                " to " +\u000a                toProgress +\u000a                " (current: " +\u000a                !isNotCurrentLayer +\u000a                ")"\u000a        );\u000a\u000a        var i;\u000a\u000a        //~~ store current layer values\u000a\u000a        isNotCurrentLayer = isNotCurrentLayer !== undefined ? isNotCurrentLayer : false;\u000a\u000a        if (!model || !model[layerNum]) return;\u000a\u000a        var cmds = model[layerNum];\u000a        var x, y;\u000a\u000a        //~~ find our initial prevX/prevY tuple\u000a\u000a        if (cmds[0].prevX !== undefined && cmds[0].prevY !== undefined) {\u000a            // command contains prevX/prevY values, use those\u000a            prevX = cmds[0].prevX;\u000a            prevY = cmds[0].prevY;\u000a        } else if (fromProgress > 0) {\u000a            // previous command in same layer exists, use x/y as prevX/prevY\u000a            prevX = cmds[fromProgress - 1].x;\u000a            prevY = cmds[fromProgress - 1].y;\u000a        } else if (model[layerNum - 1]) {\u000a            // previous layer exists, use last x/y as prevX/prevY\u000a            prevX = undefined;\u000a            prevY = undefined;\u000a            var prevModelLayer = model[layerNum - 1];\u000a            for (i = prevModelLayer.length - 1; i >= 0; i--) {\u000a                if (prevX === undefined && prevModelLayer[i].x !== undefined) {\u000a                    prevX = prevModelLayer[i].x;\u000a                    if (prevY !== undefined) break;\u000a                }\u000a                if (prevY === undefined && prevModelLayer[i].y !== undefined) {\u000a                    prevY = prevModelLayer[i].y;\u000a                    if (prevX !== undefined) break;\u000a                }\u000a            }\u000a        }\u000a\u000a        // if we did not find prevX or prevY, set it to 0 (might be that we are on the first command of the first layer,\u000a        // or it's just a very weird model...)\u000a        if (prevX === undefined) prevX = 0;\u000a        if (prevY === undefined) prevY = 0;\u000a\u000a        //~~ render this layer's commands\u000a\u000a        var sizeRetractSpot = renderOptions["sizeRetractSpot"] * lineWidthFactor * 2;\u000a\u000a        // alpha value (100% if current layer is being rendered, 30% otherwise)\u000a        // Note - If showing currently layer as preview - also render it at 30% and draw the progress over the top at 100%\u000a        var alpha =\u000a            (renderOptions["showNextLayer"] ||\u000a                renderOptions["showCurrentLayer"] ||\u000a                renderOptions["showPreviousLayer"]) &&\u000a            isNotCurrentLayer\u000a                ? 0.3\u000a                : 1.0;\u000a\u000a        var colorLine = {};\u000a        var colorMove = {};\u000a        var colorRetract = {};\u000a        var colorRestart = {};\u000a\u000a        function getColorLineForTool(tool) {\u000a            var rv = colorLine[tool];\u000a            if (rv === undefined) {\u000a                var lineColor = renderOptions["colorLine"][tool];\u000a                if (lineColor === undefined) lineColor = renderOptions["colorLine"][0];\u000a                var shade = tool * 0.15;\u000a                rv = colorLine[tool] = pusher\u000a                    .color(lineColor)\u000a                    .shade(shade)\u000a                    .alpha(alpha)\u000a                    .html();\u000a            }\u000a            return rv;\u000a        }\u000a\u000a        function getColorMoveForTool(tool) {\u000a            var rv = colorMove[tool];\u000a            if (rv === undefined) {\u000a                var shade = tool * 0.15;\u000a                rv = colorMove[tool] = pusher\u000a                    .color(renderOptions["colorMove"])\u000a                    .shade(shade)\u000a                    .alpha(alpha)\u000a                    .html();\u000a            }\u000a            return rv;\u000a        }\u000a\u000a        function getColorRetractForTool(tool) {\u000a            var rv = colorRetract[tool];\u000a            if (rv === undefined) {\u000a                var shade = tool * 0.15;\u000a                rv = colorRetract[tool] = pusher\u000a                    .color(renderOptions["colorRetract"])\u000a                    .shade(shade)\u000a                    .alpha(alpha)\u000a                    .html();\u000a            }\u000a            return rv;\u000a        }\u000a\u000a        function getColorRestartForTool(tool) {\u000a            var rv = colorRestart[tool];\u000a            if (rv === undefined) {\u000a                var shade = tool * 0.15;\u000a                rv = colorRestart[tool] = pusher\u000a                    .color(renderOptions["colorRestart"])\u000a                    .shade(shade)\u000a                    .alpha(alpha)\u000a                    .html();\u000a            }\u000a            return rv;\u000a        }\u000a\u000a        var prevPathType = "fill";\u000a        function strokePathIfNeeded(newPathType, strokeStyle) {\u000a            if (newPathType != prevPathType || newPathType == "fill") {\u000a                if (prevPathType != "fill") {\u000a                    ctx.stroke();\u000a                }\u000a                prevPathType = newPathType;\u000a\u000a                ctx.beginPath();\u000a                if (newPathType != "fill") {\u000a                    ctx.strokeStyle = strokeStyle;\u000a                    ctx.moveTo(prevX, prevY);\u000a                }\u000a            }\u000a        }\u000a\u000a        ctx.lineJoin = "round";\u000a\u000a        for (i = fromProgress; i <= toProgress; i++) {\u000a            if (typeof cmds[i] === "undefined") continue;\u000a            var cmd = cmds[i];\u000a\u000a            if (cmd.prevX !== undefined && cmd.prevY !== undefined) {\u000a                // override new (prevX, prevY)\u000a                prevX = cmd.prevX;\u000a                prevY = cmd.prevY;\u000a            }\u000a\u000a            // new x\u000a            if (cmd.x === undefined || isNaN(cmd.x)) {\u000a                x = prevX;\u000a            } else {\u000a                x = cmd.x;\u000a            }\u000a\u000a            // new y\u000a            if (cmd.y === undefined || isNaN(cmd.y)) {\u000a                y = prevY;\u000a            } else {\u000a                y = cmd.y;\u000a            }\u000a\u000a            // current tool\u000a            var tool = cmd.tool || 0;\u000a\u000a            if (!cmd.extrude && !cmd.noMove) {\u000a                // neither extrusion nor move\u000a                if (cmd.retract == -1) {\u000a                    // retract => draw dot if configured to do so\u000a                    if (renderOptions["showRetracts"] && !isNotCurrentLayer) {\u000a                        strokePathIfNeeded("fill");\u000a                        ctx.fillStyle = getColorRetractForTool(tool);\u000a                        ctx.strokeStyle = ctx.fillStyle;\u000a                        drawTriangle(prevX, prevY, sizeRetractSpot, true);\u000a                    }\u000a                }\u000a\u000a                strokePathIfNeeded("move", getColorMoveForTool(tool));\u000a                if (renderOptions["showMoves"] && !isNotCurrentLayer) {\u000a                    // move => draw line from (prevX, prevY) to (x, y) in move color\u000a                    ctx.lineWidth = lineWidthFactor;\u000a                    ctx.lineTo(x, y);\u000a                }\u000a            } else if (cmd.extrude) {\u000a                if (cmd.retract == 0) {\u000a                    // no retraction => real extrusion move, use tool color to draw line\u000a                    strokePathIfNeeded("extrude", getColorLineForTool(tool));\u000a                    ctx.lineWidth = renderOptions["extrusionWidth"] * lineWidthFactor;\u000a                    if (cmd.direction !== undefined && cmd.direction != 0) {\u000a                        var di = cmd.i;\u000a                        var dj = cmd.j;\u000a                        var centerX = prevX + di;\u000a                        var centerY = prevY + dj;\u000a                        var startAngle = Math.atan2(prevY - centerY, prevX - centerX);\u000a                        var endAngle = Math.atan2(y - centerY, x - centerX);\u000a                        var radius = Math.sqrt(di * di + dj * dj);\u000a                        ctx.arc(\u000a                            centerX,\u000a                            centerY,\u000a                            radius,\u000a                            startAngle,\u000a                            endAngle,\u000a                            cmd.direction < 0\u000a                        ); // Y-axis is inverted so direction is also inverted\u000a                    } else {\u000a                        ctx.lineTo(x, y);\u000a                    }\u000a                } else {\u000a                    // we were previously retracting, now we are restarting => draw dot if configured to do so\u000a                    if (renderOptions["showRetracts"] && !isNotCurrentLayer) {\u000a                        strokePathIfNeeded("fill");\u000a                        ctx.fillStyle = getColorRestartForTool(tool);\u000a                        ctx.strokeStyle = ctx.fillStyle;\u000a                        drawTriangle(prevX, prevY, sizeRetractSpot, false);\u000a                    }\u000a                }\u000a            }\u000a\u000a            // set new (prevX, prevY)\u000a            prevX = x;\u000a            prevY = y;\u000a        }\u000a\u000a        if (prevPathType != "fill") {\u000a            ctx.stroke();\u000a        }\u000a\u000a        if (renderOptions["showHead"] && !isNotCurrentLayer) {\u000a            var sizeHeadSpot =\u000a                renderOptions["sizeHeadSpot"] * lineWidthFactor + lineWidthFactor / 2;\u000a            var shade = tool * 0.15;\u000a            ctx.fillStyle = pusher\u000a                .color(renderOptions["colorHead"])\u000a                .shade(shade)\u000a                .alpha(alpha)\u000a                .html();\u000a            ctx.beginPath();\u000a            ctx.arc(prevX, prevY, sizeHeadSpot, 0, Math.PI * 2, true);\u000a            ctx.fill();\u000a        }\u000a    };\u000a\u000a    var applyOffsets = function () {\u000a        var canvasCenter;\u000a\u000a        // determine bed and model offsets\u000a        if (ctx) ctx.translate(-offsetModelX, -offsetModelY);\u000a        if (renderOptions["centerViewport"] || renderOptions["zoomInOnModel"]) {\u000a            canvasCenter = ctx.transformedPoint(canvas.width / 2, canvas.height / 2);\u000a            if (modelInfo) {\u000a                offsetModelX =\u000a                    canvasCenter.x -\u000a                    (modelInfo.boundingBox.minX + modelInfo.boundingBox.maxX) / 2;\u000a                offsetModelY =\u000a                    canvasCenter.y -\u000a                    (modelInfo.boundingBox.minY + modelInfo.boundingBox.maxY) / 2;\u000a            } else {\u000a                offsetModelX = 0;\u000a                offsetModelY = 0;\u000a            }\u000a            offsetBedX = 0;\u000a            offsetBedY = 0;\u000a        } else if (modelInfo && renderOptions["moveModel"]) {\u000a            offsetModelX =\u000a                renderOptions["bed"]["x"] / 2 -\u000a                (modelInfo.boundingBox.minX + modelInfo.boundingBox.maxX) / 2;\u000a            offsetModelY =\u000a                renderOptions["bed"]["y"] / 2 -\u000a                (modelInfo.boundingBox.minY + modelInfo.boundingBox.maxY) / 2;\u000a            offsetBedX =\u000a                -1 *\u000a                (renderOptions["bed"]["x"] / 2 -\u000a                    (modelInfo.boundingBox.minX + modelInfo.boundingBox.maxX) / 2);\u000a            offsetBedY =\u000a                -1 *\u000a                (renderOptions["bed"]["y"] / 2 -\u000a                    (modelInfo.boundingBox.minY + modelInfo.boundingBox.maxY) / 2);\u000a        } else if (\u000a            renderOptions["bed"]["circular"] ||\u000a            renderOptions["bed"]["centeredOrigin"]\u000a        ) {\u000a            canvasCenter = ctx.transformedPoint(canvas.width / 2, canvas.height / 2);\u000a            offsetModelX = canvasCenter.x;\u000a            offsetModelY = canvasCenter.y;\u000a            offsetBedX = 0;\u000a            offsetBedY = 0;\u000a        } else {\u000a            offsetModelX = 0;\u000a            offsetModelY = 0;\u000a            offsetBedX = 0;\u000a            offsetBedY = 0;\u000a        }\u000a        if (ctx) ctx.translate(offsetModelX, offsetModelY);\u000a    };\u000a\u000a    var applyZoom = function () {\u000a        // get middle of canvas\u000a        var pt = ctx.transformedPoint(canvas.width / 2, canvas.height / 2);\u000a\u000a        // get current transform\u000a        var transform = ctx.getTransform();\u000a\u000a        // move to middle of canvas, reset scale, move back\u000a        if (scaleX && scaleY && transform.a && transform.d) {\u000a            ctx.translate(pt.x, pt.y);\u000a            ctx.scale(1 / scaleX, 1 / scaleY);\u000a            ctx.translate(-pt.x, -pt.y);\u000a            transform = ctx.getTransform();\u000a        }\u000a\u000a        if (modelInfo && renderOptions["zoomInOnModel"]) {\u000a            // if we need to zoom in on model, scale factor is calculated by longer side of object in relation to that axis of canvas\u000a            var width = modelInfo.boundingBox.maxX - modelInfo.boundingBox.minX;\u000a            var length = modelInfo.boundingBox.maxY - modelInfo.boundingBox.minY;\u000a\u000a            var scaleF =\u000a                width > length\u000a                    ? (canvas.width - 10) / width\u000a                    : (canvas.height - 10) / length;\u000a            if (transform.a && transform.d) {\u000a                scaleX =\u000a                    (scaleF / transform.a) * (renderOptions["invertAxes"]["x"] ? -1 : 1);\u000a                scaleY =\u000a                    (scaleF / transform.d) * (renderOptions["invertAxes"]["y"] ? 1 : -1);\u000a                ctx.translate(pt.x, pt.y);\u000a                ctx.scale(scaleX, scaleY);\u000a                ctx.translate(-pt.x, -pt.y);\u000a            }\u000a        } else {\u000a            // reset scale to 1\u000a            scaleX = 1;\u000a            scaleY = 1;\u000a        }\u000a    };\u000a\u000a    var applyInversion = function () {\u000a        var width = canvas.width - 10;\u000a        var height = canvas.height - 10;\u000a\u000a        // de-invert\u000a        if (currentInvertX || currentInvertY) {\u000a            ctx.scale(currentInvertX ? -1 : 1, currentInvertY ? -1 : 1);\u000a            ctx.translate(currentInvertX ? -width : 0, currentInvertY ? height : 0);\u000a        }\u000a\u000a        // get settings\u000a        var invertX = renderOptions["invertAxes"]["x"];\u000a        var invertY = renderOptions["invertAxes"]["y"];\u000a\u000a        // invert\u000a        if (invertX || invertY) {\u000a            ctx.translate(invertX ? width : 0, invertY ? -height : 0);\u000a            ctx.scale(invertX ? -1 : 1, invertY ? -1 : 1);\u000a        }\u000a\u000a        // save for later\u000a        currentInvertX = invertX;\u000a        currentInvertY = invertY;\u000a    };\u000a\u000a    // ***** PUBLIC *******\u000a    return {\u000a        init: function () {\u000a            startCanvas();\u000a            initialized = true;\u000a            var bedWidth = renderOptions["bed"]["x"];\u000a            var bedHeight = renderOptions["bed"]["y"];\u000a            if (renderOptions["bed"]["circular"]) {\u000a                bedWidth = bedHeight = renderOptions["bed"]["r"] * 2;\u000a            }\u000a\u000a            // Ratio of bed to canvas viewport\u000a            var viewportRatio = Math.min(\u000a                (canvas.width - 10) / bedWidth,\u000a                (canvas.height - 10) / bedHeight\u000a            );\u000a\u000a            // Apply initial translation to center the bed in the viewport\u000a            var translationX, translationY;\u000a            if (renderOptions["bed"]["circular"]) {\u000a                translationX = canvas.width / 2;\u000a                translationY = canvas.height / 2;\u000a            } else {\u000a                translationX = (canvas.width - bedWidth * viewportRatio) / 2;\u000a                translationY =\u000a                    bedHeight * viewportRatio +\u000a                    (canvas.height - bedHeight * viewportRatio) / 2;\u000a            }\u000a            ctx.translate(translationX, -translationY);\u000a\u000a            ctx.scale(viewportRatio, viewportRatio);\u000a\u000a            offsetModelX = 0;\u000a            offsetModelY = 0;\u000a            offsetBedX = 0;\u000a            offsetBedY = 0;\u000a\u000a            // Scaling to apply to move lines and extrusion/retraction markers\u000a            lineWidthFactor = 1 / viewportRatio;\u000a        },\u000a        setOption: function (options) {\u000a            var mustRefresh = false;\u000a            var dirty = false;\u000a            for (var opt in options) {\u000a                if (!renderOptions.hasOwnProperty(opt) || !options.hasOwnProperty(opt))\u000a                    continue;\u000a                if (options[opt] === undefined) continue;\u000a                if (renderOptions[opt] == options[opt]) continue;\u000a\u000a                dirty = true;\u000a                renderOptions[opt] = options[opt];\u000a                if (\u000a                    $.inArray(opt, [\u000a                        "moveModel",\u000a                        "centerViewport",\u000a                        "zoomInOnModel",\u000a                        "bed",\u000a                        "invertAxes",\u000a                        "onViewportChange"\u000a                    ]) > -1\u000a                ) {\u000a                    mustRefresh = true;\u000a                }\u000a            }\u000a\u000a            if (!dirty) return;\u000a            if (initialized) {\u000a                if (mustRefresh) {\u000a                    this.refresh();\u000a                } else {\u000a                    reRender();\u000a                }\u000a            }\u000a        },\u000a        getOptions: function () {\u000a            return renderOptions;\u000a        },\u000a        debugGetModel: function () {\u000a            return model;\u000a        },\u000a        render: function (layerNum, fromProgress, toProgress) {\u000a            if (!initialized) this.init();\u000a\u000a            layerNumStore = layerNum;\u000a            progressStore.from = fromProgress;\u000a            progressStore.to = toProgress;\u000a\u000a            reRender();\u000a        },\u000a        getModelNumLayers: function () {\u000a            return model ? model.length : 1;\u000a        },\u000a        getLayerNumSegments: function (layer) {\u000a            if (model) {\u000a                return model[layer] ? model[layer].length : 1;\u000a            } else {\u000a                return 1;\u000a            }\u000a        },\u000a        clear: function () {\u000a            offsetModelX = 0;\u000a            offsetModelY = 0;\u000a            offsetBedX = 0;\u000a            offsetBedY = 0;\u000a            scaleX = 1;\u000a            scaleY = 1;\u000a            speeds = [];\u000a            speedsByLayer = {};\u000a            modelInfo = undefined;\u000a\u000a            this.doRender([], 0);\u000a        },\u000a        doRender: function (mdl, layerNum) {\u000a            model = mdl;\u000a            modelInfo = undefined;\u000a\u000a            prevX = 0;\u000a            prevY = 0;\u000a            if (!initialized) this.init();\u000a\u000a            var toProgress = 1;\u000a            if (model && model.length) {\u000a                modelInfo = GCODE.gCodeReader.getModelInfo();\u000a                speeds = modelInfo.speeds;\u000a                speedsByLayer = modelInfo.speedsByLayer;\u000a                if (model[layerNum]) {\u000a                    toProgress = model[layerNum].length;\u000a                }\u000a            }\u000a\u000a            applyInversion();\u000a            applyOffsets();\u000a            applyZoom();\u000a\u000a            this.render(layerNum, 0, toProgress);\u000a        },\u000a        refresh: function (layerNum) {\u000a            if (layerNum === undefined) layerNum = layerNumStore;\u000a            this.doRender(model, layerNum);\u000a        },\u000a        getZ: function (layerNum) {\u000a            if (!model || !model[layerNum]) {\u000a                return "-1";\u000a            }\u000a            var cmds = model[layerNum];\u000a            for (var i = 0; i < cmds.length; i++) {\u000a                if (cmds[i].prevZ !== undefined) return cmds[i].prevZ;\u000a            }\u000a            return "-1";\u000a        }\u000a    };\u000a})();\u000a\u000a;\u000a
p0
.