V// source: js/lib/avltree.js\u000a// AVLTree ///////////////////////////////////////////////////////////////////\u000a//   self file is originally from the Concentré XML project (version 0.2.1)\u000a//   Licensed under GPL and LGPL\u000a//\u000a//   Modified by Jeremy Stephens.\u000a//\u000a//   Taken from: https://gist.github.com/viking/2424106, modified to not only use string literals when searching\u000a\u000a// Pass in the attribute you want to use for comparing\u000afunction AVLTree(n, attr) {\u000a    var self = this;\u000a\u000a    self.attr = attr;\u000a    self.left = null;\u000a    self.right = null;\u000a    self.node = n;\u000a    self.depth = 1;\u000a    self.elements = [n];\u000a\u000a    self.balance = function() {\u000a        var ldepth = self.left  == null ? 0 : self.left.depth;\u000a        var rdepth = self.right == null ? 0 : self.right.depth;\u000a\u000a        if (ldepth > rdepth + 1) {\u000a            // LR or LL rotation\u000a            var lldepth = self.left.left  == null ? 0 : self.left.left.depth;\u000a            var lrdepth = self.left.right == null ? 0 : self.left.right.depth;\u000a\u000a            if (lldepth < lrdepth) {\u000a                // LR rotation consists of a RR rotation of the left child\u000a                self.left.rotateRR();\u000a                // plus a LL rotation of self node, which happens anyway\u000a            }\u000a            self.rotateLL();\u000a        } else if (ldepth + 1 < rdepth) {\u000a            // RR or RL rorarion\u000a            var rrdepth = self.right.right == null ? 0 : self.right.right.depth;\u000a            var rldepth = self.right.left  == null ? 0 : self.right.left.depth;\u000a\u000a            if (rldepth > rrdepth) {\u000a                // RR rotation consists of a LL rotation of the right child\u000a                self.right.rotateLL();\u000a                // plus a RR rotation of self node, which happens anyway\u000a            }\u000a            self.rotateRR();\u000a        }\u000a    }\u000a    \u000a    self.rotateLL = function() {\u000a        // the left side is too long => rotate from the left (_not_ leftwards)\u000a        var nodeBefore = self.node;\u000a        var elementsBefore = self.elements;\u000a        var rightBefore = self.right;\u000a        self.node = self.left.node;\u000a        self.elements = self.left.elements;\u000a        self.right = self.left;\u000a        self.left = self.left.left;\u000a        self.right.left = self.right.right;\u000a        self.right.right = rightBefore;\u000a        self.right.node = nodeBefore;\u000a        self.right.elements = elementsBefore;\u000a        self.right.updateInNewLocation();\u000a        self.updateInNewLocation();\u000a    }\u000a    \u000a    self.rotateRR = function() {\u000a        // the right side is too long => rotate from the right (_not_ rightwards)\u000a        var nodeBefore = self.node;\u000a        var elementsBefore = self.elements;\u000a        var leftBefore = self.left;\u000a        self.node = self.right.node;\u000a        self.elements = self.right.elements;\u000a        self.left = self.right;\u000a        self.right = self.right.right;\u000a        self.left.right = self.left.left;\u000a        self.left.left = leftBefore;\u000a        self.left.node = nodeBefore;\u000a        self.left.elements = elementsBefore;\u000a        self.left.updateInNewLocation();\u000a        self.updateInNewLocation();\u000a    }\u000a    \u000a    self.updateInNewLocation = function() {\u000a        self.getDepthFromChildren();\u000a    }\u000a    \u000a    self.getDepthFromChildren = function() {\u000a        self.depth = self.node == null ? 0 : 1;\u000a        if (self.left != null) {\u000a            self.depth = self.left.depth + 1;\u000a        }\u000a        if (self.right != null && self.depth <= self.right.depth) {\u000a            self.depth = self.right.depth + 1;\u000a        }\u000a    }\u000a    \u000a    self.compare = function(n1, n2) {\u000a        var v1 = n1[self.attr];\u000a        var v2 = n2[self.attr];\u000a        if (v1 == v2) {\u000a            return 0;\u000a        }\u000a        if (v1 < v2) {\u000a            return -1;\u000a        }\u000a        return 1;\u000a    }\u000a    \u000a    self.add = function(n) {\u000a        var o = self.compare(n, self.node);\u000a        if (o == 0) {\u000a            self.elements.push(n);\u000a            return false;\u000a        }\u000a\u000a        var ret = false;\u000a        if (o == -1) {\u000a            if (self.left == null) {\u000a                self.left = new AVLTree(n, self.attr);\u000a                ret = true;\u000a            } else {\u000a                ret = self.left.add(n);\u000a                if (ret) {\u000a                    self.balance();\u000a                }\u000a            }\u000a        } else if (o == 1) {\u000a            if (self.right == null) {\u000a                self.right = new AVLTree(n, self.attr);\u000a                ret = true;\u000a            } else {\u000a                ret = self.right.add(n);\u000a                if (ret) {\u000a                    self.balance();\u000a                }\u000a            }\u000a        }\u000a\u000a        if (ret) {\u000a            self.getDepthFromChildren();\u000a        }\u000a        return ret;\u000a    }\u000a    \u000a    self.findBest = function(value) {\u000a        if (value < self.node[self.attr]) {\u000a            if (self.left != null) {\u000a                return self.left.findBest(value);\u000a            }\u000a        } else if (value > self.node[self.attr]) {\u000a            if (self.right != null) {\u000a                return self.right.findBest(value);\u000a            }\u000a        }\u000a\u000a        return self.elements;\u000a    }\u000a    \u000a    self.find = function(value) {\u000a        var elements = self.findBest(value);\u000a        for (var i = 0; i < elements.length; i++) {\u000a            if (elements[i][self.attr] == value) {\u000a                return elements;\u000a            }\u000a        }\u000a\u000a        return false;\u000a    }\u000a}\u000a\u000a;\u000a
p0
.