V// source: js/lib/jquery/jquery.iframe-transport.js\u000a/*\u000a * jQuery Iframe Transport Plugin\u000a * https://github.com/blueimp/jQuery-File-Upload\u000a *\u000a * Copyright 2011, Sebastian Tschan\u000a * https://blueimp.net\u000a *\u000a * Licensed under the MIT license:\u000a * https://opensource.org/licenses/MIT\u000a */\u000a\u000a/* global define, require */\u000a\u000a(function (factory) {\u000a  'use strict';\u000a  if (typeof define === 'function' && define.amd) {\u000a    // Register as an anonymous AMD module:\u000a    define(['jquery'], factory);\u000a  } else if (typeof exports === 'object') {\u000a    // Node/CommonJS:\u000a    factory(require('jquery'));\u000a  } else {\u000a    // Browser globals:\u000a    factory(window.jQuery);\u000a  }\u000a})(function ($) {\u000a  'use strict';\u000a\u000a  // Helper variable to create unique names for the transport iframes:\u000a  var counter = 0,\u000a    jsonAPI = $,\u000a    jsonParse = 'parseJSON';\u000a\u000a  if ('JSON' in window && 'parse' in JSON) {\u000a    jsonAPI = JSON;\u000a    jsonParse = 'parse';\u000a  }\u000a\u000a  // The iframe transport accepts four additional options:\u000a  // options.fileInput: a jQuery collection of file input fields\u000a  // options.paramName: the parameter name for the file form data,\u000a  //  overrides the name property of the file input field(s),\u000a  //  can be a string or an array of strings.\u000a  // options.formData: an array of objects with name and value properties,\u000a  //  equivalent to the return data of .serializeArray(), e.g.:\u000a  //  [{name: 'a', value: 1}, {name: 'b', value: 2}]\u000a  // options.initialIframeSrc: the URL of the initial iframe src,\u000a  //  by default set to "javascript:false;"\u000a  $.ajaxTransport('iframe', function (options) {\u000a    if (options.async) {\u000a      // javascript:false as initial iframe src\u000a      // prevents warning popups on HTTPS in IE6:\u000a      // eslint-disable-next-line no-script-url\u000a      var initialIframeSrc = options.initialIframeSrc || 'javascript:false;',\u000a        form,\u000a        iframe,\u000a        addParamChar;\u000a      return {\u000a        send: function (_, completeCallback) {\u000a          form = $('<form style="display:none;"></form>');\u000a          form.attr('accept-charset', options.formAcceptCharset);\u000a          addParamChar = /\u005c?/.test(options.url) ? '&' : '?';\u000a          // XDomainRequest only supports GET and POST:\u000a          if (options.type === 'DELETE') {\u000a            options.url = options.url + addParamChar + '_method=DELETE';\u000a            options.type = 'POST';\u000a          } else if (options.type === 'PUT') {\u000a            options.url = options.url + addParamChar + '_method=PUT';\u000a            options.type = 'POST';\u000a          } else if (options.type === 'PATCH') {\u000a            options.url = options.url + addParamChar + '_method=PATCH';\u000a            options.type = 'POST';\u000a          }\u000a          // IE versions below IE8 cannot set the name property of\u000a          // elements that have already been added to the DOM,\u000a          // so we set the name along with the iframe HTML markup:\u000a          counter += 1;\u000a          iframe = $(\u000a            '<iframe src="' +\u000a              initialIframeSrc +\u000a              '" name="iframe-transport-' +\u000a              counter +\u000a              '"></iframe>'\u000a          ).on('load', function () {\u000a            var fileInputClones,\u000a              paramNames = $.isArray(options.paramName)\u000a                ? options.paramName\u000a                : [options.paramName];\u000a            iframe.off('load').on('load', function () {\u000a              var response;\u000a              // Wrap in a try/catch block to catch exceptions thrown\u000a              // when trying to access cross-domain iframe contents:\u000a              try {\u000a                response = iframe.contents();\u000a                // Google Chrome and Firefox do not throw an\u000a                // exception when calling iframe.contents() on\u000a                // cross-domain requests, so we unify the response:\u000a                if (!response.length || !response[0].firstChild) {\u000a                  throw new Error();\u000a                }\u000a              } catch (e) {\u000a                response = undefined;\u000a              }\u000a              // The complete callback returns the\u000a              // iframe content document as response object:\u000a              completeCallback(200, 'success', { iframe: response });\u000a              // Fix for IE endless progress bar activity bug\u000a              // (happens on form submits to iframe targets):\u000a              $('<iframe src="' + initialIframeSrc + '"></iframe>').appendTo(\u000a                form\u000a              );\u000a              window.setTimeout(function () {\u000a                // Removing the form in a setTimeout call\u000a                // allows Chrome's developer tools to display\u000a                // the response result\u000a                form.remove();\u000a              }, 0);\u000a            });\u000a            form\u000a              .prop('target', iframe.prop('name'))\u000a              .prop('action', options.url)\u000a              .prop('method', options.type);\u000a            if (options.formData) {\u000a              $.each(options.formData, function (index, field) {\u000a                $('<input type="hidden"/>')\u000a                  .prop('name', field.name)\u000a                  .val(field.value)\u000a                  .appendTo(form);\u000a              });\u000a            }\u000a            if (\u000a              options.fileInput &&\u000a              options.fileInput.length &&\u000a              options.type === 'POST'\u000a            ) {\u000a              fileInputClones = options.fileInput.clone();\u000a              // Insert a clone for each file input field:\u000a              options.fileInput.after(function (index) {\u000a                return fileInputClones[index];\u000a              });\u000a              if (options.paramName) {\u000a                options.fileInput.each(function (index) {\u000a                  $(this).prop('name', paramNames[index] || options.paramName);\u000a                });\u000a              }\u000a              // Appending the file input fields to the hidden form\u000a              // removes them from their original location:\u000a              form\u000a                .append(options.fileInput)\u000a                .prop('enctype', 'multipart/form-data')\u000a                // enctype must be set as encoding for IE:\u000a                .prop('encoding', 'multipart/form-data');\u000a              // Remove the HTML5 form attribute from the input(s):\u000a              options.fileInput.removeAttr('form');\u000a            }\u000a            window.setTimeout(function () {\u000a              // Submitting the form in a setTimeout call fixes an issue with\u000a              // Safari 13 not triggering the iframe load event after resetting\u000a              // the load event handler, see also:\u000a              // https://github.com/blueimp/jQuery-File-Upload/issues/3633\u000a              form.submit();\u000a              // Insert the file input fields at their original location\u000a              // by replacing the clones with the originals:\u000a              if (fileInputClones && fileInputClones.length) {\u000a                options.fileInput.each(function (index, input) {\u000a                  var clone = $(fileInputClones[index]);\u000a                  // Restore the original name and form properties:\u000a                  $(input)\u000a                    .prop('name', clone.prop('name'))\u000a                    .attr('form', clone.attr('form'));\u000a                  clone.replaceWith(input);\u000a                });\u000a              }\u000a            }, 0);\u000a          });\u000a          form.append(iframe).appendTo(document.body);\u000a        },\u000a        abort: function () {\u000a          if (iframe) {\u000a            // javascript:false as iframe src aborts the request\u000a            // and prevents warning popups on HTTPS in IE6.\u000a            iframe.off('load').prop('src', initialIframeSrc);\u000a          }\u000a          if (form) {\u000a            form.remove();\u000a          }\u000a        }\u000a      };\u000a    }\u000a  });\u000a\u000a  // The iframe transport returns the iframe content document as response.\u000a  // The following adds converters from iframe to text, json, html, xml\u000a  // and script.\u000a  // Please note that the Content-Type for JSON responses has to be text/plain\u000a  // or text/html, if the browser doesn't include application/json in the\u000a  // Accept header, else IE will show a download dialog.\u000a  // The Content-Type for XML responses on the other hand has to be always\u000a  // application/xml or text/xml, so IE properly parses the XML response.\u000a  // See also\u000a  // https://github.com/blueimp/jQuery-File-Upload/wiki/Setup#content-type-negotiation\u000a  $.ajaxSetup({\u000a    converters: {\u000a      'iframe text': function (iframe) {\u000a        return iframe && $(iframe[0].body).text();\u000a      },\u000a      'iframe json': function (iframe) {\u000a        return iframe && jsonAPI[jsonParse]($(iframe[0].body).text());\u000a      },\u000a      'iframe html': function (iframe) {\u000a        return iframe && $(iframe[0].body).html();\u000a      },\u000a      'iframe xml': function (iframe) {\u000a        var xmlDoc = iframe && iframe[0];\u000a        return xmlDoc && $.isXMLDoc(xmlDoc)\u000a          ? xmlDoc\u000a          : $.parseXML(\u000a              (xmlDoc.XMLDocument && xmlDoc.XMLDocument.xml) ||\u000a                $(xmlDoc.body).html()\u000a            );\u000a      },\u000a      'iframe script': function (iframe) {\u000a        return iframe && $.globalEval($(iframe[0].body).text());\u000a      }\u000a    }\u000a  });\u000a});\u000a\u000a;\u000a
p0
.