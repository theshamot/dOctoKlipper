V// source: js/app/main.js\u000a$(function () {\u000a    OctoPrint = window.OctoPrint;\u000a\u000a    // show page loading overlay (if enabled)\u000a    $("#page-container-loading").show();\u000a\u000a    //~~ Lodash setup\u000a\u000a    _.mixin({sprintf: sprintf, vsprintf: vsprintf});\u000a\u000a    //~~ Knockout setup\u000a\u000a    ko.options.createChildContextWithAs = true;\u000a    ko.options.foreachHidesDestroyed = true;\u000a\u000a    //~~ Logging setup\u000a\u000a    log.setLevel(CONFIG_DEBUG ? log.levels.DEBUG : log.levels.INFO);\u000a\u000a    //~~ OctoPrint client setup\u000a    OctoPrint.options.baseurl = BASEURL;\u000a\u000a    var l10n = getQueryParameterByName("l10n");\u000a    if (l10n) {\u000a        OctoPrint.options.locale = l10n;\u000a    }\u000a\u000a    //~~ some CoreUI specific stuff we put into OctoPrint.coreui\u000a\u000a    OctoPrint.coreui = (function () {\u000a        var exports = {\u000a            browserTabVisibility: undefined,\u000a            selectedTab: undefined,\u000a            settingsOpen: false,\u000a            wizardOpen: false,\u000a            browser: {\u000a                chrome: false,\u000a                firefox: false,\u000a                safari: false,\u000a                ie: false,\u000a                edge: false,\u000a                opera: false,\u000a\u000a                mobile: false,\u000a                desktop: false\u000a            },\u000a            viewmodels: {},\u000a            startedUp: false\u000a        };\u000a\u000a        var browserVisibilityCallbacks = [];\u000a\u000a        var getHiddenProp = function () {\u000a            var prefixes = ["webkit", "moz", "ms", "o"];\u000a\u000a            // if "hidden" is natively supported just return it\u000a            if ("hidden" in document) {\u000a                return "hidden";\u000a            }\u000a\u000a            // otherwise loop over all the known prefixes until we find one\u000a            var vendorPrefix = _.find(prefixes, function (prefix) {\u000a                return prefix + "Hidden" in document;\u000a            });\u000a            if (vendorPrefix !== undefined) {\u000a                return vendorPrefix + "Hidden";\u000a            }\u000a\u000a            // nothing found\u000a            return undefined;\u000a        };\u000a\u000a        var isHidden = function () {\u000a            var prop = getHiddenProp();\u000a            if (!prop) return false;\u000a\u000a            return document[prop];\u000a        };\u000a\u000a        var updateBrowserVisibility = function () {\u000a            var visible = !isHidden();\u000a            exports.browserTabVisible = visible;\u000a            _.each(browserVisibilityCallbacks, function (callback) {\u000a                callback(visible);\u000a            });\u000a        };\u000a\u000a        // register for browser visibility tracking\u000a\u000a        var prop = getHiddenProp();\u000a        if (prop) {\u000a            var eventName = prop.replace(/[H|h]idden/, "") + "visibilitychange";\u000a            document.addEventListener(eventName, updateBrowserVisibility);\u000a\u000a            updateBrowserVisibility();\u000a        }\u000a\u000a        // determine browser - loosely based on is.js\u000a\u000a        var navigator = window.navigator;\u000a        var userAgent = ((navigator && navigator.userAgent) || "").toLowerCase();\u000a        var vendor = ((navigator && navigator.vendor) || "").toLowerCase();\u000a\u000a        exports.browser.opera = userAgent.match(/opera|opr/) !== null;\u000a        exports.browser.chrome =\u000a            !exports.browser.opera &&\u000a            /google inc/.test(vendor) &&\u000a            userAgent.match(/chrome|crios/) !== null;\u000a        exports.browser.firefox = userAgent.match(/firefox|fxios/) !== null;\u000a        exports.browser.ie = userAgent.match(/msie|trident/) !== null;\u000a        exports.browser.edge = userAgent.match(/edge/) !== null;\u000a        exports.browser.safari =\u000a            !exports.browser.chrome &&\u000a            !exports.browser.edge &&\u000a            !exports.browser.opera &&\u000a            userAgent.match(/safari/) !== null;\u000a\u000a        exports.browser.mobile = $.browser.mobile;\u000a        exports.browser.desktop = !exports.browser.mobile;\u000a\u000a        // exports\u000a\u000a        exports.isVisible = function () {\u000a            return !isHidden();\u000a        };\u000a        exports.onBrowserVisibilityChange = function (callback) {\u000a            browserVisibilityCallbacks.push(callback);\u000a        };\u000a        exports.hashFromTabChange = false;\u000a        exports.onTabChange = function (current, previous) {\u000a            log.debug(\u000a                "Selected OctoPrint tab changed: previous = " +\u000a                    previous +\u000a                    ", current = " +\u000a                    current\u000a            );\u000a            OctoPrint.coreui.selectedTab = current;\u000a            callViewModels(allViewModels, "onTabChange", [current, previous]);\u000a        };\u000a        exports.onAfterTabChange = function (current, previous) {\u000a            callViewModels(allViewModels, "onAfterTabChange", [current, previous]);\u000a        };\u000a        exports.updateTab = function (force) {\u000a            force = !!force;\u000a\u000a            if (exports.hashFromTabChange) {\u000a                exports.hashFromTabChange = false;\u000a                return;\u000a            }\u000a\u000a            var selectTab = function (tab) {\u000a                if (tab.hash !== exports.selectedTab) {\u000a                    if ($(tab).parent("li").hasClass("active") && force) {\u000a                        var current = tab.hash;\u000a                        var previous = exports.selectedTab;\u000a                        exports.onTabChange(current, previous);\u000a                        exports.onAfterTabChange(current, previous);\u000a                    } else {\u000a                        $(tab).tab("show");\u000a                    }\u000a                } else {\u000a                    window.location.hash = tab.hash;\u000a                }\u000a            };\u000a\u000a            var tabs = $("#tabs");\u000a\u000a            var hashtag = window.location.hash;\u000a            if (hashtag) {\u000a                var selectedTab = tabs.find('a[href="' + hashtag + '"]:visible');\u000a                if (selectedTab.length) {\u000a                    selectTab(selectedTab[0]);\u000a                    return;\u000a                }\u000a            }\u000a\u000a            var firstTab = tabs.find("a[data-toggle=tab]:visible").eq(0);\u000a            if (firstTab.length) {\u000a                selectTab(firstTab[0]);\u000a            }\u000a        };\u000a\u000a        return exports;\u000a    })();\u000a\u000a    log.debug("Browser environment:", OctoPrint.coreui.browser);\u000a\u000a    //~~ AJAX setup\u000a\u000a    // work around a stupid iOS6 bug where ajax requests get cached and only work once, as described at\u000a    // http://stackoverflow.com/questions/12506897/is-safari-on-ios-6-caching-ajax-results\u000a    $.ajaxPrefilter(function (options, originalOptions, jqXHR) {\u000a        if (options.type !== "GET") {\u000a            if (options.hasOwnProperty("headers")) {\u000a                options.headers["Cache-Control"] = "no-cache";\u000a            } else {\u000a                options.headers = {"Cache-Control": "no-cache"};\u000a            }\u000a        }\u000a    });\u000a\u000a    //~~ Initialize file upload plugin\u000a\u000a    $.widget("blueimp.fileupload", $.blueimp.fileupload, {\u000a        options: {\u000a            dropZone: null,\u000a            pasteZone: null\u000a        }\u000a    });\u000a\u000a    //~~ Initialize i18n\u000a\u000a    var catalog = window["BABEL_TO_LOAD_" + LOCALE];\u000a    if (catalog === undefined) {\u000a        catalog = {\u000a            messages: undefined,\u000a            plural_expr: undefined,\u000a            locale: undefined,\u000a            domain: undefined\u000a        };\u000a    }\u000a    babel.Translations.load(catalog).install();\u000a\u000a    moment.locale(LOCALE);\u000a\u000a    // Dummy translation requests for dynamic strings supplied by the backend\u000a    // noinspection BadExpressionStatementJS\u000a    [\u000a        // printer states\u000a        gettext("Offline"),\u000a        gettext("Opening serial connection"),\u000a        gettext("Detecting serial connection"),\u000a        gettext("Connecting"),\u000a        gettext("Operational"),\u000a        gettext("Starting"),\u000a        gettext("Starting print from SD"),\u000a        gettext("Printing from SD"),\u000a        gettext("Sending file to SD"),\u000a        gettext("Printing"),\u000a        gettext("Paused"),\u000a        gettext("Closed"),\u000a        gettext("Transferring file to SD"),\u000a        gettext("Pausing"),\u000a        gettext("Resuming"),\u000a        gettext("Cancelling"),\u000a        gettext("Finishing")\u000a    ];\u000a\u000a    //~~ Initialize PNotify\u000a\u000a    PNotify.prototype.options.styling = "bootstrap2";\u000a    PNotify.prototype.options.mouse_reset = false;\u000a    PNotify.prototype.options.stack.firstpos1 = 40 + 20; // navbar + 20\u000a    PNotify.prototype.options.stack.firstpos2 = 20;\u000a    PNotify.prototype.options.stack.spacing1 = 20;\u000a    PNotify.prototype.options.stack.spacing2 = 20;\u000a    PNotify.prototype.options.stack.context = $("#page-container-main");\u000a    PNotify.prototype.options.delay = 5000;\u000a    PNotify.prototype.options.animate_speed = "fast";\u000a\u000a    PNotify.prototype.options.maxheight.maxheight = function () {\u000a        return $(window).height() - 170; // top margin + header + footer + some safety margin\u000a    };\u000a\u000a    // single button notify\u000a    PNotify.singleButtonNotify = function (options) {\u000a        if (\u000a            !options.confirm ||\u000a            !options.confirm.buttons ||\u000a            !options.confirm.buttons.length\u000a        ) {\u000a            return new PNotify(options);\u000a        }\u000a\u000a        var autoDisplay = options.auto_display !== false;\u000a\u000a        var params = $.extend(true, {}, options);\u000a        params.auto_display = false;\u000a\u000a        var notify = new PNotify(params);\u000a        notify = PNotify.fixSingleButton(notify, options);\u000a\u000a        if (autoDisplay) {\u000a            notify.open();\u000a        }\u000a        return notify;\u000a    };\u000a\u000a    PNotify.fixSingleButton = function (notify, options) {\u000a        if (\u000a            !options.confirm ||\u000a            !options.confirm.buttons ||\u000a            !options.confirm.buttons.length\u000a        ) {\u000a            return notify;\u000a        }\u000a\u000a        notify.options.confirm.buttons = [notify.options.confirm.buttons[0]];\u000a        notify.modules.confirm.makeDialog(notify, notify.options.confirm);\u000a        return notify;\u000a    };\u000a\u000a    //~~ Initialize view models\u000a\u000a    // the view model map is our basic look up table for dependencies that may be injected into other view models\u000a    var viewModelMap = {};\u000a\u000a    // Fix Function#name on browsers that do not support it (IE):\u000a    // see: http://stackoverflow.com/questions/6903762/function-name-not-supported-in-ie\u000a    if (!function f() {}.name) {\u000a        Object.defineProperty(Function.prototype, "name", {\u000a            get: function () {\u000a                return this.toString().match(/^\u005cs*function\u005cs*(\u005cS*)\u005cs*\u005c(/)[1];\u000a            }\u000a        });\u000a    }\u000a\u000a    // helper to create a view model instance with injected constructor parameters from the view model map\u000a    var _createViewModelInstance = function (\u000a        viewModel,\u000a        viewModelMap,\u000a        optionalDependencyPass\u000a    ) {\u000a        // mirror the requested dependencies with an array of the viewModels\u000a        var viewModelParametersMap = function (parameter) {\u000a            // check if parameter is found within optional array and if all conditions are met return null instead of undefined\u000a            if (\u000a                optionalDependencyPass &&\u000a                viewModel.optional.indexOf(parameter) !== -1 &&\u000a                !viewModelMap[parameter]\u000a            ) {\u000a                log.debug(\u000a                    "Resolving optional parameter",\u000a                    [parameter],\u000a                    "without viewmodel"\u000a                );\u000a                return null; // null == "optional but not available"\u000a            }\u000a\u000a            return viewModelMap[parameter] || undefined; // undefined == "not available"\u000a        };\u000a\u000a        // try to resolve all of the view model's constructor parameters via our view model map\u000a        var constructorParameters =\u000a            _.map(viewModel.dependencies, viewModelParametersMap) || [];\u000a\u000a        if (constructorParameters.indexOf(undefined) !== -1) {\u000a            log.debug(\u000a                "Postponing",\u000a                viewModel.name,\u000a                "due to missing parameters:",\u000a                _.keys(\u000a                    _.pick(\u000a                        _.object(viewModel.dependencies, constructorParameters),\u000a                        _.isUndefined\u000a                    )\u000a                )\u000a            );\u000a            return;\u000a        }\u000a\u000a        // transform array into object if a plugin wants it as an object\u000a        constructorParameters = viewModel.returnObject\u000a            ? _.object(viewModel.dependencies, constructorParameters)\u000a            : constructorParameters;\u000a\u000a        // if we came this far then we could resolve all constructor parameters, so let's construct that view model\u000a        log.debug(\u000a            "Constructing",\u000a            viewModel.name,\u000a            "with parameters:",\u000a            viewModel.dependencies\u000a        );\u000a        return new viewModel.construct(constructorParameters);\u000a    };\u000a\u000a    // map any additional view model bindings we might need to make\u000a    var additionalBindings = {};\u000a    _.each(OCTOPRINT_ADDITIONAL_BINDINGS, function (bindings) {\u000a        var viewModelId = bindings[0];\u000a        var viewModelBindTargets = bindings[1];\u000a        if (!_.isArray(viewModelBindTargets)) {\u000a            viewModelBindTargets = [viewModelBindTargets];\u000a        }\u000a\u000a        if (!additionalBindings.hasOwnProperty(viewModelId)) {\u000a            additionalBindings[viewModelId] = viewModelBindTargets;\u000a        } else {\u000a            additionalBindings[viewModelId] = additionalBindings[viewModelId].concat(\u000a                viewModelBindTargets\u000a            );\u000a        }\u000a    });\u000a\u000a    // helper for translating the name of a view model class into an identifier for the view model map\u000a    var _getViewModelId = function (name) {\u000a        return name.substr(0, 1).toLowerCase() + name.substr(1); // FooBarViewModel => fooBarViewModel\u000a    };\u000a\u000a    // instantiation loop, will make multiple passes over the list of unprocessed view models until all\u000a    // view models have been successfully instantiated with all of their dependencies or no changes can be made\u000a    // any more which means not all view models can be instantiated due to missing dependencies\u000a    var unprocessedViewModels = OCTOPRINT_VIEWMODELS.slice();\u000a    unprocessedViewModels = unprocessedViewModels.concat(ADDITIONAL_VIEWMODELS);\u000a\u000a    var allViewModels = [];\u000a    var allViewModelData = [];\u000a    var pass = 1;\u000a    var optionalDependencyPass = false;\u000a    log.info("Starting dependency resolution...");\u000a    while (unprocessedViewModels.length > 0) {\u000a        log.debug("Dependency resolution, pass #" + pass);\u000a        var startLength = unprocessedViewModels.length;\u000a        var postponed = [];\u000a\u000a        // now try to instantiate every one of our as of yet unprocessed view model descriptors\u000a        while (unprocessedViewModels.length > 0) {\u000a            var viewModel = unprocessedViewModels.shift();\u000a\u000a            // wrap anything not object related into an object\u000a            if (!_.isPlainObject(viewModel)) {\u000a                viewModel = {\u000a                    construct: _.isArray(viewModel) ? viewModel[0] : viewModel,\u000a                    dependencies: viewModel[1] || [],\u000a                    elements: viewModel[2] || [],\u000a                    optional: viewModel[3] || []\u000a                };\u000a            }\u000a\u000a            // make sure we have atleast a function\u000a            if (!_.isFunction(viewModel.construct)) {\u000a                log.error("No function to instantiate with", viewModel);\u000a                continue;\u000a            }\u000a\u000a            // if name is not set, get name from constructor, if it's an anonymous function generate one\u000a            viewModel.name =\u000a                viewModel.name ||\u000a                _getViewModelId(viewModel.construct.name) ||\u000a                _.uniqueId("unnamedViewModel");\u000a\u000a            // no alternative names? empty array\u000a            viewModel.additionalNames = viewModel.additionalNames || [];\u000a\u000a            // make sure all value's are set and in an array\u000a            _.each(["dependencies", "elements", "optional", "additionalNames"], function (\u000a                key\u000a            ) {\u000a                if (viewModel[key] === undefined) {\u000a                    viewModel[key] = [];\u000a                } else {\u000a                    viewModel[key] = _.isArray(viewModel[key])\u000a                        ? viewModel[key]\u000a                        : [viewModel[key]];\u000a                }\u000a            });\u000a\u000a            // make sure that we don't have two view models going by the same name\u000a            if (_.has(viewModelMap, viewModel.name)) {\u000a                log.error("Duplicate name while instantiating " + viewModel.name);\u000a                continue;\u000a            }\u000a\u000a            var viewModelInstance;\u000a            try {\u000a                viewModelInstance = _createViewModelInstance(\u000a                    viewModel,\u000a                    viewModelMap,\u000a                    optionalDependencyPass\u000a                );\u000a            } catch (exc) {\u000a                if (typeof Sentry !== "undefined") {\u000a                    Sentry.captureException(exc);\u000a                }\u000a                log.error("Error instantiating", viewModel.name, ":", exc.stack || exc);\u000a                continue;\u000a            }\u000a\u000a            // our view model couldn't yet be instantiated, so postpone it for a bit\u000a            if (viewModelInstance === undefined) {\u000a                postponed.push(viewModel);\u000a                continue;\u000a            }\u000a\u000a            // we could resolve the dependencies and the view model is not defined yet => add it, it's now fully processed\u000a            var viewModelBindTargets = viewModel.elements;\u000a\u000a            if (additionalBindings.hasOwnProperty(viewModel.name)) {\u000a                viewModelBindTargets = viewModelBindTargets.concat(\u000a                    additionalBindings[viewModel.name]\u000a                );\u000a            }\u000a\u000a            allViewModelData.push([viewModelInstance, viewModelBindTargets]);\u000a            allViewModels.push(viewModelInstance);\u000a            viewModelMap[viewModel.name] = viewModelInstance;\u000a\u000a            if (viewModel.additionalNames.length) {\u000a                var registeredAdditionalNames = [];\u000a                _.each(viewModel.additionalNames, function (additionalName) {\u000a                    if (!_.has(viewModelMap, additionalName)) {\u000a                        viewModelMap[additionalName] = viewModelInstance;\u000a                        registeredAdditionalNames.push(additionalName);\u000a                    }\u000a                });\u000a\u000a                if (registeredAdditionalNames.length) {\u000a                    log.debug(\u000a                        "Registered",\u000a                        viewModel.name,\u000a                        "under these additional names:",\u000a                        registeredAdditionalNames\u000a                    );\u000a                }\u000a            }\u000a        }\u000a\u000a        // anything that's now in the postponed list has to be readded to the unprocessedViewModels\u000a        unprocessedViewModels = unprocessedViewModels.concat(postponed);\u000a\u000a        // if we still have the same amount of items in our list of unprocessed view models it means that we\u000a        // couldn't instantiate any more view models over a whole iteration, which in turn mean we can't resolve the\u000a        // dependencies of remaining ones, so log that as an error and then quit the loop\u000a        if (unprocessedViewModels.length === startLength) {\u000a            // I'm gonna let you finish but we will do another pass with the optional dependencies flag enabled\u000a            if (!optionalDependencyPass) {\u000a                log.debug("Resolving next pass with optional dependencies flag enabled");\u000a                optionalDependencyPass = true;\u000a            } else {\u000a                log.error(\u000a                    "Could not instantiate the following view models due to unresolvable dependencies:"\u000a                );\u000a                _.each(unprocessedViewModels, function (entry) {\u000a                    log.error(\u000a                        entry.name +\u000a                            " (missing: " +\u000a                            _.filter(entry.dependencies, function (id) {\u000a                                return !_.has(viewModelMap, id);\u000a                            }).join(", ") +\u000a                            " )"\u000a                    );\u000a                });\u000a                break;\u000a            }\u000a        }\u000a\u000a        log.debug(\u000a            "Dependency resolution pass #" +\u000a                pass +\u000a                " finished, " +\u000a                unprocessedViewModels.length +\u000a                " view models left to process"\u000a        );\u000a        pass++;\u000a    }\u000a    log.info("... dependency resolution done");\u000a    OctoPrint.coreui.viewmodels = viewModelMap;\u000a\u000a    //~~ some additional hooks and initializations\u000a\u000a    // make sure modals max out at the window height\u000a    $.fn.modal.defaults.maxHeight = function () {\u000a        // subtract the height of the modal header and footer\u000a        return $(window).height() - 165;\u000a    };\u000a\u000a    // jquery plugin to select all text in an element\u000a    // originally from: http://stackoverflow.com/a/987376\u000a    $.fn.selectText = function () {\u000a        var doc = document;\u000a        var element = this[0];\u000a        var range, selection;\u000a\u000a        if (doc.body.createTextRange) {\u000a            range = document.body.createTextRange();\u000a            range.moveToElementText(element);\u000a            range.select();\u000a        } else if (window.getSelection) {\u000a            selection = window.getSelection();\u000a            range = document.createRange();\u000a            range.selectNodeContents(element);\u000a            selection.removeAllRanges();\u000a            selection.addRange(range);\u000a        }\u000a    };\u000a\u000a    $.fn.isChildOf = function (element) {\u000a        return $(element).has(this).length > 0;\u000a    };\u000a\u000a    // from http://jsfiddle.net/KyleMit/X9tgY/\u000a    $.fn.contextMenu = function (settings) {\u000a        return this.each(function () {\u000a            // Open context menu\u000a            $(this).on("contextmenu", function (e) {\u000a                // return native menu if pressing control\u000a                if (e.ctrlKey) return;\u000a\u000a                $(settings.menuSelector)\u000a                    .data("invokedOn", $(e.target))\u000a                    .data("contextParent", $(this))\u000a                    .show()\u000a                    .css({\u000a                        "position": "fixed",\u000a                        "left": getMenuPosition(e.clientX, "width", "scrollLeft"),\u000a                        "top": getMenuPosition(e.clientY, "height", "scrollTop"),\u000a                        "z-index": 9999\u000a                    })\u000a                    .off("click")\u000a                    .on("click", function (e) {\u000a                        if (e.target.tagName.toLowerCase() === "input") return;\u000a\u000a                        $(this).hide();\u000a\u000a                        settings.menuSelected.call(\u000a                            this,\u000a                            $(this).data("invokedOn"),\u000a                            $(this).data("contextParent"),\u000a                            $(e.target)\u000a                        );\u000a                    });\u000a\u000a                return false;\u000a            });\u000a\u000a            //make sure menu closes on any click\u000a            $(document).click(function () {\u000a                $(settings.menuSelector).hide();\u000a            });\u000a        });\u000a\u000a        function getMenuPosition(mouse, direction, scrollDir) {\u000a            var win = $(window)[direction](),\u000a                scroll = $(window)[scrollDir](),\u000a                menu = $(settings.menuSelector)[direction](),\u000a                position = mouse + scroll;\u000a\u000a            // opening menu would pass the side of the page\u000a            if (mouse + menu > win && menu < mouse) position -= menu;\u000a\u000a            return position;\u000a        }\u000a    };\u000a\u000a    $.fn.lazyload = function () {\u000a        return this.each(function () {\u000a            if (this.tagName.toLowerCase() !== "img") return;\u000a\u000a            var src = this.getAttribute("data-src");\u000a            if (src) {\u000a                this.setAttribute("src", src);\u000a                this.removeAttribute("data-src");\u000a            }\u000a        });\u000a    };\u000a\u000a    // Allow components to react to tab change\u000a    var tabs = $("#tabs").find('a[data-toggle="tab"]');\u000a    tabs.on("show", function (e) {\u000a        var current = e.target.hash;\u000a        var previous = e.relatedTarget ? e.relatedTarget.hash : undefined;\u000a        OctoPrint.coreui.onTabChange(current, previous);\u000a    });\u000a\u000a    tabs.on("shown", function (e) {\u000a        var current = e.target.hash;\u000a        var previous = e.relatedTarget ? e.relatedTarget.hash : undefined;\u000a        OctoPrint.coreui.onAfterTabChange(current, previous);\u000a\u000a        // make sure we also update the hash but stick to the current scroll position\u000a        var scrollmem = $("body").scrollTop() || $("html").scrollTop();\u000a        OctoPrint.coreui.hashFromTabChange = true;\u000a        window.location.hash = current;\u000a        $("html,body").scrollTop(scrollmem);\u000a    });\u000a\u000a    // Fix input element click problems on dropdowns\u000a    $(".dropdown input, .dropdown label").click(function (e) {\u000a        e.stopPropagation();\u000a    });\u000a\u000a    // prevent default action for drag-n-drop\u000a    $(document).bind("drop dragover", function (e) {\u000a        e.preventDefault();\u000a    });\u000a\u000a    // reload overlay\u000a    $("#reloadui_overlay_reload").click(function () {\u000a        location.reload();\u000a    });\u000a\u000a    //~~ final initialization - passive login, settings fetch, view model binding\u000a\u000a    if (!_.has(viewModelMap, "settingsViewModel")) {\u000a        throw new Error("settingsViewModel is missing, can't run UI");\u000a    }\u000a\u000a    if (\u000a        !_.has(viewModelMap, "accessViewModel") ||\u000a        !viewModelMap["accessViewModel"].permissions\u000a    ) {\u000a        throw new Error("accessViewmodel is missing or incomplete, can't run UI");\u000a    }\u000a\u000a    if (!_.has(viewModelMap, "loginStateViewModel")) {\u000a        throw new Error("loginStateViewModel is missing, can't run UI");\u000a    }\u000a\u000a    if (!_.has(viewModelMap, "uiStateViewModel")) {\u000a        throw new Error("uiStateViewModel is missing, can't run UI");\u000a    }\u000a\u000a    var bindViewModels = function () {\u000a        try {\u000a            log.info("Going to bind " + allViewModelData.length + " view models...");\u000a            _.each(allViewModelData, function (viewModelData) {\u000a                try {\u000a                    if (!Array.isArray(viewModelData) || viewModelData.length !== 2) {\u000a                        if (typeof Sentry !== "undefined") {\u000a                            Sentry.captureException(\u000a                                new Error(\u000a                                    "View model data for" +\u000a                                        viewModelData.constructor.name +\u000a                                        "has wrong format, expected 2-tuple (viewModel, targets), got:" +\u000a                                        viewModelData\u000a                                )\u000a                            );\u000a                        }\u000a                        log.error(\u000a                            "View model data for",\u000a                            viewModelData.constructor.name,\u000a                            "has wrong format, expected 2-tuple (viewModel, targets), got:",\u000a                            viewModelData\u000a                        );\u000a                        return;\u000a                    }\u000a\u000a                    var viewModel = viewModelData[0];\u000a                    var targets = viewModelData[1];\u000a\u000a                    if (targets === undefined) {\u000a                        log.error(\u000a                            "No binding targets defined for view model",\u000a                            viewMode.constructor.name\u000a                        );\u000a                        return;\u000a                    }\u000a\u000a                    if (!_.isArray(targets)) {\u000a                        targets = [targets];\u000a                    }\u000a\u000a                    try {\u000a                        callViewModel(viewModel, "onBeforeBinding", undefined, true);\u000a                    } catch (exc) {\u000a                        if (typeof Sentry !== "undefined") {\u000a                            Sentry.captureException(exc);\u000a                        }\u000a                        log.error(\u000a                            "Error calling onBeforeBinding on view model",\u000a                            viewModel.constructor.name,\u000a                            ":",\u000a                            exc.stack || exc\u000a                        );\u000a                        return;\u000a                    }\u000a\u000a                    if (targets !== undefined) {\u000a                        if (!_.isArray(targets)) {\u000a                            targets = [targets];\u000a                        }\u000a\u000a                        viewModel._bindings = [];\u000a\u000a                        _.each(targets, function (target) {\u000a                            if (target === undefined) {\u000a                                log.error(\u000a                                    "Undefined target for view model",\u000a                                    viewModel.constructor.name\u000a                                );\u000a                                return;\u000a                            }\u000a\u000a                            var object;\u000a                            if (!(target instanceof jQuery)) {\u000a                                try {\u000a                                    object = $(target);\u000a                                } catch (exc) {\u000a                                    if (typeof Sentry !== "undefined") {\u000a                                        Sentry.captureException(exc);\u000a                                    }\u000a                                    log.error(\u000a                                        "Error while attempting to jquery-fy target",\u000a                                        target,\u000a                                        "of view model",\u000a                                        viewModel.constructor.name,\u000a                                        ":",\u000a                                        exc.stack || exc\u000a                                    );\u000a                                    return;\u000a                                }\u000a                            } else {\u000a                                object = target;\u000a                            }\u000a\u000a                            if (object === undefined || !object.length) {\u000a                                log.info(\u000a                                    "Did not bind view model",\u000a                                    viewModel.constructor.name,\u000a                                    "to target",\u000a                                    target,\u000a                                    "since it does not exist"\u000a                                );\u000a                                return;\u000a                            }\u000a\u000a                            var element = object.get(0);\u000a                            if (element === undefined) {\u000a                                log.info(\u000a                                    "Did not bind view model",\u000a                                    viewModel.constructor.name,\u000a                                    "to target",\u000a                                    target,\u000a                                    "since it does not exist"\u000a                                );\u000a                                return;\u000a                            }\u000a\u000a                            try {\u000a                                ko.applyBindings(viewModel, element);\u000a                                viewModel._bindings.push(target);\u000a\u000a                                callViewModel(\u000a                                    viewModel,\u000a                                    "onBoundTo",\u000a                                    [target, element],\u000a                                    true\u000a                                );\u000a\u000a                                log.debug(\u000a                                    "View model",\u000a                                    viewModel.constructor.name,\u000a                                    "bound to",\u000a                                    target\u000a                                );\u000a                            } catch (exc) {\u000a                                if (typeof Sentry !== "undefined") {\u000a                                    Sentry.captureException(exc);\u000a                                }\u000a                                log.error(\u000a                                    "Could not bind view model",\u000a                                    viewModel.constructor.name,\u000a                                    "to target",\u000a                                    target,\u000a                                    ":",\u000a                                    exc.stack || exc\u000a                                );\u000a                            }\u000a                        });\u000a                    }\u000a\u000a                    viewModel._unbound =\u000a                        viewModel._bindings === undefined ||\u000a                        viewModel._bindings.length === 0;\u000a                    viewModel._bound =\u000a                        viewModel._bindings && viewModel._bindings.length > 0;\u000a\u000a                    callViewModel(viewModel, "onAfterBinding");\u000a                } catch (exc) {\u000a                    var name;\u000a                    try {\u000a                        name = viewModel.constructor.name;\u000a                    } catch (exc) {\u000a                        name = "n/a";\u000a                    }\u000a                    log.error(\u000a                        "Error while processing view model",\u000a                        name,\u000a                        "for binding:",\u000a                        exc.stack || exc\u000a                    );\u000a                }\u000a            });\u000a\u000a            callViewModels(allViewModels, "onAllBound", [allViewModels]);\u000a            log.info("... binding done");\u000a\u000a            // make sure we can track the browser tab visibility\u000a            OctoPrint.coreui.onBrowserVisibilityChange(function (status) {\u000a                log.debug("Browser tab is now " + (status ? "visible" : "hidden"));\u000a                callViewModels(allViewModels, "onBrowserTabVisibilityChange", [status]);\u000a            });\u000a\u000a            $(window).on("hashchange", function () {\u000a                OctoPrint.coreui.updateTab();\u000a            });\u000a\u000a            log.info("Application startup complete");\u000a\u000a            viewModelMap["uiStateViewModel"].loading(false);\u000a        } catch (exc) {\u000a            if (typeof Sentry !== "undefined") {\u000a                Sentry.captureException(exc);\u000a            }\u000a            viewModelMap["uiStateViewModel"].showLoadingError(\u000a                "Application startup failed."\u000a            );\u000a            throw exc;\u000a        }\u000a\u000a        // startup complete\u000a        callViewModels(allViewModels, "onStartupComplete");\u000a        setOnViewModels(allViewModels, "_startupComplete", true);\u000a\u000a        // this will also allow selecting any tabs that will be hidden later due to overflowing since our\u000a        // overflow plugin tabdrop hasn't run yet\u000a        OctoPrint.coreui.updateTab(true);\u000a\u000a        // Use bootstrap tabdrop for tabs and pills\u000a        $(".nav-pills, .nav-tabs").tabdrop();\u000a\u000a        OctoPrint.coreui.startedUp = true;\u000a    };\u000a\u000a    var fetchSettings = function () {\u000a        log.info("Finalizing application startup");\u000a\u000a        //~~ Starting up the app\u000a        callViewModels(allViewModels, "onStartup");\u000a\u000a        viewModelMap["settingsViewModel"]\u000a            .requestData()\u000a            .done(function () {\u000a                var adjustModalDefaultBehaviour = function () {\u000a                    if (\u000a                        viewModelMap[\u000a                            "settingsViewModel"\u000a                        ].appearance_closeModalsWithClick()\u000a                    ) {\u000a                        $.fn.modal.defaults.backdrop = true;\u000a                    } else {\u000a                        $.fn.modal.defaults.backdrop = "static";\u000a                    }\u000a                };\u000a                adjustModalDefaultBehaviour();\u000a                viewModelMap[\u000a                    "settingsViewModel"\u000a                ].appearance_closeModalsWithClick.subscribe(adjustModalDefaultBehaviour);\u000a\u000a                // There appears to be an odd race condition either in JQuery's AJAX implementation or\u000a                // the browser's implementation of XHR, causing a second GET request from inside the\u000a                // completion handler of the very same request to never get its completion handler called\u000a                // if ETag headers are present on the response (the status code of the request does NOT\u000a                // seem to matter here, only that the ETag header is present).\u000a                //\u000a                // Minimal example with which I was able to reproduce this behaviour can be found\u000a                // at https://gist.github.com/foosel/b2ddb9ebd71b0b63a749444651bfce3f\u000a                //\u000a                // Decoupling all consecutive calls from this done event handler hence is an easy way\u000a                // to avoid this problem. A zero timeout should do the trick nicely.\u000a                window.setTimeout(bindViewModels, 0);\u000a            })\u000a            .fail(function () {\u000a                viewModelMap["uiStateViewModel"].showLoadingError(\u000a                    "Initial settings fetch failed."\u000a                );\u000a            });\u000a    };\u000a\u000a    log.info("Initial application setup done, connecting to server...");\u000a\u000a    /**\u000a     * The following looks a bit complicated, so let me explain...\u000a     *\u000a     * Once we connect to the server (and that also includes consecutive reconnects), the\u000a     * first thing we need to do is perform a passive login to a) establish a proper request\u000a     * session with the server and b) figure out the login status of our client. That passive\u000a     * login will be responded to with our session cookie and we must make absolutely sure that\u000a     * this cannot be overridden by any concurrent requests. E.g. if we would send the passive\u000a     * login request and also something like a settings fetch, the settings would not have the\u000a     * cookie yet, hence the server would generate a new session for that request, and if the\u000a     * response for the settings now arrives later than the passive login we'll get our\u000a     * session cookie from that login directly overwritten again. That will not only lead to\u000a     * us losing our login session with the server but also the client _thinking_ it is logged\u000a     * in when in fact it isn't. See also #1881.\u000a     *\u000a     * So what we do here is ensure that we send the passive login request _and nothing else_\u000a     * until that has been responded to and hence our session been properly established. Only\u000a     * then we may trigger stuff like the various view model callbacks that might cause\u000a     * additional requests.\u000a     *\u000a     * onServerConnect below takes care of the passive login. Only once that's completed it tells\u000a     * our DataUpdater that it's ok to trigger any callbacks in view models. On the initial\u000a     * server connect (during first initialization) we also trigger the settings fetch and\u000a     * binding procedure once that's done, but only then.\u000a     *\u000a     * Or, as a fancy diagram: https://gist.githubusercontent.com/foosel/0cdc3a03cf5311804271f12e87293c0c/raw/abc84fdc3b13030d70961539d9c132ae39c32085/octoprint_web_startup.txt\u000a     */\u000a\u000a    var onServerConnect = function () {\u000a        // Initialize our permissions\u000a        viewModelMap["accessViewModel"].permissions.initialize();\u000a\u000a        // Always perform a passive login on server (re)connect. No need for\u000a        // onServerConnect/onServerReconnect on the LoginStateViewModel with this in place.\u000a        return viewModelMap["loginStateViewModel"]\u000a            .requestData()\u000a            .done(function () {\u000a                // Only mark our data updater as initialized once we've done our initial\u000a                // passive login request.\u000a                //\u000a                // This is to ensure that we have no concurrent requests triggered by socket events\u000a                // overriding each other's session during app initialization\u000a                dataUpdater.initialized();\u000a            })\u000a            .fail(function () {\u000a                viewModelMap["uiStateViewModel"].showLoadingError(\u000a                    "Passive login failed."\u000a                );\u000a            });\u000a    };\u000a\u000a    var dataUpdater = new DataUpdater(allViewModels);\u000a    dataUpdater\u000a        .connect()\u000a        .done(function () {\u000a            // make sure we trigger onServerConnect should we dis- and reconnect to the server\u000a            dataUpdater.connectCallback = onServerConnect;\u000a\u000a            // we are now connected to the server and need to change the loading message - jquery instead of\u000a            // binding because no bindings yet\u000a            $("#page-container-loading-header").html(\u000a                gettext("Loading OctoPrint's UI, please wait...")\u000a            );\u000a\u000a            // perform passive login first\u000a            onServerConnect().done(function () {\u000a                // then trigger a settings fetch\u000a                window.setTimeout(fetchSettings, 0);\u000a            });\u000a        })\u000a        .fail(function () {\u000a            viewModelMap["uiStateViewModel"].showLoadingError(\u000a                "Socket connection failed."\u000a            );\u000a        });\u000a});\u000a\u000a;\u000a
p0
.