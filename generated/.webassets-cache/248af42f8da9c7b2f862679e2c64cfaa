V// source: js/lib/jquery/jquery-ui.js\u000a/*! jQuery UI - v1.12.1 - 2020-11-03\u000a* http://jqueryui.com\u000a* Includes: widget.js, widgets/mouse.js\u000a* Copyright jQuery Foundation and other contributors; Licensed MIT */\u000a\u000a(function( factory ) {\u000a	if ( typeof define === "function" && define.amd ) {\u000a\u000a		// AMD. Register as an anonymous module.\u000a		define([ "jquery" ], factory );\u000a	} else {\u000a\u000a		// Browser globals\u000a		factory( jQuery );\u000a	}\u000a}(function( $ ) {\u000a\u000a$.ui = $.ui || {};\u000a\u000avar version = $.ui.version = "1.12.1";\u000a\u000a\u000a/*!\u000a * jQuery UI Widget 1.12.1\u000a * http://jqueryui.com\u000a *\u000a * Copyright jQuery Foundation and other contributors\u000a * Released under the MIT license.\u000a * http://jquery.org/license\u000a */\u000a\u000a//>>label: Widget\u000a//>>group: Core\u000a//>>description: Provides a factory for creating stateful widgets with a common API.\u000a//>>docs: http://api.jqueryui.com/jQuery.widget/\u000a//>>demos: http://jqueryui.com/widget/\u000a\u000a\u000a\u000avar widgetUuid = 0;\u000avar widgetSlice = Array.prototype.slice;\u000a\u000a$.cleanData = ( function( orig ) {\u000a	return function( elems ) {\u000a		var events, elem, i;\u000a		for ( i = 0; ( elem = elems[ i ] ) != null; i++ ) {\u000a			try {\u000a\u000a				// Only trigger remove when necessary to save time\u000a				events = $._data( elem, "events" );\u000a				if ( events && events.remove ) {\u000a					$( elem ).triggerHandler( "remove" );\u000a				}\u000a\u000a			// Http://bugs.jquery.com/ticket/8235\u000a			} catch ( e ) {}\u000a		}\u000a		orig( elems );\u000a	};\u000a} )( $.cleanData );\u000a\u000a$.widget = function( name, base, prototype ) {\u000a	var existingConstructor, constructor, basePrototype;\u000a\u000a	// ProxiedPrototype allows the provided prototype to remain unmodified\u000a	// so that it can be used as a mixin for multiple widgets (#8876)\u000a	var proxiedPrototype = {};\u000a\u000a	var namespace = name.split( "." )[ 0 ];\u000a	name = name.split( "." )[ 1 ];\u000a	var fullName = namespace + "-" + name;\u000a\u000a	if ( !prototype ) {\u000a		prototype = base;\u000a		base = $.Widget;\u000a	}\u000a\u000a	if ( $.isArray( prototype ) ) {\u000a		prototype = $.extend.apply( null, [ {} ].concat( prototype ) );\u000a	}\u000a\u000a	// Create selector for plugin\u000a	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {\u000a		return !!$.data( elem, fullName );\u000a	};\u000a\u000a	$[ namespace ] = $[ namespace ] || {};\u000a	existingConstructor = $[ namespace ][ name ];\u000a	constructor = $[ namespace ][ name ] = function( options, element ) {\u000a\u000a		// Allow instantiation without "new" keyword\u000a		if ( !this._createWidget ) {\u000a			return new constructor( options, element );\u000a		}\u000a\u000a		// Allow instantiation without initializing for simple inheritance\u000a		// must use "new" keyword (the code above always passes args)\u000a		if ( arguments.length ) {\u000a			this._createWidget( options, element );\u000a		}\u000a	};\u000a\u000a	// Extend with the existing constructor to carry over any static properties\u000a	$.extend( constructor, existingConstructor, {\u000a		version: prototype.version,\u000a\u000a		// Copy the object used to create the prototype in case we need to\u000a		// redefine the widget later\u000a		_proto: $.extend( {}, prototype ),\u000a\u000a		// Track widgets that inherit from this widget in case this widget is\u000a		// redefined after a widget inherits from it\u000a		_childConstructors: []\u000a	} );\u000a\u000a	basePrototype = new base();\u000a\u000a	// We need to make the options hash a property directly on the new instance\u000a	// otherwise we'll modify the options hash on the prototype that we're\u000a	// inheriting from\u000a	basePrototype.options = $.widget.extend( {}, basePrototype.options );\u000a	$.each( prototype, function( prop, value ) {\u000a		if ( !$.isFunction( value ) ) {\u000a			proxiedPrototype[ prop ] = value;\u000a			return;\u000a		}\u000a		proxiedPrototype[ prop ] = ( function() {\u000a			function _super() {\u000a				return base.prototype[ prop ].apply( this, arguments );\u000a			}\u000a\u000a			function _superApply( args ) {\u000a				return base.prototype[ prop ].apply( this, args );\u000a			}\u000a\u000a			return function() {\u000a				var __super = this._super;\u000a				var __superApply = this._superApply;\u000a				var returnValue;\u000a\u000a				this._super = _super;\u000a				this._superApply = _superApply;\u000a\u000a				returnValue = value.apply( this, arguments );\u000a\u000a				this._super = __super;\u000a				this._superApply = __superApply;\u000a\u000a				return returnValue;\u000a			};\u000a		} )();\u000a	} );\u000a	constructor.prototype = $.widget.extend( basePrototype, {\u000a\u000a		// TODO: remove support for widgetEventPrefix\u000a		// always use the name + a colon as the prefix, e.g., draggable:start\u000a		// don't prefix for widgets that aren't DOM-based\u000a		widgetEventPrefix: existingConstructor ? ( basePrototype.widgetEventPrefix || name ) : name\u000a	}, proxiedPrototype, {\u000a		constructor: constructor,\u000a		namespace: namespace,\u000a		widgetName: name,\u000a		widgetFullName: fullName\u000a	} );\u000a\u000a	// If this widget is being redefined then we need to find all widgets that\u000a	// are inheriting from it and redefine all of them so that they inherit from\u000a	// the new version of this widget. We're essentially trying to replace one\u000a	// level in the prototype chain.\u000a	if ( existingConstructor ) {\u000a		$.each( existingConstructor._childConstructors, function( i, child ) {\u000a			var childPrototype = child.prototype;\u000a\u000a			// Redefine the child widget using the same prototype that was\u000a			// originally used, but inherit from the new version of the base\u000a			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor,\u000a				child._proto );\u000a		} );\u000a\u000a		// Remove the list of existing child constructors from the old constructor\u000a		// so the old child constructors can be garbage collected\u000a		delete existingConstructor._childConstructors;\u000a	} else {\u000a		base._childConstructors.push( constructor );\u000a	}\u000a\u000a	$.widget.bridge( name, constructor );\u000a\u000a	return constructor;\u000a};\u000a\u000a$.widget.extend = function( target ) {\u000a	var input = widgetSlice.call( arguments, 1 );\u000a	var inputIndex = 0;\u000a	var inputLength = input.length;\u000a	var key;\u000a	var value;\u000a\u000a	for ( ; inputIndex < inputLength; inputIndex++ ) {\u000a		for ( key in input[ inputIndex ] ) {\u000a			value = input[ inputIndex ][ key ];\u000a			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {\u000a\u000a				// Clone objects\u000a				if ( $.isPlainObject( value ) ) {\u000a					target[ key ] = $.isPlainObject( target[ key ] ) ?\u000a						$.widget.extend( {}, target[ key ], value ) :\u000a\u000a						// Don't extend strings, arrays, etc. with objects\u000a						$.widget.extend( {}, value );\u000a\u000a				// Copy everything else by reference\u000a				} else {\u000a					target[ key ] = value;\u000a				}\u000a			}\u000a		}\u000a	}\u000a	return target;\u000a};\u000a\u000a$.widget.bridge = function( name, object ) {\u000a	var fullName = object.prototype.widgetFullName || name;\u000a	$.fn[ name ] = function( options ) {\u000a		var isMethodCall = typeof options === "string";\u000a		var args = widgetSlice.call( arguments, 1 );\u000a		var returnValue = this;\u000a\u000a		if ( isMethodCall ) {\u000a\u000a			// If this is an empty collection, we need to have the instance method\u000a			// return undefined instead of the jQuery instance\u000a			if ( !this.length && options === "instance" ) {\u000a				returnValue = undefined;\u000a			} else {\u000a				this.each( function() {\u000a					var methodValue;\u000a					var instance = $.data( this, fullName );\u000a\u000a					if ( options === "instance" ) {\u000a						returnValue = instance;\u000a						return false;\u000a					}\u000a\u000a					if ( !instance ) {\u000a						return $.error( "cannot call methods on " + name +\u000a							" prior to initialization; " +\u000a							"attempted to call method '" + options + "'" );\u000a					}\u000a\u000a					if ( !$.isFunction( instance[ options ] ) || options.charAt( 0 ) === "_" ) {\u000a						return $.error( "no such method '" + options + "' for " + name +\u000a							" widget instance" );\u000a					}\u000a\u000a					methodValue = instance[ options ].apply( instance, args );\u000a\u000a					if ( methodValue !== instance && methodValue !== undefined ) {\u000a						returnValue = methodValue && methodValue.jquery ?\u000a							returnValue.pushStack( methodValue.get() ) :\u000a							methodValue;\u000a						return false;\u000a					}\u000a				} );\u000a			}\u000a		} else {\u000a\u000a			// Allow multiple hashes to be passed on init\u000a			if ( args.length ) {\u000a				options = $.widget.extend.apply( null, [ options ].concat( args ) );\u000a			}\u000a\u000a			this.each( function() {\u000a				var instance = $.data( this, fullName );\u000a				if ( instance ) {\u000a					instance.option( options || {} );\u000a					if ( instance._init ) {\u000a						instance._init();\u000a					}\u000a				} else {\u000a					$.data( this, fullName, new object( options, this ) );\u000a				}\u000a			} );\u000a		}\u000a\u000a		return returnValue;\u000a	};\u000a};\u000a\u000a$.Widget = function( /* options, element */ ) {};\u000a$.Widget._childConstructors = [];\u000a\u000a$.Widget.prototype = {\u000a	widgetName: "widget",\u000a	widgetEventPrefix: "",\u000a	defaultElement: "<div>",\u000a\u000a	options: {\u000a		classes: {},\u000a		disabled: false,\u000a\u000a		// Callbacks\u000a		create: null\u000a	},\u000a\u000a	_createWidget: function( options, element ) {\u000a		element = $( element || this.defaultElement || this )[ 0 ];\u000a		this.element = $( element );\u000a		this.uuid = widgetUuid++;\u000a		this.eventNamespace = "." + this.widgetName + this.uuid;\u000a\u000a		this.bindings = $();\u000a		this.hoverable = $();\u000a		this.focusable = $();\u000a		this.classesElementLookup = {};\u000a\u000a		if ( element !== this ) {\u000a			$.data( element, this.widgetFullName, this );\u000a			this._on( true, this.element, {\u000a				remove: function( event ) {\u000a					if ( event.target === element ) {\u000a						this.destroy();\u000a					}\u000a				}\u000a			} );\u000a			this.document = $( element.style ?\u000a\u000a				// Element within the document\u000a				element.ownerDocument :\u000a\u000a				// Element is window or document\u000a				element.document || element );\u000a			this.window = $( this.document[ 0 ].defaultView || this.document[ 0 ].parentWindow );\u000a		}\u000a\u000a		this.options = $.widget.extend( {},\u000a			this.options,\u000a			this._getCreateOptions(),\u000a			options );\u000a\u000a		this._create();\u000a\u000a		if ( this.options.disabled ) {\u000a			this._setOptionDisabled( this.options.disabled );\u000a		}\u000a\u000a		this._trigger( "create", null, this._getCreateEventData() );\u000a		this._init();\u000a	},\u000a\u000a	_getCreateOptions: function() {\u000a		return {};\u000a	},\u000a\u000a	_getCreateEventData: $.noop,\u000a\u000a	_create: $.noop,\u000a\u000a	_init: $.noop,\u000a\u000a	destroy: function() {\u000a		var that = this;\u000a\u000a		this._destroy();\u000a		$.each( this.classesElementLookup, function( key, value ) {\u000a			that._removeClass( value, key );\u000a		} );\u000a\u000a		// We can probably remove the unbind calls in 2.0\u000a		// all event bindings should go through this._on()\u000a		this.element\u000a			.off( this.eventNamespace )\u000a			.removeData( this.widgetFullName );\u000a		this.widget()\u000a			.off( this.eventNamespace )\u000a			.removeAttr( "aria-disabled" );\u000a\u000a		// Clean up events and states\u000a		this.bindings.off( this.eventNamespace );\u000a	},\u000a\u000a	_destroy: $.noop,\u000a\u000a	widget: function() {\u000a		return this.element;\u000a	},\u000a\u000a	option: function( key, value ) {\u000a		var options = key;\u000a		var parts;\u000a		var curOption;\u000a		var i;\u000a\u000a		if ( arguments.length === 0 ) {\u000a\u000a			// Don't return a reference to the internal hash\u000a			return $.widget.extend( {}, this.options );\u000a		}\u000a\u000a		if ( typeof key === "string" ) {\u000a\u000a			// Handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }\u000a			options = {};\u000a			parts = key.split( "." );\u000a			key = parts.shift();\u000a			if ( parts.length ) {\u000a				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );\u000a				for ( i = 0; i < parts.length - 1; i++ ) {\u000a					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};\u000a					curOption = curOption[ parts[ i ] ];\u000a				}\u000a				key = parts.pop();\u000a				if ( arguments.length === 1 ) {\u000a					return curOption[ key ] === undefined ? null : curOption[ key ];\u000a				}\u000a				curOption[ key ] = value;\u000a			} else {\u000a				if ( arguments.length === 1 ) {\u000a					return this.options[ key ] === undefined ? null : this.options[ key ];\u000a				}\u000a				options[ key ] = value;\u000a			}\u000a		}\u000a\u000a		this._setOptions( options );\u000a\u000a		return this;\u000a	},\u000a\u000a	_setOptions: function( options ) {\u000a		var key;\u000a\u000a		for ( key in options ) {\u000a			this._setOption( key, options[ key ] );\u000a		}\u000a\u000a		return this;\u000a	},\u000a\u000a	_setOption: function( key, value ) {\u000a		if ( key === "classes" ) {\u000a			this._setOptionClasses( value );\u000a		}\u000a\u000a		this.options[ key ] = value;\u000a\u000a		if ( key === "disabled" ) {\u000a			this._setOptionDisabled( value );\u000a		}\u000a\u000a		return this;\u000a	},\u000a\u000a	_setOptionClasses: function( value ) {\u000a		var classKey, elements, currentElements;\u000a\u000a		for ( classKey in value ) {\u000a			currentElements = this.classesElementLookup[ classKey ];\u000a			if ( value[ classKey ] === this.options.classes[ classKey ] ||\u000a					!currentElements ||\u000a					!currentElements.length ) {\u000a				continue;\u000a			}\u000a\u000a			// We are doing this to create a new jQuery object because the _removeClass() call\u000a			// on the next line is going to destroy the reference to the current elements being\u000a			// tracked. We need to save a copy of this collection so that we can add the new classes\u000a			// below.\u000a			elements = $( currentElements.get() );\u000a			this._removeClass( currentElements, classKey );\u000a\u000a			// We don't use _addClass() here, because that uses this.options.classes\u000a			// for generating the string of classes. We want to use the value passed in from\u000a			// _setOption(), this is the new value of the classes option which was passed to\u000a			// _setOption(). We pass this value directly to _classes().\u000a			elements.addClass( this._classes( {\u000a				element: elements,\u000a				keys: classKey,\u000a				classes: value,\u000a				add: true\u000a			} ) );\u000a		}\u000a	},\u000a\u000a	_setOptionDisabled: function( value ) {\u000a		this._toggleClass( this.widget(), this.widgetFullName + "-disabled", null, !!value );\u000a\u000a		// If the widget is becoming disabled, then nothing is interactive\u000a		if ( value ) {\u000a			this._removeClass( this.hoverable, null, "ui-state-hover" );\u000a			this._removeClass( this.focusable, null, "ui-state-focus" );\u000a		}\u000a	},\u000a\u000a	enable: function() {\u000a		return this._setOptions( { disabled: false } );\u000a	},\u000a\u000a	disable: function() {\u000a		return this._setOptions( { disabled: true } );\u000a	},\u000a\u000a	_classes: function( options ) {\u000a		var full = [];\u000a		var that = this;\u000a\u000a		options = $.extend( {\u000a			element: this.element,\u000a			classes: this.options.classes || {}\u000a		}, options );\u000a\u000a		function processClassString( classes, checkOption ) {\u000a			var current, i;\u000a			for ( i = 0; i < classes.length; i++ ) {\u000a				current = that.classesElementLookup[ classes[ i ] ] || $();\u000a				if ( options.add ) {\u000a					current = $( $.unique( current.get().concat( options.element.get() ) ) );\u000a				} else {\u000a					current = $( current.not( options.element ).get() );\u000a				}\u000a				that.classesElementLookup[ classes[ i ] ] = current;\u000a				full.push( classes[ i ] );\u000a				if ( checkOption && options.classes[ classes[ i ] ] ) {\u000a					full.push( options.classes[ classes[ i ] ] );\u000a				}\u000a			}\u000a		}\u000a\u000a		this._on( options.element, {\u000a			"remove": "_untrackClassesElement"\u000a		} );\u000a\u000a		if ( options.keys ) {\u000a			processClassString( options.keys.match( /\u005cS+/g ) || [], true );\u000a		}\u000a		if ( options.extra ) {\u000a			processClassString( options.extra.match( /\u005cS+/g ) || [] );\u000a		}\u000a\u000a		return full.join( " " );\u000a	},\u000a\u000a	_untrackClassesElement: function( event ) {\u000a		var that = this;\u000a		$.each( that.classesElementLookup, function( key, value ) {\u000a			if ( $.inArray( event.target, value ) !== -1 ) {\u000a				that.classesElementLookup[ key ] = $( value.not( event.target ).get() );\u000a			}\u000a		} );\u000a	},\u000a\u000a	_removeClass: function( element, keys, extra ) {\u000a		return this._toggleClass( element, keys, extra, false );\u000a	},\u000a\u000a	_addClass: function( element, keys, extra ) {\u000a		return this._toggleClass( element, keys, extra, true );\u000a	},\u000a\u000a	_toggleClass: function( element, keys, extra, add ) {\u000a		add = ( typeof add === "boolean" ) ? add : extra;\u000a		var shift = ( typeof element === "string" || element === null ),\u000a			options = {\u000a				extra: shift ? keys : extra,\u000a				keys: shift ? element : keys,\u000a				element: shift ? this.element : element,\u000a				add: add\u000a			};\u000a		options.element.toggleClass( this._classes( options ), add );\u000a		return this;\u000a	},\u000a\u000a	_on: function( suppressDisabledCheck, element, handlers ) {\u000a		var delegateElement;\u000a		var instance = this;\u000a\u000a		// No suppressDisabledCheck flag, shuffle arguments\u000a		if ( typeof suppressDisabledCheck !== "boolean" ) {\u000a			handlers = element;\u000a			element = suppressDisabledCheck;\u000a			suppressDisabledCheck = false;\u000a		}\u000a\u000a		// No element argument, shuffle and use this.element\u000a		if ( !handlers ) {\u000a			handlers = element;\u000a			element = this.element;\u000a			delegateElement = this.widget();\u000a		} else {\u000a			element = delegateElement = $( element );\u000a			this.bindings = this.bindings.add( element );\u000a		}\u000a\u000a		$.each( handlers, function( event, handler ) {\u000a			function handlerProxy() {\u000a\u000a				// Allow widgets to customize the disabled handling\u000a				// - disabled as an array instead of boolean\u000a				// - disabled class as method for disabling individual parts\u000a				if ( !suppressDisabledCheck &&\u000a						( instance.options.disabled === true ||\u000a						$( this ).hasClass( "ui-state-disabled" ) ) ) {\u000a					return;\u000a				}\u000a				return ( typeof handler === "string" ? instance[ handler ] : handler )\u000a					.apply( instance, arguments );\u000a			}\u000a\u000a			// Copy the guid so direct unbinding works\u000a			if ( typeof handler !== "string" ) {\u000a				handlerProxy.guid = handler.guid =\u000a					handler.guid || handlerProxy.guid || $.guid++;\u000a			}\u000a\u000a			var match = event.match( /^([\u005cw:-]*)\u005cs*(.*)$/ );\u000a			var eventName = match[ 1 ] + instance.eventNamespace;\u000a			var selector = match[ 2 ];\u000a\u000a			if ( selector ) {\u000a				delegateElement.on( eventName, selector, handlerProxy );\u000a			} else {\u000a				element.on( eventName, handlerProxy );\u000a			}\u000a		} );\u000a	},\u000a\u000a	_off: function( element, eventName ) {\u000a		eventName = ( eventName || "" ).split( " " ).join( this.eventNamespace + " " ) +\u000a			this.eventNamespace;\u000a		element.off( eventName ).off( eventName );\u000a\u000a		// Clear the stack to avoid memory leaks (#10056)\u000a		this.bindings = $( this.bindings.not( element ).get() );\u000a		this.focusable = $( this.focusable.not( element ).get() );\u000a		this.hoverable = $( this.hoverable.not( element ).get() );\u000a	},\u000a\u000a	_delay: function( handler, delay ) {\u000a		function handlerProxy() {\u000a			return ( typeof handler === "string" ? instance[ handler ] : handler )\u000a				.apply( instance, arguments );\u000a		}\u000a		var instance = this;\u000a		return setTimeout( handlerProxy, delay || 0 );\u000a	},\u000a\u000a	_hoverable: function( element ) {\u000a		this.hoverable = this.hoverable.add( element );\u000a		this._on( element, {\u000a			mouseenter: function( event ) {\u000a				this._addClass( $( event.currentTarget ), null, "ui-state-hover" );\u000a			},\u000a			mouseleave: function( event ) {\u000a				this._removeClass( $( event.currentTarget ), null, "ui-state-hover" );\u000a			}\u000a		} );\u000a	},\u000a\u000a	_focusable: function( element ) {\u000a		this.focusable = this.focusable.add( element );\u000a		this._on( element, {\u000a			focusin: function( event ) {\u000a				this._addClass( $( event.currentTarget ), null, "ui-state-focus" );\u000a			},\u000a			focusout: function( event ) {\u000a				this._removeClass( $( event.currentTarget ), null, "ui-state-focus" );\u000a			}\u000a		} );\u000a	},\u000a\u000a	_trigger: function( type, event, data ) {\u000a		var prop, orig;\u000a		var callback = this.options[ type ];\u000a\u000a		data = data || {};\u000a		event = $.Event( event );\u000a		event.type = ( type === this.widgetEventPrefix ?\u000a			type :\u000a			this.widgetEventPrefix + type ).toLowerCase();\u000a\u000a		// The original event may come from any element\u000a		// so we need to reset the target on the new event\u000a		event.target = this.element[ 0 ];\u000a\u000a		// Copy original event properties over to the new event\u000a		orig = event.originalEvent;\u000a		if ( orig ) {\u000a			for ( prop in orig ) {\u000a				if ( !( prop in event ) ) {\u000a					event[ prop ] = orig[ prop ];\u000a				}\u000a			}\u000a		}\u000a\u000a		this.element.trigger( event, data );\u000a		return !( $.isFunction( callback ) &&\u000a			callback.apply( this.element[ 0 ], [ event ].concat( data ) ) === false ||\u000a			event.isDefaultPrevented() );\u000a	}\u000a};\u000a\u000a$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {\u000a	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {\u000a		if ( typeof options === "string" ) {\u000a			options = { effect: options };\u000a		}\u000a\u000a		var hasOptions;\u000a		var effectName = !options ?\u000a			method :\u000a			options === true || typeof options === "number" ?\u000a				defaultEffect :\u000a				options.effect || defaultEffect;\u000a\u000a		options = options || {};\u000a		if ( typeof options === "number" ) {\u000a			options = { duration: options };\u000a		}\u000a\u000a		hasOptions = !$.isEmptyObject( options );\u000a		options.complete = callback;\u000a\u000a		if ( options.delay ) {\u000a			element.delay( options.delay );\u000a		}\u000a\u000a		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {\u000a			element[ method ]( options );\u000a		} else if ( effectName !== method && element[ effectName ] ) {\u000a			element[ effectName ]( options.duration, options.easing, callback );\u000a		} else {\u000a			element.queue( function( next ) {\u000a				$( this )[ method ]();\u000a				if ( callback ) {\u000a					callback.call( element[ 0 ] );\u000a				}\u000a				next();\u000a			} );\u000a		}\u000a	};\u000a} );\u000a\u000avar widget = $.widget;\u000a\u000a\u000a\u000a\u000a// This file is deprecated\u000avar ie = $.ui.ie = !!/msie [\u005cw.]+/.exec( navigator.userAgent.toLowerCase() );\u000a\u000a/*!\u000a * jQuery UI Mouse 1.12.1\u000a * http://jqueryui.com\u000a *\u000a * Copyright jQuery Foundation and other contributors\u000a * Released under the MIT license.\u000a * http://jquery.org/license\u000a */\u000a\u000a//>>label: Mouse\u000a//>>group: Widgets\u000a//>>description: Abstracts mouse-based interactions to assist in creating certain widgets.\u000a//>>docs: http://api.jqueryui.com/mouse/\u000a\u000a\u000a\u000avar mouseHandled = false;\u000a$( document ).on( "mouseup", function() {\u000a	mouseHandled = false;\u000a} );\u000a\u000avar widgetsMouse = $.widget( "ui.mouse", {\u000a	version: "1.12.1",\u000a	options: {\u000a		cancel: "input, textarea, button, select, option",\u000a		distance: 1,\u000a		delay: 0\u000a	},\u000a	_mouseInit: function() {\u000a		var that = this;\u000a\u000a		this.element\u000a			.on( "mousedown." + this.widgetName, function( event ) {\u000a				return that._mouseDown( event );\u000a			} )\u000a			.on( "click." + this.widgetName, function( event ) {\u000a				if ( true === $.data( event.target, that.widgetName + ".preventClickEvent" ) ) {\u000a					$.removeData( event.target, that.widgetName + ".preventClickEvent" );\u000a					event.stopImmediatePropagation();\u000a					return false;\u000a				}\u000a			} );\u000a\u000a		this.started = false;\u000a	},\u000a\u000a	// TODO: make sure destroying one instance of mouse doesn't mess with\u000a	// other instances of mouse\u000a	_mouseDestroy: function() {\u000a		this.element.off( "." + this.widgetName );\u000a		if ( this._mouseMoveDelegate ) {\u000a			this.document\u000a				.off( "mousemove." + this.widgetName, this._mouseMoveDelegate )\u000a				.off( "mouseup." + this.widgetName, this._mouseUpDelegate );\u000a		}\u000a	},\u000a\u000a	_mouseDown: function( event ) {\u000a\u000a		// don't let more than one widget handle mouseStart\u000a		if ( mouseHandled ) {\u000a			return;\u000a		}\u000a\u000a		this._mouseMoved = false;\u000a\u000a		// We may have missed mouseup (out of window)\u000a		( this._mouseStarted && this._mouseUp( event ) );\u000a\u000a		this._mouseDownEvent = event;\u000a\u000a		var that = this,\u000a			btnIsLeft = ( event.which === 1 ),\u000a\u000a			// event.target.nodeName works around a bug in IE 8 with\u000a			// disabled inputs (#7620)\u000a			elIsCancel = ( typeof this.options.cancel === "string" && event.target.nodeName ?\u000a				$( event.target ).closest( this.options.cancel ).length : false );\u000a		if ( !btnIsLeft || elIsCancel || !this._mouseCapture( event ) ) {\u000a			return true;\u000a		}\u000a\u000a		this.mouseDelayMet = !this.options.delay;\u000a		if ( !this.mouseDelayMet ) {\u000a			this._mouseDelayTimer = setTimeout( function() {\u000a				that.mouseDelayMet = true;\u000a			}, this.options.delay );\u000a		}\u000a\u000a		if ( this._mouseDistanceMet( event ) && this._mouseDelayMet( event ) ) {\u000a			this._mouseStarted = ( this._mouseStart( event ) !== false );\u000a			if ( !this._mouseStarted ) {\u000a				event.preventDefault();\u000a				return true;\u000a			}\u000a		}\u000a\u000a		// Click event may never have fired (Gecko & Opera)\u000a		if ( true === $.data( event.target, this.widgetName + ".preventClickEvent" ) ) {\u000a			$.removeData( event.target, this.widgetName + ".preventClickEvent" );\u000a		}\u000a\u000a		// These delegates are required to keep context\u000a		this._mouseMoveDelegate = function( event ) {\u000a			return that._mouseMove( event );\u000a		};\u000a		this._mouseUpDelegate = function( event ) {\u000a			return that._mouseUp( event );\u000a		};\u000a\u000a		this.document\u000a			.on( "mousemove." + this.widgetName, this._mouseMoveDelegate )\u000a			.on( "mouseup." + this.widgetName, this._mouseUpDelegate );\u000a\u000a		event.preventDefault();\u000a\u000a		mouseHandled = true;\u000a		return true;\u000a	},\u000a\u000a	_mouseMove: function( event ) {\u000a\u000a		// Only check for mouseups outside the document if you've moved inside the document\u000a		// at least once. This prevents the firing of mouseup in the case of IE<9, which will\u000a		// fire a mousemove event if content is placed under the cursor. See #7778\u000a		// Support: IE <9\u000a		if ( this._mouseMoved ) {\u000a\u000a			// IE mouseup check - mouseup happened when mouse was out of window\u000a			if ( $.ui.ie && ( !document.documentMode || document.documentMode < 9 ) &&\u000a					!event.button ) {\u000a				return this._mouseUp( event );\u000a\u000a			// Iframe mouseup check - mouseup occurred in another document\u000a			} else if ( !event.which ) {\u000a\u000a				// Support: Safari <=8 - 9\u000a				// Safari sets which to 0 if you press any of the following keys\u000a				// during a drag (#14461)\u000a				if ( event.originalEvent.altKey || event.originalEvent.ctrlKey ||\u000a						event.originalEvent.metaKey || event.originalEvent.shiftKey ) {\u000a					this.ignoreMissingWhich = true;\u000a				} else if ( !this.ignoreMissingWhich ) {\u000a					return this._mouseUp( event );\u000a				}\u000a			}\u000a		}\u000a\u000a		if ( event.which || event.button ) {\u000a			this._mouseMoved = true;\u000a		}\u000a\u000a		if ( this._mouseStarted ) {\u000a			this._mouseDrag( event );\u000a			return event.preventDefault();\u000a		}\u000a\u000a		if ( this._mouseDistanceMet( event ) && this._mouseDelayMet( event ) ) {\u000a			this._mouseStarted =\u000a				( this._mouseStart( this._mouseDownEvent, event ) !== false );\u000a			( this._mouseStarted ? this._mouseDrag( event ) : this._mouseUp( event ) );\u000a		}\u000a\u000a		return !this._mouseStarted;\u000a	},\u000a\u000a	_mouseUp: function( event ) {\u000a		this.document\u000a			.off( "mousemove." + this.widgetName, this._mouseMoveDelegate )\u000a			.off( "mouseup." + this.widgetName, this._mouseUpDelegate );\u000a\u000a		if ( this._mouseStarted ) {\u000a			this._mouseStarted = false;\u000a\u000a			if ( event.target === this._mouseDownEvent.target ) {\u000a				$.data( event.target, this.widgetName + ".preventClickEvent", true );\u000a			}\u000a\u000a			this._mouseStop( event );\u000a		}\u000a\u000a		if ( this._mouseDelayTimer ) {\u000a			clearTimeout( this._mouseDelayTimer );\u000a			delete this._mouseDelayTimer;\u000a		}\u000a\u000a		this.ignoreMissingWhich = false;\u000a		mouseHandled = false;\u000a		event.preventDefault();\u000a	},\u000a\u000a	_mouseDistanceMet: function( event ) {\u000a		return ( Math.max(\u000a				Math.abs( this._mouseDownEvent.pageX - event.pageX ),\u000a				Math.abs( this._mouseDownEvent.pageY - event.pageY )\u000a			) >= this.options.distance\u000a		);\u000a	},\u000a\u000a	_mouseDelayMet: function( /* event */ ) {\u000a		return this.mouseDelayMet;\u000a	},\u000a\u000a	// These are placeholder methods, to be overriden by extending plugin\u000a	_mouseStart: function( /* event */ ) {},\u000a	_mouseDrag: function( /* event */ ) {},\u000a	_mouseStop: function( /* event */ ) {},\u000a	_mouseCapture: function( /* event */ ) { return true; }\u000a} );\u000a\u000a\u000a\u000a\u000a}));\u000a;\u000a
p0
.