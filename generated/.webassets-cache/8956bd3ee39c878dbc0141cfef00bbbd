V// source: js/lib/jquery/jquery.flot.time.js\u000a/* Pretty handling of time axes.\u000a\u000aCopyright (c) 2007-2014 IOLA and Ole Laursen.\u000aLicensed under the MIT license.\u000a\u000aSet axis.mode to "time" to enable. See the section "Time series data" in\u000aAPI.txt for details.\u000a\u000a*/\u000a\u000a(function($) {\u000a\u000a	var options = {\u000a		xaxis: {\u000a			timezone: null,		// "browser" for local to the client or timezone for timezone-js\u000a			timeformat: null,	// format string to use\u000a			twelveHourClock: false,	// 12 or 24 time in time mode\u000a			monthNames: null	// list of names of months\u000a		}\u000a	};\u000a\u000a	// round to nearby lower multiple of base\u000a\u000a	function floorInBase(n, base) {\u000a		return base * Math.floor(n / base);\u000a	}\u000a\u000a	// Returns a string with the date d formatted according to fmt.\u000a	// A subset of the Open Group's strftime format is supported.\u000a\u000a	function formatDate(d, fmt, monthNames, dayNames) {\u000a\u000a		if (typeof d.strftime == "function") {\u000a			return d.strftime(fmt);\u000a		}\u000a\u000a		var leftPad = function(n, pad) {\u000a			n = "" + n;\u000a			pad = "" + (pad == null ? "0" : pad);\u000a			return n.length == 1 ? pad + n : n;\u000a		};\u000a\u000a		var r = [];\u000a		var escape = false;\u000a		var hours = d.getHours();\u000a		var isAM = hours < 12;\u000a\u000a		if (monthNames == null) {\u000a			monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];\u000a		}\u000a\u000a		if (dayNames == null) {\u000a			dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];\u000a		}\u000a\u000a		var hours12;\u000a\u000a		if (hours > 12) {\u000a			hours12 = hours - 12;\u000a		} else if (hours == 0) {\u000a			hours12 = 12;\u000a		} else {\u000a			hours12 = hours;\u000a		}\u000a\u000a		for (var i = 0; i < fmt.length; ++i) {\u000a\u000a			var c = fmt.charAt(i);\u000a\u000a			if (escape) {\u000a				switch (c) {\u000a					case 'a': c = "" + dayNames[d.getDay()]; break;\u000a					case 'b': c = "" + monthNames[d.getMonth()]; break;\u000a					case 'd': c = leftPad(d.getDate()); break;\u000a					case 'e': c = leftPad(d.getDate(), " "); break;\u000a					case 'h':	// For back-compat with 0.7; remove in 1.0\u000a					case 'H': c = leftPad(hours); break;\u000a					case 'I': c = leftPad(hours12); break;\u000a					case 'l': c = leftPad(hours12, " "); break;\u000a					case 'm': c = leftPad(d.getMonth() + 1); break;\u000a					case 'M': c = leftPad(d.getMinutes()); break;\u000a					// quarters not in Open Group's strftime specification\u000a					case 'q':\u000a						c = "" + (Math.floor(d.getMonth() / 3) + 1); break;\u000a					case 'S': c = leftPad(d.getSeconds()); break;\u000a					case 'y': c = leftPad(d.getFullYear() % 100); break;\u000a					case 'Y': c = "" + d.getFullYear(); break;\u000a					case 'p': c = (isAM) ? ("" + "am") : ("" + "pm"); break;\u000a					case 'P': c = (isAM) ? ("" + "AM") : ("" + "PM"); break;\u000a					case 'w': c = "" + d.getDay(); break;\u000a				}\u000a				r.push(c);\u000a				escape = false;\u000a			} else {\u000a				if (c == "%") {\u000a					escape = true;\u000a				} else {\u000a					r.push(c);\u000a				}\u000a			}\u000a		}\u000a\u000a		return r.join("");\u000a	}\u000a\u000a	// To have a consistent view of time-based data independent of which time\u000a	// zone the client happens to be in we need a date-like object independent\u000a	// of time zones.  This is done through a wrapper that only calls the UTC\u000a	// versions of the accessor methods.\u000a\u000a	function makeUtcWrapper(d) {\u000a\u000a		function addProxyMethod(sourceObj, sourceMethod, targetObj, targetMethod) {\u000a			sourceObj[sourceMethod] = function() {\u000a				return targetObj[targetMethod].apply(targetObj, arguments);\u000a			};\u000a		};\u000a\u000a		var utc = {\u000a			date: d\u000a		};\u000a\u000a		// support strftime, if found\u000a\u000a		if (d.strftime != undefined) {\u000a			addProxyMethod(utc, "strftime", d, "strftime");\u000a		}\u000a\u000a		addProxyMethod(utc, "getTime", d, "getTime");\u000a		addProxyMethod(utc, "setTime", d, "setTime");\u000a\u000a		var props = ["Date", "Day", "FullYear", "Hours", "Milliseconds", "Minutes", "Month", "Seconds"];\u000a\u000a		for (var p = 0; p < props.length; p++) {\u000a			addProxyMethod(utc, "get" + props[p], d, "getUTC" + props[p]);\u000a			addProxyMethod(utc, "set" + props[p], d, "setUTC" + props[p]);\u000a		}\u000a\u000a		return utc;\u000a	};\u000a\u000a	// select time zone strategy.  This returns a date-like object tied to the\u000a	// desired timezone\u000a\u000a	function dateGenerator(ts, opts) {\u000a		if (opts.timezone == "browser") {\u000a			return new Date(ts);\u000a		} else if (!opts.timezone || opts.timezone == "utc") {\u000a			return makeUtcWrapper(new Date(ts));\u000a		} else if (typeof timezoneJS != "undefined" && typeof timezoneJS.Date != "undefined") {\u000a			var d = new timezoneJS.Date();\u000a			// timezone-js is fickle, so be sure to set the time zone before\u000a			// setting the time.\u000a			d.setTimezone(opts.timezone);\u000a			d.setTime(ts);\u000a			return d;\u000a		} else {\u000a			return makeUtcWrapper(new Date(ts));\u000a		}\u000a	}\u000a	\u000a	// map of app. size of time units in milliseconds\u000a\u000a	var timeUnitSize = {\u000a		"second": 1000,\u000a		"minute": 60 * 1000,\u000a		"hour": 60 * 60 * 1000,\u000a		"day": 24 * 60 * 60 * 1000,\u000a		"month": 30 * 24 * 60 * 60 * 1000,\u000a		"quarter": 3 * 30 * 24 * 60 * 60 * 1000,\u000a		"year": 365.2425 * 24 * 60 * 60 * 1000\u000a	};\u000a\u000a	// the allowed tick sizes, after 1 year we use\u000a	// an integer algorithm\u000a\u000a	var baseSpec = [\u000a		[1, "second"], [2, "second"], [5, "second"], [10, "second"],\u000a		[30, "second"], \u000a		[1, "minute"], [2, "minute"], [5, "minute"], [10, "minute"],\u000a		[30, "minute"], \u000a		[1, "hour"], [2, "hour"], [4, "hour"],\u000a		[8, "hour"], [12, "hour"],\u000a		[1, "day"], [2, "day"], [3, "day"],\u000a		[0.25, "month"], [0.5, "month"], [1, "month"],\u000a		[2, "month"]\u000a	];\u000a\u000a	// we don't know which variant(s) we'll need yet, but generating both is\u000a	// cheap\u000a\u000a	var specMonths = baseSpec.concat([[3, "month"], [6, "month"],\u000a		[1, "year"]]);\u000a	var specQuarters = baseSpec.concat([[1, "quarter"], [2, "quarter"],\u000a		[1, "year"]]);\u000a\u000a	function init(plot) {\u000a		plot.hooks.processOptions.push(function (plot, options) {\u000a			$.each(plot.getAxes(), function(axisName, axis) {\u000a\u000a				var opts = axis.options;\u000a\u000a				if (opts.mode == "time") {\u000a					axis.tickGenerator = function(axis) {\u000a\u000a						var ticks = [];\u000a						var d = dateGenerator(axis.min, opts);\u000a						var minSize = 0;\u000a\u000a						// make quarter use a possibility if quarters are\u000a						// mentioned in either of these options\u000a\u000a						var spec = (opts.tickSize && opts.tickSize[1] ===\u000a							"quarter") ||\u000a							(opts.minTickSize && opts.minTickSize[1] ===\u000a							"quarter") ? specQuarters : specMonths;\u000a\u000a						if (opts.minTickSize != null) {\u000a							if (typeof opts.tickSize == "number") {\u000a								minSize = opts.tickSize;\u000a							} else {\u000a								minSize = opts.minTickSize[0] * timeUnitSize[opts.minTickSize[1]];\u000a							}\u000a						}\u000a\u000a						for (var i = 0; i < spec.length - 1; ++i) {\u000a							if (axis.delta < (spec[i][0] * timeUnitSize[spec[i][1]]\u000a											  + spec[i + 1][0] * timeUnitSize[spec[i + 1][1]]) / 2\u000a								&& spec[i][0] * timeUnitSize[spec[i][1]] >= minSize) {\u000a								break;\u000a							}\u000a						}\u000a\u000a						var size = spec[i][0];\u000a						var unit = spec[i][1];\u000a\u000a						// special-case the possibility of several years\u000a\u000a						if (unit == "year") {\u000a\u000a							// if given a minTickSize in years, just use it,\u000a							// ensuring that it's an integer\u000a\u000a							if (opts.minTickSize != null && opts.minTickSize[1] == "year") {\u000a								size = Math.floor(opts.minTickSize[0]);\u000a							} else {\u000a\u000a								var magn = Math.pow(10, Math.floor(Math.log(axis.delta / timeUnitSize.year) / Math.LN10));\u000a								var norm = (axis.delta / timeUnitSize.year) / magn;\u000a\u000a								if (norm < 1.5) {\u000a									size = 1;\u000a								} else if (norm < 3) {\u000a									size = 2;\u000a								} else if (norm < 7.5) {\u000a									size = 5;\u000a								} else {\u000a									size = 10;\u000a								}\u000a\u000a								size *= magn;\u000a							}\u000a\u000a							// minimum size for years is 1\u000a\u000a							if (size < 1) {\u000a								size = 1;\u000a							}\u000a						}\u000a\u000a						axis.tickSize = opts.tickSize || [size, unit];\u000a						var tickSize = axis.tickSize[0];\u000a						unit = axis.tickSize[1];\u000a\u000a						var step = tickSize * timeUnitSize[unit];\u000a\u000a						if (unit == "second") {\u000a							d.setSeconds(floorInBase(d.getSeconds(), tickSize));\u000a						} else if (unit == "minute") {\u000a							d.setMinutes(floorInBase(d.getMinutes(), tickSize));\u000a						} else if (unit == "hour") {\u000a							d.setHours(floorInBase(d.getHours(), tickSize));\u000a						} else if (unit == "month") {\u000a							d.setMonth(floorInBase(d.getMonth(), tickSize));\u000a						} else if (unit == "quarter") {\u000a							d.setMonth(3 * floorInBase(d.getMonth() / 3,\u000a								tickSize));\u000a						} else if (unit == "year") {\u000a							d.setFullYear(floorInBase(d.getFullYear(), tickSize));\u000a						}\u000a\u000a						// reset smaller components\u000a\u000a						d.setMilliseconds(0);\u000a\u000a						if (step >= timeUnitSize.minute) {\u000a							d.setSeconds(0);\u000a						}\u000a						if (step >= timeUnitSize.hour) {\u000a							d.setMinutes(0);\u000a						}\u000a						if (step >= timeUnitSize.day) {\u000a							d.setHours(0);\u000a						}\u000a						if (step >= timeUnitSize.day * 4) {\u000a							d.setDate(1);\u000a						}\u000a						if (step >= timeUnitSize.month * 2) {\u000a							d.setMonth(floorInBase(d.getMonth(), 3));\u000a						}\u000a						if (step >= timeUnitSize.quarter * 2) {\u000a							d.setMonth(floorInBase(d.getMonth(), 6));\u000a						}\u000a						if (step >= timeUnitSize.year) {\u000a							d.setMonth(0);\u000a						}\u000a\u000a						var carry = 0;\u000a						var v = Number.NaN;\u000a						var prev;\u000a\u000a						do {\u000a\u000a							prev = v;\u000a							v = d.getTime();\u000a							ticks.push(v);\u000a\u000a							if (unit == "month" || unit == "quarter") {\u000a								if (tickSize < 1) {\u000a\u000a									// a bit complicated - we'll divide the\u000a									// month/quarter up but we need to take\u000a									// care of fractions so we don't end up in\u000a									// the middle of a day\u000a\u000a									d.setDate(1);\u000a									var start = d.getTime();\u000a									d.setMonth(d.getMonth() +\u000a										(unit == "quarter" ? 3 : 1));\u000a									var end = d.getTime();\u000a									d.setTime(v + carry * timeUnitSize.hour + (end - start) * tickSize);\u000a									carry = d.getHours();\u000a									d.setHours(0);\u000a								} else {\u000a									d.setMonth(d.getMonth() +\u000a										tickSize * (unit == "quarter" ? 3 : 1));\u000a								}\u000a							} else if (unit == "year") {\u000a								d.setFullYear(d.getFullYear() + tickSize);\u000a							} else {\u000a								d.setTime(v + step);\u000a							}\u000a						} while (v < axis.max && v != prev);\u000a\u000a						return ticks;\u000a					};\u000a\u000a					axis.tickFormatter = function (v, axis) {\u000a\u000a						var d = dateGenerator(v, axis.options);\u000a\u000a						// first check global format\u000a\u000a						if (opts.timeformat != null) {\u000a							return formatDate(d, opts.timeformat, opts.monthNames, opts.dayNames);\u000a						}\u000a\u000a						// possibly use quarters if quarters are mentioned in\u000a						// any of these places\u000a\u000a						var useQuarters = (axis.options.tickSize &&\u000a								axis.options.tickSize[1] == "quarter") ||\u000a							(axis.options.minTickSize &&\u000a								axis.options.minTickSize[1] == "quarter");\u000a\u000a						var t = axis.tickSize[0] * timeUnitSize[axis.tickSize[1]];\u000a						var span = axis.max - axis.min;\u000a						var suffix = (opts.twelveHourClock) ? " %p" : "";\u000a						var hourCode = (opts.twelveHourClock) ? "%I" : "%H";\u000a						var fmt;\u000a\u000a						if (t < timeUnitSize.minute) {\u000a							fmt = hourCode + ":%M:%S" + suffix;\u000a						} else if (t < timeUnitSize.day) {\u000a							if (span < 2 * timeUnitSize.day) {\u000a								fmt = hourCode + ":%M" + suffix;\u000a							} else {\u000a								fmt = "%b %d " + hourCode + ":%M" + suffix;\u000a							}\u000a						} else if (t < timeUnitSize.month) {\u000a							fmt = "%b %d";\u000a						} else if ((useQuarters && t < timeUnitSize.quarter) ||\u000a							(!useQuarters && t < timeUnitSize.year)) {\u000a							if (span < timeUnitSize.year) {\u000a								fmt = "%b";\u000a							} else {\u000a								fmt = "%b %Y";\u000a							}\u000a						} else if (useQuarters && t < timeUnitSize.year) {\u000a							if (span < timeUnitSize.year) {\u000a								fmt = "Q%q";\u000a							} else {\u000a								fmt = "Q%q %Y";\u000a							}\u000a						} else {\u000a							fmt = "%Y";\u000a						}\u000a\u000a						var rt = formatDate(d, fmt, opts.monthNames, opts.dayNames);\u000a\u000a						return rt;\u000a					};\u000a				}\u000a			});\u000a		});\u000a	}\u000a\u000a	$.plot.plugins.push({\u000a		init: init,\u000a		options: options,\u000a		name: 'time',\u000a		version: '1.0'\u000a	});\u000a\u000a	// Time-axis support used to be in Flot core, which exposed the\u000a	// formatDate function on the plot object.  Various plugins depend\u000a	// on the function, so we need to re-expose it here.\u000a\u000a	$.plot.formatDate = formatDate;\u000a	$.plot.dateGenerator = dateGenerator;\u000a\u000a})(jQuery);\u000a\u000a;\u000a
p0
.